<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Amethyst Documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="style/book.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="concepts/intro.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/state.html"><strong aria-hidden="true">3.1.</strong> State</a></li><li class="chapter-item expanded "><a href="concepts/entity_and_component.html"><strong aria-hidden="true">3.2.</strong> Entity and Component</a></li><li class="chapter-item expanded "><a href="concepts/resource.html"><strong aria-hidden="true">3.3.</strong> Resource</a></li><li class="chapter-item expanded "><a href="concepts/world.html"><strong aria-hidden="true">3.4.</strong> World</a></li><li class="chapter-item expanded "><a href="concepts/system.html"><strong aria-hidden="true">3.5.</strong> System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/system/system_initialization.html"><strong aria-hidden="true">3.5.1.</strong> System Initialization</a></li><li class="chapter-item expanded "><a href="concepts/system/system_desc_derive.html"><strong aria-hidden="true">3.5.2.</strong> SystemDesc Derive</a></li><li class="chapter-item expanded "><a href="concepts/system/implementing_the_system_desc_trait.html"><strong aria-hidden="true">3.5.3.</strong> Implementing the SystemDesc Trait</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/dispatcher.html"><strong aria-hidden="true">3.6.</strong> Dispatcher</a></li><li class="chapter-item expanded "><a href="concepts/event-channel.html"><strong aria-hidden="true">3.7.</strong> Event Channel</a></li></ol></li><li class="chapter-item expanded "><a href="pong-tutorial.html"><strong aria-hidden="true">4.</strong> Pong Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="pong-tutorial/pong-tutorial-01.html"><strong aria-hidden="true">4.1.</strong> Setting up the project</a></li><li class="chapter-item expanded "><a href="pong-tutorial/pong-tutorial-02.html"><strong aria-hidden="true">4.2.</strong> Drawing the Paddles</a></li><li class="chapter-item expanded "><a href="pong-tutorial/pong-tutorial-03.html"><strong aria-hidden="true">4.3.</strong> Moving the Paddles</a></li><li class="chapter-item expanded "><a href="pong-tutorial/pong-tutorial-04.html"><strong aria-hidden="true">4.4.</strong> Making a Ball Move and Bounce</a></li><li class="chapter-item expanded "><a href="pong-tutorial/pong-tutorial-05.html"><strong aria-hidden="true">4.5.</strong> Winning Rounds and Keeping Score</a></li><li class="chapter-item expanded "><a href="pong-tutorial/pong-tutorial-06.html"><strong aria-hidden="true">4.6.</strong> Adding audio</a></li><li class="chapter-item expanded "><a href="pong-tutorial/contribution.html"><strong aria-hidden="true">4.7.</strong> Call for Contribution</a></li></ol></li><li class="chapter-item expanded "><a href="math.html"><strong aria-hidden="true">5.</strong> Math</a></li><li class="chapter-item expanded "><a href="input.html"><strong aria-hidden="true">6.</strong> Input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="input/handling_input.html"><strong aria-hidden="true">6.1.</strong> Handling Input</a></li><li class="chapter-item expanded "><a href="input/how_to_define_custom_control_bindings.html"><strong aria-hidden="true">6.2.</strong> How to Define Custom Control Bindings</a></li></ol></li><li class="chapter-item expanded "><a href="assets.html"><strong aria-hidden="true">7.</strong> Assets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="assets/formats.html"><strong aria-hidden="true">7.1.</strong> Formats</a></li><li class="chapter-item expanded "><a href="assets/how_to_use_assets.html"><strong aria-hidden="true">7.2.</strong> How to Use Assets</a></li><li class="chapter-item expanded "><a href="assets/how_to_define_custom_assets.html"><strong aria-hidden="true">7.3.</strong> How to Define Custom Assets</a></li><li class="chapter-item expanded "><a href="assets/how_to_define_custom_formats.html"><strong aria-hidden="true">7.4.</strong> How to Define Custom Formats</a></li></ol></li><li class="chapter-item expanded "><a href="prefabs.html"><strong aria-hidden="true">8.</strong> Prefabs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="prefabs/prefabs_in_amethyst.html"><strong aria-hidden="true">8.1.</strong> Prefabs in Amethyst</a></li><li class="chapter-item expanded "><a href="prefabs/how_to_define_prefabs_prelude.html"><strong aria-hidden="true">8.2.</strong> How to Define Prefabs: Prelude</a></li><li class="chapter-item expanded "><a href="prefabs/how_to_define_prefabs_simple.html"><strong aria-hidden="true">8.3.</strong> How to Define Prefabs: Simple</a></li><li class="chapter-item expanded "><a href="prefabs/how_to_define_prefabs_aggregate.html"><strong aria-hidden="true">8.4.</strong> How to Define Prefabs: Aggregate</a></li><li class="chapter-item expanded "><a href="prefabs/how_to_define_prefabs_adapter.html"><strong aria-hidden="true">8.5.</strong> How to Define Prefabs: Adapter</a></li><li class="chapter-item expanded "><a href="prefabs/how_to_define_prefabs_asset.html"><strong aria-hidden="true">8.6.</strong> How to Define Prefabs: Asset</a></li><li class="chapter-item expanded "><a href="prefabs/how_to_define_prefabs_multi_handle.html"><strong aria-hidden="true">8.7.</strong> How to Define Prefabs: Multi-Handle</a></li><li class="chapter-item expanded "><a href="prefabs/prefabs_technical_explanation.html"><strong aria-hidden="true">8.8.</strong> Prefabs Technical Explanation</a></li></ol></li><li class="chapter-item expanded "><a href="animation.html"><strong aria-hidden="true">9.</strong> Animation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="animation/interpolation.html"><strong aria-hidden="true">9.1.</strong> Interpolation</a></li><li class="chapter-item expanded "><a href="animation/channel.html"><strong aria-hidden="true">9.2.</strong> Channel</a></li><li class="chapter-item expanded "><a href="animation/sampler.html"><strong aria-hidden="true">9.3.</strong> Sampler</a></li><li class="chapter-item expanded "><a href="animation/definition.html"><strong aria-hidden="true">9.4.</strong> Definition</a></li></ol></li><li class="chapter-item expanded "><a href="controlling_system_execution.html"><strong aria-hidden="true">10.</strong> Controlling System Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="controlling_system_execution/custom_game_data.html"><strong aria-hidden="true">10.1.</strong> Custom GameData</a></li><li class="chapter-item expanded "><a href="controlling_system_execution/state-specific_dispatcher.html"><strong aria-hidden="true">10.2.</strong> State-specific Dispatcher</a></li><li class="chapter-item expanded "><a href="controlling_system_execution/pausable_systems.html"><strong aria-hidden="true">10.3.</strong> Pausable Systems</a></li></ol></li><li class="chapter-item expanded "><a href="sprites.html"><strong aria-hidden="true">11.</strong> Sprites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sprites/set_up_the_render_pass.html"><strong aria-hidden="true">11.1.</strong> Set Up The Render Pass</a></li><li class="chapter-item expanded "><a href="sprites/load_the_texture.html"><strong aria-hidden="true">11.2.</strong> Load The Texture</a></li><li class="chapter-item expanded "><a href="sprites/define_the_sprite_sheet.html"><strong aria-hidden="true">11.3.</strong> Define The SpriteSheet</a></li><li class="chapter-item expanded "><a href="sprites/sprite_render_component.html"><strong aria-hidden="true">11.4.</strong> SpriteRender Component</a></li><li class="chapter-item expanded "><a href="sprites/modify_the_texture.html"><strong aria-hidden="true">11.5.</strong> Modify The Texture</a></li><li class="chapter-item expanded "><a href="sprites/orthographic_camera.html"><strong aria-hidden="true">11.6.</strong> Orthographic Camera</a></li></ol></li><li class="chapter-item expanded "><a href="tiles.html"><strong aria-hidden="true">12.</strong> Tiles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tiles/setup.html"><strong aria-hidden="true">12.1.</strong> Setup Features and Render Pass</a></li><li class="chapter-item expanded "><a href="tiles/create_a_tile_map.html"><strong aria-hidden="true">12.2.</strong> Create a Tile Map</a></li></ol></li><li class="chapter-item expanded "><a href="ui/introduction.html"><strong aria-hidden="true">13.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ui/simple_button.html"><strong aria-hidden="true">13.1.</strong> Creating a simple button</a></li><li class="chapter-item expanded "><a href="ui/interacting.html"><strong aria-hidden="true">13.2.</strong> Interacting with the UI</a></li><li class="chapter-item expanded "><a href="ui/state_interaction.html"><strong aria-hidden="true">13.3.</strong> Interacting through a state</a></li></ol></li><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">14.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing/test_examples.html"><strong aria-hidden="true">14.1.</strong> Test Examples</a></li></ol></li><li class="chapter-item expanded "><a href="glossary.html"><strong aria-hidden="true">15.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="appendices/a_config_files.html"><strong aria-hidden="true">16.</strong> Appendix A: Config Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendices/a_config_files/arena_config.html"><strong aria-hidden="true">16.1.</strong> Adding an Arena Config</a></li><li class="chapter-item expanded "><a href="appendices/a_config_files/ball_config.html"><strong aria-hidden="true">16.2.</strong> Adding a Ball Config</a></li><li class="chapter-item expanded "><a href="appendices/a_config_files/paddle_configs.html"><strong aria-hidden="true">16.3.</strong> Adding Paddle Configs</a></li></ol></li><li class="chapter-item expanded "><a href="appendices/b_migration_notes.html"><strong aria-hidden="true">17.</strong> Appendix B: Migration Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendices/b_migration_notes/cgmath_to_nalgebra.html"><strong aria-hidden="true">17.1.</strong> cgmath to nalgebra</a></li><li class="chapter-item expanded "><a href="appendices/b_migration_notes/rendy_migration.html"><strong aria-hidden="true">17.2.</strong> Rendy Migration</a></li><li class="chapter-item expanded "><a href="appendices/b_migration_notes/specs_migration.html"><strong aria-hidden="true">17.3.</strong> Specs Migration</a></li></ol></li><li class="chapter-item expanded "><a href="appendices/c_feature_gates.html"><strong aria-hidden="true">18.</strong> Appendix C: Feature Gates</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Amethyst Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="splash">
   <img src="./images/logo.svg" class="splogo" alt="Logo" height="110px"/>
</div>
<div class="drop"></div>
<h2><a class="header" href="#presentation" id="presentation">Presentation</a></h2>
<p>Howdy! This book will teach you everything you need to know about building video
games and interactive simulations with the Amethyst game engine. This engine is
written entirely in <a href="https://www.rust-lang.org/">Rust</a>, a safe and fast systems programming language,
and sports a clean and modern design. More correctly, though, Amethyst is
actually a collection of separate libraries and tools that collectively make up a
game engine.</p>
<p>Amethyst is free and open source software, distributed under a dual license of <a href="https://github.com/amethyst/amethyst/blob/master/docs/LICENSE-MIT">MIT</a>
and <a href="https://github.com/amethyst/amethyst/blob/master/docs/LICENSE-APACHE">Apache</a>. This means that the engine is given to you at no cost
and its source code is completely yours to tinker with. The code is available on
<a href="https://github.com/amethyst/amethyst/tree/master">GitHub</a>. Contributions and feature requests will always be welcomed!</p>
<h2><a class="header" href="#getting-started" id="getting-started">Getting started</a></h2>
<p>This book is split into several sections, with this introduction being the first. The others are:</p>
<ul>
<li><a href="./getting-started.html">Getting Started</a> – Prepare your computer for Amethyst development.</li>
<li><a href="./concepts/intro.html">Concepts</a> – An overview of the concepts used in Amethyst. Recommended.</li>
<li><a href="./pong-tutorial.html">Pong Tutorial</a> – Build a basic pong game in Rust.</li>
<li><a href="./math.html">Math</a> – A quick introduction to doing math with Amethyst.</li>
<li><a href="./animation.html">Animation</a> – Explains the architecture of the <code>amethyst_animation</code> crate.</li>
<li><a href="./controlling_system_execution.html">Controlling <code>System</code> Execution</a> – Shows you how to structure more complex games that need to change the <code>System</code> graph.</li>
<li><a href="./glossary.html">Glossary</a> – Defines special terms used throughout the book.</li>
<li><a href="./appendices/a_config_files.html">Appendix A: Config Files</a> – Shows you how to define your data in RON files.</li>
</ul>
<p>Read the crate-level <a href="https://docs.amethyst.rs/stable/amethyst/index.html">API documentation</a> for more details.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>Most of us have worked with quite a few game engines over the years, namely <a href="http://unity3d.com/">Unity</a>, <a href="https://www.unrealengine.com/">Unreal Engine</a>, <a href="http://jmonkeyengine.org/">JMonkeyEngine</a> and many more.
While they all are pretty solid solutions if you want to
build a quality game, each have their own pros and cons that you have to
weigh before using them, especially in regards to performance and scalability.</p>
<p>We think that basing the Amethyst engine on good and modern principles will allow us to make an open source game engine that can actually be more performant than those engines.
Those principles are:</p>
<ol>
<li>
<p>Modularity.</p>
<p>Modularity is at the core of the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix philosophy</a>, which proved itself to be an excellent way of developing software over the years.
You will always be free to use the built-in modules, or to write your own and integrate them easily into the engine.
Since modules are small and well integrated, it is easier to reason about what they do and how they relate to other modules.</p>
</li>
<li>
<p>Parallelism.</p>
<p>Modern computers, even cheap ones, all have multithreading with multicore CPUs. We expect that over the years, there will be more and more opportunities for parallelism to improve performance.
With a proper parallel engine, we are convinced that your game will be more and more performant over the years without even needing you to update it.</p>
</li>
<li>
<p>Data-oriented/Data-driven.</p>
<p>Building your game around the data makes it really easy to prototype and quickly build a game.
Complex behaviours like swapping assets during gameplay become a breeze, making testing and balancing a lot faster.</p>
</li>
</ol>
<h2><a class="header" href="#why-use-amethyst" id="why-use-amethyst">Why use Amethyst?</a></h2>
<p>While there are a lot of <a href="http://arewegameyet.com/">great building blocks</a> in the Rust ecosystem, using the Amethyst engine instead of building your own game engine definitely has a lot of advantages.</p>
<p>First of all, the engine is based on the <a href="https://github.com/slide-rs/specs">Specs</a> library, which is a common base on which the engine's concepts are built. For a great introduction to game development with Rust and an Entity Component System, see this <a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">great talk by Catherine West</a>. Amethyst's take on ECS is described in the <a href="./concepts/intro.html">concepts</a> section of the book.
A lot of features have been glued together using those:</p>
<p>There are the obvious ones:</p>
<ul>
<li>Transformations</li>
<li>Graphics</li>
<li>Windowing</li>
<li>Inputs</li>
<li>Audio</li>
<li>Etc...</li>
</ul>
<p>And also the less known but also essential features:</p>
<ul>
<li>Animations</li>
<li>Gltf</li>
<li>Locales</li>
<li>Networking</li>
</ul>
<p>If you were not to use Amethyst, not only would you need to create all those features (or use pre-existing crates), but you would also need to glue the layers together.</p>
<p>Amethyst does all of this for you, so that you can focus on making your game instead of worrying about the low-level details.</p>
<p>Futhermore, because of the architecture of Amethyst, almost all the parts are both configurable and replaceable. This means that if you do want to change something to suit your needs, there's always a way to do it.</p>
<p>For example, the <a href="https://github.com/tomaka/rodio">rodio</a> crate is currently used for the audio features in the engine, but if you would rather use something more complex or a custom solution, all you have to do is add some glue that moves the data coming from Specs into the library that you are using to play and control the audio, without even having to touch the engine code!</p>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<p>We are always happy to welcome new contributors!</p>
<p>To know where to start, we suggest you read our <a href="https://github.com/amethyst/amethyst/blob/master/docs/CONTRIBUTING.md">contribution guidelines</a></p>
<p>If you want to contribute, or have questions, let us know either on <a href="https://github.com/amethyst/amethyst/">GitHub</a>, or on <a href="https://discord.gg/amethyst">Discord</a>.</p>
<h1><a class="header" href="#getting-started-1" id="getting-started-1">Getting started</a></h1>
<h2><a class="header" href="#setting-up-rust" id="setting-up-rust">Setting up Rust</a></h2>
<p>We recommend using <a href="https://rustup.rs">rustup</a> to easily install the latest stable version of rust.
Instructions should be on the screen once rustup is downloaded.</p>
<blockquote>
<p><strong>Updating Rust:</strong> If you already have Rust installed, make sure you're using the
the latest version by running <code>rustup update</code>.</p>
</blockquote>
<p>We recommend using the stable version of Rust, as Rust nightlies tend to break rather
often.</p>
<blockquote>
<p><strong>Using the stable toolchain:</strong> Rustup can be configured to default to the stable
toolchain by running <code>rustup default stable</code>.</p>
</blockquote>
<h2><a class="header" href="#required-dependencies" id="required-dependencies">Required dependencies</a></h2>
<p>Please check the dependencies section of the
<a href="https://github.com/amethyst/amethyst/blob/master/README.md#dependencies">README.md</a>
for details on what dependencies are required for compiling Amethyst.</p>
<p>Please note that you need to have a functional graphics driver installed.
If you get a panic about the renderer unable to create the rendering context
when trying to run an example, a faulty driver installation could be the issue.</p>
<h2><a class="header" href="#setting-up-an-amethyst-project" id="setting-up-an-amethyst-project">Setting up an Amethyst Project</a></h2>
<p>You can either use our Starter Projects or do it the manual way.</p>
<h3><a class="header" href="#creating-a-project-the-manual-way" id="creating-a-project-the-manual-way">Creating a Project the manual way.</a></h3>
<ul>
<li>Add <code>amethyst</code> as a dependency in your <code>Cargo.toml</code>.</li>
<li>Create a <code>config</code> folder and put a <code>display.ron</code> in it.</li>
<li>(Optional) Copy the code from one of the amethyst's examples.</li>
</ul>
<h3><a class="header" href="#starter-project" id="starter-project">Starter Project</a></h3>
<p>If you want to get running as quickly as possible and start playing around with Amethyst, you can also use a starter project. These are specifically made for certain types of games and will set you up with the groundwork needed to start right away.<br />
The <code>README.md</code> file on these will include everything you need to know to run the starter project.</p>
<blockquote>
<p><strong>Note:</strong> Right now, the only starter available is for 2D games. This will expand over time, and offer more options for different types of games.</p>
</blockquote>
<ul>
<li><a href="https://github.com/amethyst/amethyst-starter-2d">2D Starter</a></li>
</ul>
<h3><a class="header" href="#important-note-on-versioning" id="important-note-on-versioning">Important note on versioning</a></h3>
<p>Amethyst is divided into two major versions:</p>
<ul>
<li>The released crates.io version, which is the latest version available on crates.io</li>
<li>The git (master) version, which is the current unreleased development snapshot of Amethyst available on <a href="https://github.com/amethyst/amethyst">Github</a></li>
</ul>
<blockquote>
<p><strong>Note:</strong> You can see which version you're currently looking at by checking the URL
in your browser. The book/documentation for <code>master</code> contains &quot;master&quot; in the address,
the crates.io version is called &quot;stable&quot;.</p>
</blockquote>
<p>Depending on the book version that you choose to read, make sure that the amethyst version in your Cargo.toml matches that.</p>
<p>For the released crates.io version, you should have something like this:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = &quot;LATEST_CRATES.IO_VERSION&quot;
</code></pre>
<p>The latest crates.io version can be found <a href="https://crates.io/crates/amethyst">here</a>.</p>
<p>If you want to use the latest unreleased changes, your Cargo.toml file should look like this:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = { git = &quot;https://github.com/amethyst/amethyst&quot;, rev = &quot;COMMIT_HASH&quot; }
</code></pre>
<p>The commit hash part is optional. It indicates which specific commit your project uses, to prevent unexpected breakage when we make changes to the git version.</p>
<h1><a class="header" href="#concepts-behind-amethyst" id="concepts-behind-amethyst">Concepts behind Amethyst</a></h1>
<p>Amethyst uses quite a few concepts that you might not be familiar with.
This section of the book explains what they are, how they work and
how they relate to each other.</p>
<p>If you are a practical person and want to quickly get into the code, you can skip to the <a href="concepts/../pong-tutorial.html">pong tutorial</a>
section of the book, which is focused on practice. 
That said, reading this section is suggested, as it can be hard to understand the examples without knowing the theory presented here.</p>
<p>If you don't understand how something works in amethyst, knowing the concepts presented here will help you understand how some implementations are made.</p>
<h2><a class="header" href="#chapters" id="chapters">Chapters</a></h2>
<ul>
<li><a href="concepts/./state.html">State</a></li>
<li><a href="concepts/./entity_and_component.html">Entity and Component</a></li>
<li><a href="concepts/./resource.html">Resource</a></li>
<li><a href="concepts/./world.html">World</a></li>
<li><a href="concepts/./system.html">System</a></li>
<li><a href="concepts/./dispatcher.html">Dispatcher</a></li>
<li><a href="concepts/./event-channel.html">EventChannel</a></li>
</ul>
<h1><a class="header" href="#state" id="state">State</a></h1>
<h2><a class="header" href="#what-is-a-state" id="what-is-a-state">What is a state?</a></h2>
<p>The word &quot;state&quot; can mean a lot of different things in computer science.
In the case of amethyst, it is used to represent the &quot;game state&quot;.</p>
<p>A game state is a <em>general</em> and <em>global</em> section of the game.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>As an example, let's say you are making a pong game.</p>
<ul>
<li>When the user opens up the game, it first loads all the assets and shows a loading screen.</li>
<li>Then, the main menu shows up, asking you if you want to start a game in single or multiplayer.</li>
<li>Once you select an option, the game displays the paddles and the ball and starts playing.</li>
<li>By pressing escape, you can toggle the &quot;pause&quot; menu.</li>
<li>Once the score limit is reached, a result screen is shown with a button to go back to the main menu.</li>
</ul>
<p>The game can be divided into different states:</p>
<ul>
<li>LoadingState</li>
<li>MainMenuState</li>
<li>GameplayState</li>
<li>PauseState</li>
<li>ResultState</li>
</ul>
<p>While you could effectively insert all the game's logic into a single state <code>GameState</code>,
dividing it into multiple parts makes it much easier to reason about and maintain.</p>
<h2><a class="header" href="#state-manager" id="state-manager">State Manager</a></h2>
<p>Amethyst has a built-in state manager, which allows easily switching between different <code>State</code>s.
It is based on the concept of a pushdown-automaton, which is a combination of a Stack and a State Machine.</p>
<h3><a class="header" href="#stack" id="stack">Stack</a></h3>
<p>The stack concept makes it so you can &quot;push&quot; <code>State</code>s on top of each other.</p>
<p>If we take the pong example of earlier, you can push the <code>PauseState</code> over the <code>GameplayState</code>.</p>
<p>When you want to go out of pause, you pop the <code>PauseState</code> out of the stack and you are back into the <code>GameplayState</code>, just as you left it.</p>
<h3><a class="header" href="#state-machine" id="state-machine">State Machine</a></h3>
<p>The concept of State Machine can be pretty complex, but here we will only explain the basics of it.
The State Machine is usually composed of two elements: Transitions and Events.</p>
<p>Transitions are simply the &quot;switching&quot; between two states.</p>
<p>For example, from <code>LoadingState</code>, go to state <code>MainMenuState</code>.</p>
<p>Amethyst has multiple types of transitions.</p>
<ul>
<li>You can Push a <code>State</code> over another.</li>
<li>You can also Switch a <code>State</code>, which replaces the current <code>State</code> with a new one.</li>
</ul>
<p>Events are what trigger the transitions. In the case of amethyst, it is the different methods called on the <code>State</code>. Continue reading to learn about them.</p>
<h2><a class="header" href="#life-cycle" id="life-cycle">Life Cycle</a></h2>
<p><code>State</code>s are only valid for a certain period of time, during which a lot of things can occur.
A <code>State</code> contains methods that reflect the most common of those events:</p>
<ul>
<li>on_start: When a <code>State</code> is added to the stack, this method is called on it.</li>
<li>on_stop: When a <code>State</code> is removed from the stack, this method is called on it.</li>
<li>on_pause: When a <code>State</code> is pushed over the current one, the current one is paused, and this method is called on it.</li>
<li>on_resume: When the <code>State</code> that was pushed over the current <code>State</code> is popped, the current one resumes, and this method is called on the now-current <code>State</code>.</li>
<li>handle_event: Allows easily handling events, like the window closing or a key being pressed.</li>
<li>fixed_update: This method is called on the active <code>State</code> at a fixed time interval (1/60th second by default).</li>
<li>update: This method is called on the active <code>State</code> as often as possible by the engine.</li>
<li>shadow_update: This method is called as often as possible by the engine on all <code>State</code>s which are on the <code>StateMachines</code> stack, including the active <code>State</code>. Unlike <code>update</code>, this does not return a <code>Trans</code>.</li>
<li>shadow_fixed_update: This method is called at a fixed time interval (1/60th second by default) on all <code>State</code>s which are on the <code>StateMachines</code> stack, including the active <code>State</code>. Unlike <code>fixed_update</code>, this does not return a <code>Trans</code>.</li>
</ul>
<p>If you aren't using <code>SimpleState</code> or <code>EmptyState</code>, you <em>must</em> implement the <code>update</code> method to call <code>data.data.update(&amp;mut data.world)</code>.</p>
<h2><a class="header" href="#game-data" id="game-data">Game Data</a></h2>
<p><code>State</code>s can have arbitrary data associated with them.
If you need to store data that is tightly coupled to your <code>State</code>, the classic way is to put it in the <code>State</code>'s struct.</p>
<p><code>State</code>s also have internal data, which is any type T.
In most cases, the two following are the most used: <code>()</code> and <code>GameData</code>.</p>
<p><code>()</code> means that there is no data associated with this <code>State</code>. This is usually used for tests and not for actual games.
<code>GameData</code> is the de-facto standard. It is a struct containing a <code>Dispatcher</code>. This will be discussed later.</p>
<p>When calling your <code>State</code>'s methods, the engine will pass a <code>StateData</code> struct which contains both the <code>World</code> (which will also be discussed later) and the Game Data type that you chose.</p>
<h2><a class="header" href="#code" id="code">Code</a></h2>
<p>Yes! It's finally time to get some code in here!</p>
<p>Here will just be a small code snippet that shows the basics of <code>State</code>'s usage.
For more advanced examples, see the following pong tutorial.</p>
<h3><a class="header" href="#creating-a-state" id="creating-a-state">Creating a State</a></h3>
<pre><code class="language-rust edition2018 no_run noplaypen">extern crate amethyst;
use amethyst::prelude::*;

struct GameplayState {
    /// The `State`-local data. Usually you will not have anything.
    /// In this case, we have the number of players here.
    player_count: u8,
}

impl SimpleState for GameplayState {
    fn on_start(&amp;mut self, _data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        println!(&quot;Number of players: {}&quot;, self.player_count);
    }
}
</code></pre>
<p>That's a lot of code, indeed!</p>
<p>We first declare the <code>State</code>'s struct <code>GameplayState</code>.</p>
<p>In this case, we give it some data: <code>player_count</code>, a byte.</p>
<p>Then, we implement the <code>SimpleState</code> trait for our <code>GameplayState</code>.
<code>SimpleState</code> is a shorthand for <code>State&lt;GameData&lt;'static, 'static&gt;, ()&gt;</code> where <code>GameData</code> is the internal shared data between states.</p>
<h3><a class="header" href="#switching-state" id="switching-state">Switching State</a></h3>
<p>Now, if we want to change to a second state, how do we do it?</p>
<p>Well, we'll need to use one of the methods that return the <code>Trans</code> type.</p>
<p>Those are:</p>
<ul>
<li><code>handle_event</code></li>
<li><code>fixed_update</code></li>
<li><code>update</code></li>
</ul>
<p>Let's use handle_event to go to the <code>PausedState</code> and come back by pressing the &quot;Escape&quot; key.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">extern crate amethyst;
use amethyst::prelude::*;
use amethyst::input::{VirtualKeyCode, is_key_down};

struct GameplayState;
struct PausedState;

// This time around, we are using () instead of GameData, because we don't have any `System`s that need to be updated.
// (They are covered in the dedicated section of the book.)
// Instead of writing `State&lt;(), StateEvent&gt;`, we can instead use `EmptyState`.
impl EmptyState for GameplayState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: StateEvent) -&gt; EmptyTrans {
        if let StateEvent::Window(event) = &amp;event {
            if is_key_down(&amp;event, VirtualKeyCode::Escape) {
                // Pause the game by going to the `PausedState`.
                return Trans::Push(Box::new(PausedState));
            }
        }

        // Escape isn't pressed, so we stay in this `State`.
        Trans::None
    }
}

impl EmptyState for PausedState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: StateEvent) -&gt; EmptyTrans {
        if let StateEvent::Window(event) = &amp;event {
            if is_key_down(&amp;event, VirtualKeyCode::Escape) {
                // Go back to the `GameplayState`.
                return Trans::Pop;
            }
        }

        // Escape isn't pressed, so we stay in this `State`.
        Trans::None
    }
}
</code></pre>
<h3><a class="header" href="#event-handling" id="event-handling">Event Handling</a></h3>
<p>As you already saw, we can handle events from the <code>handle_event</code> method.
But what is this weird <code>StateEvent</code> all about?</p>
<p>Well, it is simply an enum. It regroups multiple types of events that are emitted throughout the engine by default.
To change the set of events that the state receives, you create a new event enum and derive <code>EventReader</code> for that type.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#[macro_use] extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::ui::UiEvent;
</span><span class="boring">use amethyst::input::{VirtualKeyCode, is_key_down};
</span><span class="boring">use amethyst::winit::Event;
</span>
// These imports are required for the #[derive(EventReader)] code to build
use amethyst::core::{
    ecs::{Read, SystemData, World},
    shrev::{ReaderId, EventChannel},
    EventReader
};

#[derive(Clone, Debug)]
pub struct AppEvent {
    data: i32,
}

#[derive(Debug, EventReader, Clone)]
#[reader(MyEventReader)]
pub enum MyEvent {
    Window(Event),
    Ui(UiEvent),
    App(AppEvent),
}

struct GameplayState;

impl State&lt;(), MyEvent&gt; for GameplayState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: MyEvent) -&gt; Trans&lt;(), MyEvent&gt; {
        match event {
            MyEvent::Window(_) =&gt; {}, // Events related to the window and inputs.
            MyEvent::Ui(_) =&gt; {}, // Ui event. Button presses, mouse hover, etc...
            MyEvent::App(ev) =&gt; println!(&quot;Got an app event: {:?}&quot;, ev),
        };

        Trans::None
    }
}

<span class="boring">fn main() {}
</span></code></pre>
<p>To make <code>Application</code> aware of the change to which events to send to the state, you also need to supply both the
event type, and the <code>EventReader</code> type (the name you give in the <code>#[reader(SomeReader)]</code> derive attribute) when
the <code>Application</code> is created. This is done by replacing <code>Application::build</code> (or <code>Application::new</code>) with
<code>CoreApplication::&lt;_, MyEvent, MyEventReader&gt;::build()</code> (or <code>CoreApplication::&lt;_, MyEvent, MyEventReader&gt;::new()</code>).</p>
<p><em>Note: Events are gathered from <code>EventChannel</code>s. <code>EventChannel</code>s are covered in the dedicated book section.</em></p>
<h1><a class="header" href="#entity-and-component" id="entity-and-component">Entity and Component</a></h1>
<h2><a class="header" href="#what-are-entity-and-component" id="what-are-entity-and-component">What are <code>Entity</code> and <code>Component</code>?</a></h2>
<p>An <code>Entity</code> represents a single object in your world. <code>Component</code> represents one aspect of an object. For example, a bottle of water has a shape, a volume, a color and is made of a material (usually plastic). In this example, the bottle is the entity, and the properties are components.</p>
<h2><a class="header" href="#entity-and-component-in-amethyst" id="entity-and-component-in-amethyst">Entity and Component in Amethyst</a></h2>
<p>In an inheritance design, entity usually contains components. All the data and methods related to an entity are stored within. However, in the ECS design, entity is just a general purpose object. In fact, the implementation of <code>Entity</code> in Amethyst is simply:</p>
<pre><code class="language-rust ignore">struct Entity(u32, Generation);
</code></pre>
<p>where u32 is the id of the entity and generation is used to check if the entity has been deleted.</p>
<p><code>Entity</code>s are stored in a special container <code>EntitiesRes</code>. Whereas the data associated with the entities are grouped into components and stored in the designated storages.</p>
<p>Consider an example where you have three objects: two bottles and a person.</p>
<table><thead><tr><th align="center">object</th><th align="center">x</th><th align="center">y</th><th align="center">shape</th><th align="center">color</th><th align="center">name</th></tr></thead><tbody>
<tr><td align="center">Bottle A</td><td align="center">150.0</td><td align="center">202.1</td><td align="center">&quot;round&quot;</td><td align="center">&quot;red&quot;</td><td align="center"></td></tr>
<tr><td align="center">Bottle B</td><td align="center">570.0</td><td align="center">122.0</td><td align="center">&quot;square&quot;</td><td align="center">&quot;white&quot;</td><td align="center"></td></tr>
<tr><td align="center">Person C</td><td align="center">100.5</td><td align="center">300.8</td><td align="center"></td><td align="center"></td><td align="center">&quot;Peter&quot;</td></tr>
</tbody></table>
<p>We can separate bottle's properties into <code>PositionComponent</code> and <code>BottleComponent</code>, and person's properties into <code>PositionComponent</code> and <code>PersonComponent</code>. Here's an illustration of how the three objects would be stored.</p>
<p><img src="concepts/../images/concepts/component_and_entity.svg" alt="How entity and components are stored" /></p>
<p>As you could see from the graph, entities do not store data. Nor do they know any information about their components. They serve the purpose of object identification and tracking object existence. The component storage stores all the data and their connection to entities.</p>
<p>If you are familiar with relational databases, this organization looks quite similar to the tables in a database, where entity id serves as the key in each table. In fact, you can even join components or entities like joining tables. For example, to update the position of all the persons, you will need to join the <code>PersonComponent</code> and the <code>PositionComponent</code>. </p>
<h2><a class="header" href="#entitiesres" id="entitiesres">EntitiesRes</a></h2>
<p>Even though the structure of the entity is pretty simple, entity manipulation is very sophisticated and crucial to game performance. This is why entities are handled exclusively by the struct <code>EntitiesRes</code>. <code>EntitiesRes</code> provides two ways for creating/deleting entities:</p>
<ul>
<li>Immediate creation/deletion, used for game setup or clean up.</li>
<li>Lazy creation/deletion, used in the game play state. It updates entities in batch at the end of each game loop. This is also referred to as atomic creation/deletion.</li>
</ul>
<p>You will see how these methods are used in later chapters.</p>
<h2><a class="header" href="#declaring-a-component" id="declaring-a-component">Declaring a component</a></h2>
<p>To declare a component, you first declare the relevant underlying data:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::core::math::{Isometry3, Vector3};
</span>
/// This `Component` describes the shape of an `Entity`
enum Shape {
    Sphere { radius: f32 },
    Cuboid { height: f32, width: f32, depth: f32 },
}

/// This `Component` describes the transform of an `Entity`
pub struct Transform {
    /// Translation + rotation value
    iso: Isometry3&lt;f32&gt;,
    /// Scale vector
    scale: Vector3&lt;f32&gt;,
}
</code></pre>
<p>and then you implement the <code>Component</code> trait for them:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">struct Shape;
</span><span class="boring">struct Transform;
</span>use amethyst::ecs::{Component, DenseVecStorage, FlaggedStorage};

impl Component for Shape {
    type Storage = DenseVecStorage&lt;Self&gt;;
}

impl Component for Transform {
    type Storage = FlaggedStorage&lt;Self, DenseVecStorage&lt;Self&gt;&gt;;
}
</code></pre>
<p>The storage type will determine how you store the component, but it will not initialize the storage. Storage is initialized when you register a component in <code>World</code> or when you use that component in a <code>System</code>.</p>
<h2><a class="header" href="#storages" id="storages">Storages</a></h2>
<p>There are a few storage strategies for different usage scenarios. The most commonly used types are <code>DenseVecStorage</code>, <code>VecStorage</code> and <code>FlaggedStorage</code>.</p>
<ul>
<li><code>DenseVecStorage</code>: Elements are stored in a contiguous vector. No empty space is left between <code>Component</code>s, allowing a lowered memory usage for big components.</li>
<li><code>VecStorage</code>: Elements are stored into a sparse array. The entity id is the same as the index of component. If your component is small (&lt;= 16 bytes) or is carried by most entities, this is preferable over <code>DenseVecStorage</code>.</li>
<li><code>FlaggedStorage</code>: Used to keep track of changes of a component. Useful for caching purposes.</li>
</ul>
<!-- DenseVec Storage Diagram Table -->
<div style="width: 100%">
    <h4 style="text-align: center; font-weight: bold">DenseVecStorage ( <em>entity_id</em> maps to <em>data_id</em> )</h4>
    <div style="display: flex">
        <div style="margin-right: 3em">
            <table style="text-align: center;">
                <tr><td style="background-color: #D8E5FD; color: black;">data</td></tr>
                <tr><td style="background-color: #D8E5FD; color: black;">data_id</td></tr>
                <tr><td style="background-color: #D8E5FD; color: black;">entity_id</td></tr>
            </table>
        </div>
        <div style="flex-grow: 1; text-align: center">
            <table style="width: 100%">
                <tr>
                    <td>data</td>
                    <td>data</td>
                    <td>data</td>
                    <td>data</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>2</td>
                    <td>3</td>
                    <td>1</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>5</td>
                    <td>9</td>
                    <td>...</td>
                </tr>
            </table>
        </div>
</div>
<!-- VecStorage Diagram Table -->
<div style="width: 100%">
    <h4 style="text-align: center; font-weight: bold">VecStorage ( <em>entity_id</em> = data index, can be empty )</h4>
    <div style="display: flex">
        <div style="margin-right: 3em">
            <table><tr><td style="background-color: #D8E5FD; color: black;">data</td></tr></table>
        </div>
        <div style="flex-grow: 1; text-align: center">
            <table style="width: 100%">
                <tr>
                    <td>data</td>
                    <td>data</td>
                    <td style="background-color: #E22C2C99; color: black;">empty</td>
                    <td>data</td>
                    <td>...</td>
                </tr>
            </table>
        </div>
</div>
<p>For more information, see the <a href="https://docs.rs/specs/latest/specs/storage/index.html">specs storage reference</a>
and the <a href="https://specs.amethyst.rs/docs/tutorials/05_storages.html">&quot;Storages&quot; section</a> of the specs book.</p>
<p>There are a bunch more storages, and deciding which one is the best isn't trivial and should be done based on careful benchmarking. A general rule is: if your component is used in over 30% of entities, use <code>VecStorage</code>. If you don't know which one you should use, <code>DenseVecStorage</code> is a good default. It will need more memory than <code>VecStorage</code> for pointer-sized components, but it will perform well for most scenarios.</p>
<h2><a class="header" href="#tags" id="tags">Tags</a></h2>
<p>Components can also be used to &quot;tag&quot; entities.
The usual way to do it is to create an empty struct, and implement <code>Component</code> using <code>NullStorage</code> as the <code>Storage</code> type for it.
Null storage means that it is not going to take memory space to store those components.</p>
<p>You will learn how to use those tag components in the System chapter.</p>
<h1><a class="header" href="#resource" id="resource">Resource</a></h1>
<h2><a class="header" href="#what-is-a-resource" id="what-is-a-resource">What is a resource?</a></h2>
<p>A resource is any type that stores data that you might need for your game AND that is not specific to an entity.
For example, the score of a pong game is global to the whole game and isn't owned by any of the entities (paddle, ball and even the ui score text).</p>
<h2><a class="header" href="#creating-a-resource" id="creating-a-resource">Creating a resource</a></h2>
<p>Resources are stored in the <code>World</code> container.</p>
<p>Adding a resource to a <code>World</code> instance is done like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::ecs::World;

struct MyResource {
    pub game_score: i32,
}

fn main() {
    let mut world = World::empty();
    
    let my = MyResource {
        game_score: 0,
    };
    
    world.insert(my);
}
</code></pre>
<h2><a class="header" href="#fetching-a-resource-from-world" id="fetching-a-resource-from-world">Fetching a resource (from <code>World</code>)</a></h2>
<p>Fetching a resource can be done like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">#[derive(Debug, PartialEq)]
</span><span class="boring">struct MyResource {
</span><span class="boring">  pub game_score: i32,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::empty();
</span><span class="boring">  let my = MyResource{
</span><span class="boring">    game_score: 0,
</span><span class="boring">  };
</span><span class="boring">  world.insert(my);
</span>  // try_fetch returns a Option&lt;Fetch&lt;MyResource&gt;&gt;
  let fetched = world.try_fetch::&lt;MyResource&gt;();
  if let Some(fetched_resource) = fetched {
      //dereference Fetch&lt;MyResource&gt; to access data
      assert_eq!(*fetched_resource, MyResource{ game_score: 0, });
  } else {
      println!(&quot;No MyResource present in `World`&quot;);
  }
<span class="boring">}
</span></code></pre>
<p>If you want to get a resource and create it if it doesn't exist:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::empty();
</span><span class="boring">  let my = MyResource;
</span>  // If the resource isn't inside `World`, 
  // it will insert the instance we created earlier.
let fetched = world.entry::&lt;MyResource&gt;().or_insert_with(|| my);
<span class="boring">}
</span></code></pre>
<p>If you want to change a resource that is already inside of <code>World</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">struct MyResource {
</span><span class="boring">  pub game_score: i32,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::empty();
</span><span class="boring">  let my = MyResource{
</span><span class="boring">    game_score: 0,
</span><span class="boring">  };
</span><span class="boring">  world.insert(my);
</span>  // try_fetch_mut returns a Option&lt;FetchMut&lt;MyResource&gt;&gt;
  let fetched = world.try_fetch_mut::&lt;MyResource&gt;();
  if let Some(mut fetched_resource) = fetched {
    assert_eq!(fetched_resource.game_score, 0);
    fetched_resource.game_score = 10;
    assert_eq!(fetched_resource.game_score, 10);
  } else {
    println!(&quot;No MyResource present in `World`&quot;);
  }
<span class="boring">}
</span></code></pre>
<p>Other ways of fetching a resource will be covered in the system section of the book.</p>
<h2><a class="header" href="#deleting-a-resource" id="deleting-a-resource">Deleting a resource</a></h2>
<p>There is no method to properly &quot;delete&quot; a resource added to the world.
The usual method to achieve something similar is to add an <code>Option&lt;MyResource&gt;</code> and to set it to <code>None</code> when you want to delete it.</p>
<h2><a class="header" href="#storages-part-2" id="storages-part-2">Storages, part 2</a></h2>
<p>A <code>Component</code>'s <code>Storage</code> is a resource.
The components are &quot;attached&quot; to entities, but as said previously, they are not &quot;owned&quot; by the entities at the implementation level.
By storing them into <code>Storage</code>s and by having <code>Storage</code> be placed inside <code>World</code>,
it allows global access to all of the components at runtime with minimal effort.</p>
<p>Actually accessing the components inside <code>Storage</code>s will be covered in the world and system sections of the book.</p>
<p><strong>WARNING:</strong>
If you try to fetch the component directly, you will not get the storage. You will get a <code>Default::default()</code> instance of that component.
To get the <code>Storage</code> resource that HOLDS all the <code>MyComponent</code> instances, you need to fetch <code>ReadStorage&lt;MyComponent&gt;</code>.</p>
<h1><a class="header" href="#world" id="world">World</a></h1>
<h2><a class="header" href="#what-is-a-world" id="what-is-a-world">What is a <code>World</code>?</a></h2>
<p>A <code>World</code> is a container for resources, with some helper functions that make your life easier.
This chapter will showcase those functions and their usage.</p>
<h2><a class="header" href="#adding-a-resource" id="adding-a-resource">Adding a resource</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::ecs::{World, WorldExt};

// A simple struct with no data.
struct MyResource;

fn main() {
    // We create a new `World` instance.
    let mut world = World::new();
    
    // We create our resource.
    let my = MyResource;
    
    // We add the resource to the world.
    world.insert(my);
}
</code></pre>
<h2><a class="header" href="#fetching-a-resource" id="fetching-a-resource">Fetching a resource</a></h2>
<p>Here's how to fetch a read-only resource. Be aware that this method panics if the resource isn't inserted into <code>Resources</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let my = world.read_resource::&lt;MyResource&gt;();
<span class="boring">}
</span></code></pre>
<p>If you are not sure that the resource will be present, use the methods available on <code>Resources</code>, as shown in the resource chapter.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let my = world.entry::&lt;MyResource&gt;().or_insert_with(|| MyResource);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#modifying-a-resource" id="modifying-a-resource">Modifying a resource</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let mut my = world.write_resource::&lt;MyResource&gt;();
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#creating-entities" id="creating-entities">Creating entities</a></h2>
<p>You first start by creating the entity builder.
Then, you can add components to your entity.
Finally, you call the build() method on the entity builder to get the actual entity.
Please note that <strong>in order to use this syntax, you need to import the <code>amethyst::prelude::Builder</code> trait.</strong></p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    world.register::&lt;MyComponent&gt;();
    use amethyst::prelude::Builder;

    let mut entity_builder = world.create_entity();
    entity_builder = entity_builder.with(MyComponent);
    let my_entity = entity_builder.build();
<span class="boring">}
</span></code></pre>
<p>Shorter version:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    use amethyst::prelude::Builder;

    let my_entity = world
       .create_entity()
       .with(MyComponent)
       .build();
<span class="boring">}
</span></code></pre>
<p>Internally, the <code>World</code> interacts with <code>EntitiesRes</code>, which is a resource holding the entities inside of <code>Resources</code>.</p>
<h2><a class="header" href="#accessing-a-component" id="accessing-a-component">Accessing a <code>Component</code></a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    // Create an `Entity` with `MyComponent`.
    // `World` will implicitly write to the component's storage in `Resources`.
    let my_entity = world.create_entity().with(MyComponent).build();
    
    // Get a ReadStorage&lt;MyComponent&gt;
    let storage = world.read_storage::&lt;MyComponent&gt;();
    
    // Get the actual component from the storage.
    let my = storage.get(my_entity).expect(&quot;Failed to get component for entity&quot;);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#modifying-a-component" id="modifying-a-component">Modifying a <code>Component</code></a></h2>
<p>This is almost the same as accessing a component:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let my_entity = world.create_entity().with(MyComponent).build();
    let mut storage = world.write_storage::&lt;MyComponent&gt;();
    let mut my = storage.get_mut(my_entity).expect(&quot;Failed to get component for entity&quot;);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#getting-all-entities" id="getting-all-entities">Getting all entities</a></h2>
<p>It is pretty rare to use this, but can be useful in some occasions.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    // Returns `EntitiesRes`
    let entities = world.entities();
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#delete-an-entity" id="delete-an-entity">Delete an entity</a></h2>
<p>Single:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span><span class="boring">  let my_entity = world.create_entity().build();
</span>    world.delete_entity(my_entity).expect(&quot;Failed to delete entity. Was it already removed?&quot;);
<span class="boring">}
</span></code></pre>
<p>Multiple:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span><span class="boring">  let entity_vec: Vec&lt;amethyst::ecs::Entity&gt; = vec![world.create_entity().build()];
</span>    world.delete_entities(entity_vec.as_slice()).expect(&quot;Failed to delete entities from specified list.&quot;);
<span class="boring">}
</span></code></pre>
<p>All:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    world.delete_all();
<span class="boring">}
</span></code></pre>
<p><strong>Note: Entities are lazily deleted, which means that deletion only happens at the end of the frame and not immediately when calling the <code>delete</code> method.</strong></p>
<h2><a class="header" href="#check-if-the-entity-was-deleted" id="check-if-the-entity-was-deleted">Check if the entity was deleted</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span><span class="boring">  let my_entity = world.create_entity().build();
</span>    // Returns true if the entity was **not** deleted.
    let is_alive = world.is_alive(my_entity);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#exec" id="exec">Exec</a></h2>
<p><strong>This is just to show that this feature exists. It is normal to not understand what it does until you read the system chapter</strong></p>
<p>Sometimes, you will want to create an entity where you need to fetch resources to create the correct components for it.
There is a function that acts as a shorthand for this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{ReadExpect, World, WorldExt};
</span><span class="boring">struct Dummy;
</span><span class="boring">type SomeSystemData&lt;'a&gt; = ReadExpect&lt;'a, Dummy&gt;;
</span><span class="boring">trait DoSomething {
</span><span class="boring">  fn do_something(&amp;mut self);
</span><span class="boring">}
</span><span class="boring">impl&lt;'a&gt; DoSomething for SomeSystemData&lt;'a&gt; {
</span><span class="boring">  fn do_something(&amp;mut self) { }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    world.exec(|mut data: SomeSystemData| {
        data.do_something();
    });
<span class="boring">}
</span></code></pre>
<p>We will talk about what <code>SystemData</code> is in the system chapter.</p>
<h1><a class="header" href="#system" id="system">System</a></h1>
<h2><a class="header" href="#what-is-a-system" id="what-is-a-system">What is a <code>System</code>?</a></h2>
<p>A system is where the logic of the game is executed. In practice, it consists of a struct implementing a function executed on every iteration of the game loop, and taking as an argument data about the game.</p>
<p>Systems can be seen as a small unit of logic. All systems are run by the engine together (even in parallel when possible), and do a specialized operation on one or a group of entities.</p>
<h2><a class="header" href="#structure" id="structure">Structure</a></h2>
<p>A system struct is a structure implementing the trait <code>amethyst::ecs::System</code>.</p>
<p>Here is a very simple example implementation:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::System;
</span>struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;Hello!&quot;);
    }
}
</code></pre>
<p>This system will, on every iteration of the game loop, print &quot;Hello!&quot; in the console. This is a pretty boring system as it does not interact at all with the game. Let us spice it up a bit.</p>
<h2><a class="header" href="#accessing-the-context-of-the-game" id="accessing-the-context-of-the-game">Accessing the context of the game</a></h2>
<p>In the definition of a system, the trait requires you to define a type <code>SystemData</code>. This type defines what data the system will be provided with on each call of its <code>run</code> method. <code>SystemData</code> is only meant to carry information accessible to multiple systems. Data local to a system is usually stored in the system's struct itself instead.</p>
<p>The Amethyst engine provides useful system data types to use in order to access the context of a game. Here are some of the most important ones:</p>
<ul>
<li><strong>Read&lt;'a, Resource&gt;</strong> (respectively <strong>Write&lt;'a, Resource&gt;</strong>) allows you to obtain an immutable (respectively mutable) reference to a resource of the type you specify. This is guaranteed to not fail as if the resource is not available, it will give you the <code>Default::default()</code> of your resource. </li>
<li><strong>ReadExpect&lt;'a, Resource&gt;</strong> (respectively <strong>WriteExpect&lt;'a, Resource&gt;</strong>) is a failable alternative to the previous system data, so that you can use resources that do not implement the <code>Default</code> trait.</li>
<li><strong>ReadStorage&lt;'a, Component&gt;</strong> (respectively <strong>WriteStorage&lt;'a, Component&gt;</strong>) allows you to obtain an immutable (respectively mutable) reference to the entire storage of a certain <code>Component</code> type.</li>
<li><strong>Entities&lt;'a&gt;</strong> allows you to create or destroy entities in the context of a system.</li>
</ul>
<p>You can then use one, or multiple of them via a tuple.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Read};
</span><span class="boring">use amethyst::core::timing::Time;
</span>struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = Read&lt;'a, Time&gt;;

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;{}&quot;, data.delta_seconds());
    }
}
</code></pre>
<p>Here, we get the <code>amethyst::core::timing::Time</code> resource to print in the console the time elapsed between two frames. Nice! But that's still a bit boring.</p>
<h2><a class="header" href="#manipulating-storages" id="manipulating-storages">Manipulating storages</a></h2>
<p>Once you have access to a storage, you can use them in different ways.</p>
<h3><a class="header" href="#getting-a-component-of-a-specific-entity" id="getting-a-component-of-a-specific-entity">Getting a component of a specific entity</a></h3>
<p>Sometimes, it can be useful to get a component in the storage for a specific entity. This can easily be done using the <code>get</code> or, for mutable storages, <code>get_mut</code> methods.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Entity, System, WriteStorage};
</span><span class="boring">use amethyst::core::Transform;
</span>struct WalkPlayerUp {
    player: Entity,
}

impl&lt;'a&gt; System&lt;'a&gt; for WalkPlayerUp {
    type SystemData = WriteStorage&lt;'a, Transform&gt;;

    fn run(&amp;mut self, mut transforms: Self::SystemData) {
        transforms.get_mut(self.player).unwrap().prepend_translation_y(0.1);
    }
}
</code></pre>
<p>This system makes the player go up by 0.1 unit every iteration of the game loop! To identify what entity the player is, we stored it beforehand in the system's struct. Then, we get its <code>Transform</code> from the transform storage, and move it along the Y axis by 0.1.</p>
<blockquote>
<p>A transform is a very common structure in game development. It represents the position, rotation and scale of an object in the game world. You will use them a lot, as they are what you need to change when you want to move something around in your game.</p>
</blockquote>
<p>However, this approach is pretty rare because most of the time you don't know what entity you want to manipulate, and in fact you may want to apply your changes to multiple entities.</p>
<h3><a class="header" href="#getting-all-entities-with-specific-components" id="getting-all-entities-with-specific-components">Getting all entities with specific components</a></h3>
<p>Most of the time, you will want to perform logic on all entities with a specific component, or even all entities with a selection of components.</p>
<p>This is possible using the <code>join</code> method. You may be familiar with joining operations if you have ever worked with databases. The <code>join</code> method takes multiple storages, and iterates over all entities that have a component in each of those storages.
It works like an &quot;AND&quot; gate. It will return an iterator containing a tuple of all the requested components if they are <strong>ALL</strong> on the same entity.</p>
<p>If you join with components A, B and C, only the entities that have <strong>ALL</strong> those components will be considered.</p>
<p>Needless to say that you can use it with only one storage to iterate over all entities with a specific component.</p>
<p>Keep in mind that <strong>the <code>join</code> method is only available by importing <code>amethyst::ecs::Join</code></strong>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, ReadStorage, WriteStorage};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct FallingObject;
</span><span class="boring">impl amethyst::ecs::Component for FallingObject {
</span><span class="boring">  type Storage = amethyst::ecs::DenseVecStorage&lt;FallingObject&gt;;
</span><span class="boring">}
</span>use amethyst::ecs::Join;

struct MakeObjectsFall;

impl&lt;'a&gt; System&lt;'a&gt; for MakeObjectsFall {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (mut transforms, falling): Self::SystemData) {
        for (transform, _) in (&amp;mut transforms, &amp;falling).join() {
            if transform.translation().y &gt; 0.0 {
                transform.prepend_translation_y(-0.1);
            }
        }
    }
}
</code></pre>
<p>This system will make all entities with both a <code>Transform</code> with a positive y coordinate and a <code>FallingObject</code> tag component fall by 0.1 unit per game loop iteration. Note that as the <code>FallingObject</code> is only here as a tag to restrict the joining operation, we immediately discard it using the <code>_</code> syntax.</p>
<p>Cool! Now that looks like something we'll actually do in our games!</p>
<h3><a class="header" href="#getting-entities-that-have-some-components-but-not-others" id="getting-entities-that-have-some-components-but-not-others">Getting entities that have some components, but not others</a></h3>
<p>There is a special type of <code>Storage</code> in specs called <code>AntiStorage</code>.
The not operator (!) turns a Storage into its AntiStorage counterpart, allowing you to iterate over entities that do NOT have this <code>Component</code>.
It is used like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, ReadStorage, WriteStorage};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct FallingObject;
</span><span class="boring">impl amethyst::ecs::Component for FallingObject {
</span><span class="boring">  type Storage = amethyst::ecs::DenseVecStorage&lt;FallingObject&gt;;
</span><span class="boring">}
</span>use amethyst::ecs::Join;

struct NotFallingObjects;

impl&lt;'a&gt; System&lt;'a&gt; for NotFallingObjects {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (mut transforms, falling): Self::SystemData) {
        for (mut transform, _) in (&amp;mut transforms, !&amp;falling).join() {
            // If they don't fall, why not make them go up!
            transform.prepend_translation_y(0.1);
        }
    }
}
</code></pre>
<h2><a class="header" href="#manipulating-the-structure-of-entities" id="manipulating-the-structure-of-entities">Manipulating the structure of entities</a></h2>
<p>It may sometimes be interesting to manipulate the structure of entities in a system, such as creating new ones or modifying the component layout of existing ones. This kind of process is done using the <code>Entities&lt;'a&gt;</code> system data.</p>
<blockquote>
<p>Requesting <code>Entities&lt;'a&gt;</code> does not impact performance, as it contains only immutable resources and therefore <a href="concepts/./dispatcher.html">does not block the dispatching</a>.</p>
</blockquote>
<h3><a class="header" href="#creating-new-entities-in-a-system" id="creating-new-entities-in-a-system">Creating new entities in a system</a></h3>
<p>Creating an entity while in the context of a system is very similar to the way one would create an entity using the <code>World</code> struct. The only difference is that one needs to provide mutable storages of all the components they plan to add to the entity.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, WriteStorage, Entities};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct Enemy;
</span><span class="boring">impl amethyst::ecs::Component for Enemy {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Enemy&gt;;
</span><span class="boring">}
</span>struct SpawnEnemies {
    counter: u32,
}

impl&lt;'a&gt; System&lt;'a&gt; for SpawnEnemies {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        WriteStorage&lt;'a, Enemy&gt;,
        Entities&lt;'a&gt;,
    );

    fn run(&amp;mut self, (mut transforms, mut enemies, entities): Self::SystemData) {
        self.counter += 1;
        if self.counter &gt; 200 {
            entities.build_entity()
                .with(Transform::default(), &amp;mut transforms)
                .with(Enemy, &amp;mut enemies)
                .build();
            self.counter = 0;
        }
    }
}
</code></pre>
<p>This system will spawn a new enemy every 200 game loop iterations.</p>
<h3><a class="header" href="#removing-an-entity" id="removing-an-entity">Removing an entity</a></h3>
<p>Deleting an entity is very easy using <code>Entities&lt;'a&gt;</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Entities, Entity};
</span><span class="boring">struct MySystem { entity: Entity }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
</span><span class="boring">  type SystemData = Entities&lt;'a&gt;;
</span><span class="boring">  fn run(&amp;mut self, entities: Self::SystemData) {
</span><span class="boring">      let entity = self.entity;
</span>entities.delete(entity);
<span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<h3><a class="header" href="#iterating-over-components-with-associated-entity" id="iterating-over-components-with-associated-entity">Iterating over components with associated entity</a></h3>
<p>Sometimes, when you iterate over components, you may want to also know what entity you are working with. To do that, you can use the joining operation with <code>Entities&lt;'a&gt;</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Join, System, Entities, WriteStorage, ReadStorage};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct FallingObject;
</span><span class="boring">impl amethyst::ecs::Component for FallingObject {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;FallingObject&gt;;
</span><span class="boring">}
</span>struct MakeObjectsFall;

impl&lt;'a&gt; System&lt;'a&gt; for MakeObjectsFall {
    type SystemData = (
        Entities&lt;'a&gt;,
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (entities, mut transforms, falling): Self::SystemData) {
        for (e, mut transform, _) in (&amp;*entities, &amp;mut transforms, &amp;falling).join() {
            if transform.translation().y &gt; 0.0 {
                transform.prepend_translation_y(-0.1);
            } else {
                entities.delete(e);
            }
        }
    }
}
</code></pre>
<p>This system does the same thing as the previous <code>MakeObjectsFall</code>, but also cleans up falling objects that reached the ground.</p>
<h3><a class="header" href="#adding-or-removing-components" id="adding-or-removing-components">Adding or removing components</a></h3>
<p>You can also insert or remove components from a specific entity.
To do that, you need to get a mutable storage of the component you want to modify, and simply do:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Entities, Entity, WriteStorage};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">struct MySystem { entity: Entity }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
</span><span class="boring">  type SystemData = WriteStorage&lt;'a, MyComponent&gt;;
</span><span class="boring">  fn run(&amp;mut self, mut write_storage: Self::SystemData) {
</span><span class="boring">      let entity = self.entity;
</span>// Add the component
write_storage.insert(entity, MyComponent);

// Remove the component
write_storage.remove(entity);
<span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<p>Keep in mind that inserting a component on an entity that already has a component of the same type <strong>will overwrite the previous one</strong>.</p>
<h2><a class="header" href="#changing-states-through-resources" id="changing-states-through-resources">Changing states through resources</a></h2>
<p>In a previous section we talked about <a href="concepts/./state.html"><code>States</code></a>, and how they are used to organize your game
into different logical sections.
Sometimes we want to trigger a state transition from a system.
For example, if a player dies we might want to remove their entity and signal to the state machine
to push a state that shows a &quot;You Died&quot; screen.</p>
<p>So how can we affect states from systems?
There are a couple of ways, but this section will detail the easiest one: using a <a href="concepts/./resource.html"><code>Resource</code></a>.</p>
<p>Before that, let's just quickly remind ourselves what a resource is:</p>
<blockquote>
<p>A <a href="concepts/./resource.html"><code>Resource</code></a> is any type that stores data that you might need for your game AND that is not
specific to an entity.</p>
</blockquote>
<p>The data in a resource is available both to systems and states.
We can use this to our advantage!</p>
<p>Let's say you have the following two states:</p>
<ul>
<li><code>GameplayState</code>: State in which the game is running.</li>
<li><code>GameMenuState</code>: State where the game is paused and we interact with a game menu.</li>
</ul>
<p>The following example shows how to keep track of which state we are currently in.
This allows us to do a bit of conditional logic in our systems to determine what to do depending on
which state is currently active, and manipulating the states by tracking user actions:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::prelude::*;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum CurrentState {
    MainMenu,
    Gameplay,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum UserAction {
    OpenMenu,
    ResumeGame,
    Quit,
}

impl Default for CurrentState {
    fn default() -&gt; Self {
        CurrentState::Gameplay
    }
}

struct Game {
    user_action: Option&lt;UserAction&gt;,
    current_state: CurrentState,
}

impl Default for Game {
    fn default() -&gt; Self {
        Game {
            user_action: None,
            current_state: CurrentState::default(),
        }
    }
}

struct GameplayState;

impl SimpleState for GameplayState {
    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        // If the `Game` resource has been set up to go back to the menu, push
        // the menu state so that we go back.

        let mut game = data.world.write_resource::&lt;Game&gt;();

        if let Some(UserAction::OpenMenu) = game.user_action.take() {
            return Trans::Push(Box::new(GameMenuState));
        }

        Trans::None
    }

    fn on_resume(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // mark that the current state is a gameplay state.
        data.world.write_resource::&lt;Game&gt;().current_state = CurrentState::Gameplay;
    }
}

struct GameMenuState;

impl SimpleState for GameMenuState {
    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        let mut game = data.world.write_resource::&lt;Game&gt;();

        match game.user_action.take() {
            Some(UserAction::ResumeGame) =&gt; Trans::Pop,
            Some(UserAction::Quit) =&gt; {
                // Note: no need to clean up :)
                Trans::Quit
            },
            _ =&gt; Trans::None,
        }
    }

    fn on_resume(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // mark that the current state is a main menu state.
        data.world.write_resource::&lt;Game&gt;().current_state = CurrentState::MainMenu;
    }
}
</code></pre>
<p>Let's say we want the player to be able to press escape to enter the menu.
We modify our input handler to map the <code>open_menu</code> action to <code>Esc</code>, and we write the following
system:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">enum CurrentState {
</span><span class="boring">    MainMenu,
</span><span class="boring">    Gameplay,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for CurrentState { fn default() -&gt; Self { CurrentState::Gameplay } }
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">enum UserAction {
</span><span class="boring">    OpenMenu,
</span><span class="boring">    ResumeGame,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Game {
</span><span class="boring">    user_action: Option&lt;UserAction&gt;,
</span><span class="boring">    current_state: CurrentState,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Game {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Game {
</span><span class="boring">            user_action: None,
</span><span class="boring">            current_state: CurrentState::default(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    prelude::*,
    ecs::{System, prelude::*},
    input::{InputHandler, StringBindings},
};

struct MyGameplaySystem;

impl&lt;'s&gt; System&lt;'s&gt; for MyGameplaySystem {
    type SystemData = (
        Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;,
        Write&lt;'s, Game&gt;,
    );

    fn run(&amp;mut self, (input, mut game): Self::SystemData) {
        match game.current_state {
            CurrentState::Gameplay =&gt; {
                let open_menu = input
                    .action_is_down(&quot;open_menu&quot;)
                    .unwrap_or(false);

                // Toggle the `open_menu` variable to signal the state to
                // transition.
                if open_menu {
                    game.user_action = Some(UserAction::OpenMenu);
                }
            }
            // do nothing for other states.
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>Now whenever you are playing the game and you press the button associated with the <code>open_menu</code>
action, the <code>GameMenuState</code> will resume and the <code>GameplayState</code> will pause.</p>
<h2><a class="header" href="#the-systemdata-trait" id="the-systemdata-trait">The SystemData trait</a></h2>
<p>While this is rarely useful, it is possible to create custom <code>SystemData</code> types.</p>
<p>The <code>Dispatcher</code> populates the <code>SystemData</code> on every call of the <code>run</code> method. To do that, your <code>SystemData</code> type must implement the trait <code>amethyst::ecs::SystemData</code> in order to have it be valid.</p>
<p>This is rather complicated trait to implement, fortunately Amethyst provides a derive macro for it, that can implement the trait to any struct as long as all its fields are <code>SystemData</code>. Most of the time however, you will not even need to implement it at all as you will be using <code>SystemData</code> structs provided by the engine.</p>
<p>Please note that tuples of structs implementing <code>SystemData</code> are themselves <code>SystemData</code>. This is very useful when you need to request multiple <code>SystemData</code> at once quickly.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate shred;
</span><span class="boring">#[macro_use] extern crate shred_derive;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{Component, Join, ReadStorage, System, SystemData, VecStorage, World, WriteStorage},
</span><span class="boring">    shred::ResourceId,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct FooComponent {
</span><span class="boring">  stuff: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for FooComponent {
</span><span class="boring">  type Storage = VecStorage&lt;FooComponent&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct BarComponent {
</span><span class="boring">  stuff: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for BarComponent {
</span><span class="boring">  type Storage = VecStorage&lt;BarComponent&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(SystemData)]
</span><span class="boring">struct BazSystemData&lt;'a&gt; {
</span><span class="boring"> field: ReadStorage&lt;'a, FooComponent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; BazSystemData&lt;'a&gt; {
</span><span class="boring">  fn should_process(&amp;self) -&gt; bool {
</span><span class="boring">      true
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(SystemData)]
struct MySystemData&lt;'a&gt; {
    foo: ReadStorage&lt;'a, FooComponent&gt;,
    bar: WriteStorage&lt;'a, BarComponent&gt;,
    baz: BazSystemData&lt;'a&gt;,
}

struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = MySystemData&lt;'a&gt;;

    fn run(&amp;mut self, mut data: Self::SystemData) {
        if data.baz.should_process() {
            for (foo, mut bar) in (&amp;data.foo, &amp;mut data.bar).join() {
                bar.stuff += foo.stuff;
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#system-initialization" id="system-initialization">System Initialization</a></h1>
<p>Systems may need to access resources from the <code>World</code> in order to be
instantiated. For example, obtaining a <code>ReaderId</code> to an <code>EventChannel</code> that
exists in the <code>World</code>. When there is an existing event channel in the <code>World</code>, a
<code>System</code> should register itself as a reader of that channel instead of replacing
it, as that invalidates all other readers.</p>
<p>In Amethyst, the <code>World</code> that the application begins with is populated with a
number of default resources -- event channels, a thread pool, a frame limiter,
and so on.</p>
<p>Given the default resources begin with special limits, we need a way to pass the
<code>System</code> initialization logic through to the application, including parameters to
the <code>System</code>'s constructor. This is information the <code>SystemDesc</code> trait captures.</p>
<p>For each <code>System</code>, an implementation of the <code>SystemDesc</code> trait specifies the
logic to instantiate the <code>System</code>. For <code>System</code>s that do not require special
initialization logic, the <code>SystemDesc</code> derive automatically implements the
<code>SystemDesc</code> trait on the system type itself:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{System, SystemData, World},
};

#[derive(SystemDesc)]
struct SystemName;

impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;Hello!&quot;);
    }
}
</code></pre>
<p>The <a href="concepts/system/./system_desc_derive.html"><code>SystemDesc</code> derive</a> page demonstrates the use cases supported by the
<code>SystemDesc</code> derive. For more complex cases, the
<a href="concepts/system/./implementing_the_system_desc_trait.html">Implementing the <code>SystemDesc</code> Trait</a> page explains how to implement the
<code>SystemDesc</code> trait.</p>
<h1><a class="header" href="#systemdesc-derive" id="systemdesc-derive"><code>SystemDesc</code> Derive</a></h1>
<p>The <code>SystemDesc</code> derive supports the following cases when generating a <code>SystemDesc</code> trait implementation:</p>
<ul>
<li>Parameters to pass to the system constructor.</li>
<li>Fields to skip -- defaulted by the system constructor.</li>
<li>Registering a <code>ReaderId</code> for an <code>EventChannel&lt;_&gt;</code> in the <code>World</code>.</li>
<li>Registering a <code>ReaderId</code> to a component's <code>FlaggedStorage</code>.</li>
<li>Inserting a resource into the <code>World</code>.</li>
</ul>
<p>If your system initialization use case is not covered, please see the
<a href="concepts/system/./implementing_the_system_desc_trait.html">Implementing the <code>SystemDesc</code> Trait</a> page.</p>
<h2><a class="header" href="#passing-parameters-to-system-constructor" id="passing-parameters-to-system-constructor">Passing parameters to system constructor</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    field_0: u32,
    field_1: String,
}

impl SystemName {
    fn new(field_0: u32, field_1: String) -&gt; Self {
        SystemName { field_0, field_1 }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    field_0: u32,
</span><span class="boring">    field_1: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(field_0: u32, field_1: String) -&gt; Self {
</span><span class="boring">        SystemName { field_0, field_1 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds a `SystemName`.
#[derive(Default, Debug)]
pub struct SystemNameDesc {
    field_0: u32,
    field_1: String,
}

impl SystemNameDesc {
    fn new(field_0: u32, field_1: String) -&gt; Self {
        SystemNameDesc { field_0, field_1 }
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        SystemName::new(self.field_0, self.field_1)
    }
}
</code></pre>
</details>
<h2><a class="header" href="#fields-to-skip----defaulted-by-the-system-constructor" id="fields-to-skip----defaulted-by-the-system-constructor">Fields to skip -- defaulted by the system constructor</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(skip)]
    field_0: u32,
    field_1: String,
}

impl SystemName {
    fn new(field_1: String) -&gt; Self {
        SystemName { field_0: 123, field_1 }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    field_0: u32,
</span><span class="boring">    field_1: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(field_1: String) -&gt; Self {
</span><span class="boring">        SystemName { field_0: 123, field_1 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds a `SystemName`.
#[derive(Default, Debug)]
pub struct SystemNameDesc {
    field_1: String,
}

impl SystemNameDesc {
    fn new(field_1: String) -&gt; Self {
        SystemNameDesc { field_1 }
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        SystemName::new(self.field_1)
    }
}
</code></pre>
</details>
<p><strong>Note:</strong> If there are no field parameters, the <code>SystemDesc</code> implementation
will call  <code>SystemName::default()</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(Default, SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(skip)]
    field_0: u32,
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    field_0: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds a `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc {}

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        SystemName::default()
    }
}
</code></pre>
</details>
<h2><a class="header" href="#registering-a-readerid-for-an-eventchannel_-in-the-world" id="registering-a-readerid-for-an-eventchannel_-in-the-world">Registering a <code>ReaderId</code> for an <code>EventChannel&lt;_&gt;</code> in the <code>World</code></a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiEvent,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(event_channel_reader)]
    reader_id: ReaderId&lt;UiEvent&gt;,
}

impl SystemName {
    fn new(reader_id: ReaderId&lt;UiEvent&gt;) -&gt; Self {
        SystemName { reader_id }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiEvent,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(reader_id: ReaderId&lt;UiEvent&gt;) -&gt; Self {
</span><span class="boring">        SystemName { reader_id }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds a `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc;

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        let reader_id = world
            .fetch_mut::&lt;EventChannel&lt;UiEvent&gt;&gt;()
            .register_reader();

        SystemName::new(reader_id)
    }
}
</code></pre>
</details>
<h2><a class="header" href="#registering-a-readerid-to-a-components-flaggedstorage" id="registering-a-readerid-to-a-components-flaggedstorage">Registering a <code>ReaderId</code> to a component's <code>FlaggedStorage</code></a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{storage::ComponentEvent, System, SystemData, WriteStorage},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiResize,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(flagged_storage_reader(UiResize))]
    resize_events_id: ReaderId&lt;ComponentEvent&gt;,
}

impl SystemName {
    fn new(resize_events_id: ReaderId&lt;ComponentEvent&gt;) -&gt; Self {
        SystemName { resize_events_id }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{storage::ComponentEvent, System, SystemData, WriteStorage},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiResize,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    resize_events_id: ReaderId&lt;ComponentEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(resize_events_id: ReaderId&lt;ComponentEvent&gt;) -&gt; Self {
</span><span class="boring">        SystemName { resize_events_id }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds a `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc;

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        let resize_events_id = WriteStorage::&lt;UiResize&gt;::fetch(&amp;world)
                            .register_reader();

        SystemName::new(resize_events_id)
    }
}
</code></pre>
</details>
<h2><a class="header" href="#inserting-a-resource-into-the-world" id="inserting-a-resource-into-the-world">Inserting a resource into the <code>World</code></a></h2>
<p><strong>Note:</strong> If the resource you wish to insert is the result of an expression,
such as a function call, you must surround that expression in quotes, e.g.
<code>#[system_desc(insert(&quot;MyResource::default()&quot;))]</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{ReadExpect, System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>pub struct NonDefault;

#[derive(Default, SystemDesc)]
#[system_desc(insert(NonDefault))]
pub struct SystemName;

impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
    type SystemData = ReadExpect&lt;'a, NonDefault&gt;;
    fn run(&amp;mut self, data: Self::SystemData) {}
}
</code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{ReadExpect, System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct NonDefault;
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct SystemName;
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ReadExpect&lt;'a, NonDefault&gt;;
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds a `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc;

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        world.insert(NonDefault);

        SystemName::default()
    }
}
</code></pre>
<h1><a class="header" href="#implementing-the-systemdesc-trait" id="implementing-the-systemdesc-trait">Implementing the <code>SystemDesc</code> Trait</a></h1>
<p>If the <code>SystemDesc</code> derive is unable to generate a <code>SystemDesc</code> trait
implementation for system initialization, the <code>SystemDesc</code> trait can be
implemented manually:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    audio::output::Output,
    core::SystemDesc,
    ecs::{System, SystemData, World},
};

<span class="boring">/// Syncs 3D transform data with the audio engine to provide 3D audio.
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">pub struct AudioSystem(Output);
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for AudioSystem {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, _: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Builds an `AudioSystem`.
#[derive(Default, Debug)]
pub struct AudioSystemDesc {
    /// Audio `Output`.
    pub output: Output,
}

impl&lt;'a, 'b&gt; SystemDesc&lt;'a, 'b, AudioSystem&gt; for AudioSystemDesc {
    fn build(self, world: &amp;mut World) -&gt; AudioSystem {
        &lt;AudioSystem as System&lt;'_&gt;&gt;::SystemData::setup(world);

        world.insert(self.output.clone());

        AudioSystem(self.output)
    }
}

// in `main.rs`:
// let game_data = GameDataBuilder::default()
//     .with_system_desc(AudioSystemDesc::default(), &quot;&quot;, &amp;[]);
</code></pre>
</details>
<h2><a class="header" href="#templates" id="templates">Templates</a></h2>
<pre><code class="language-rust ignore">use amethyst_core::SystemDesc;

/// Builds a `SystemName`.
#[derive(Default, Debug)]
pub struct SystemNameDesc;

impl&lt;'a, 'b&gt; SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut World) -&gt; SystemName {
        &lt;SystemName as System&lt;'_&gt;&gt;::SystemData::setup(world);

        let arg = unimplemented!(&quot;Replace code here&quot;);

        SystemName::new(arg)
    }
}
</code></pre>
<p>With type parameters:</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

use derivative::Derivative;

use amethyst_core::ecs::SystemData;
use amethyst_core::SystemDesc;

/// Builds a `SystemName`.
#[derive(Derivative, Debug)]
#[derivative(Default(bound = &quot;&quot;))]
pub struct SystemNameDesc&lt;T&gt; {
    marker: PhantomData&lt;T&gt;,
}

impl&lt;'a, 'b, T&gt; SystemDesc&lt;'a, 'b, SystemName&lt;T&gt;&gt;
    for SystemNameDesc&lt;T&gt;
where
    T: unimplemented!(&quot;Replace me.&quot;),
{
    fn build(self, world: &amp;mut World) -&gt; SystemName&lt;T&gt; {
        &lt;SystemName&lt;T&gt; as System&lt;'_&gt;&gt;::SystemData::setup(world);

        let arg = unimplemented!(&quot;Replace code here&quot;);

        SystemName::new(arg)
    }
}
</code></pre>
<h1><a class="header" href="#dispatcher" id="dispatcher">Dispatcher</a></h1>
<h2><a class="header" href="#what-is-a-dispatcher" id="what-is-a-dispatcher">What is a <code>Dispatcher</code>?</a></h2>
<p>Dispatchers are the heart of the ECS infrastructure. They are the executors that decide when the <code>System</code>s will be executed so that they don't walk over each other.</p>
<p>When a dispatcher is created, it is associated with the systems that it will execute. It then generates an execution plan that respects mutability rules while maximizing parallelism.</p>
<h2><a class="header" href="#respecting-mutability-rules" id="respecting-mutability-rules">Respecting mutability rules</a></h2>
<p>When a system wants to access a <code>Storage</code> or a resource, they can do so either mutably or immutably. This works just like in Rust: either only one system can request something mutably and no other system can access it, or multiple systems can request something but only immutably.</p>
<p>The dispatcher looks at all the <code>SystemData</code> in the systems and builds execution stages.</p>
<p>If you want to have the best performance possible, you should prefer immutable over mutable whenever it is possible. (<code>Read</code> instead of <code>Write</code>, <code>ReadStorage</code> instead of <code>WriteStorage</code>).</p>
<p><strong>Note: Please however keep in mind that <code>Write</code> is still preferable to locks in most cases, such as <code>Mutex</code> or <code>RwLock</code> for example.</strong></p>
<h1><a class="header" href="#event-channel" id="event-channel">Event Channel</a></h1>
<h2><a class="header" href="#what-is-an-event-channel" id="what-is-an-event-channel">What is an event channel?</a></h2>
<p>An <code>EventChannel</code> is a broadcast queue of events. Events may be any type that implements <code>Send + Sync + 'static</code>.</p>
<p>Typically, <code>EventChannel</code>s are inserted as resources in the <code>World</code>.</p>
<h2><a class="header" href="#examples" id="examples">Examples</a></h2>
<h3><a class="header" href="#creating-an-event-channel" id="creating-an-event-channel">Creating an event channel</a></h3>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::shrev::EventChannel;
</span>// In the following examples, `MyEvent` is the event type of the channel.
#[derive(Debug)]
pub enum MyEvent {
    A,
    B,
}

let mut channel = EventChannel::&lt;MyEvent&gt;::new();
</code></pre>
<h3><a class="header" href="#writing-events-to-the-event-channel" id="writing-events-to-the-event-channel">Writing events to the event channel</a></h3>
<p>Single:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
</span>    channel.single_write(MyEvent::A);
<span class="boring">}
</span></code></pre>
<p>Multiple:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
</span>    channel.iter_write(vec![MyEvent::A, MyEvent::A, MyEvent::B].into_iter());
<span class="boring">}
</span></code></pre>
<h3><a class="header" href="#reading-events" id="reading-events">Reading events</a></h3>
<p><code>EventChannel</code>s guarantee sending events in order to each reader.</p>
<p>To subscribe to events, register a reader against the <code>EventChannel</code> to receive a <code>ReaderId</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
</span>let mut reader_id = channel.register_reader();
<span class="boring">}
</span></code></pre>
<p>When reading events, pass the <code>ReaderId</code> in:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut channel = amethyst::shrev::EventChannel::&lt;MyEvent&gt;::new();
</span><span class="boring">  let mut reader_id = channel.register_reader();
</span>for event in channel.read(&amp;mut reader_id) {
    // The type of the event is inferred from the generic type
    // we assigned to the `EventChannel&lt;MyEvent&gt;` earlier when creating it.
    println!(&quot;Received event value of: {:?}&quot;, event);
}
<span class="boring">}
</span></code></pre>
<p>Note that you only need to have a read access to the channel when reading events.
It is the <code>ReaderId</code> that needs to be mutable to keep track of where your last read was.</p>
<blockquote>
<p><strong>IMPORTANT:</strong> The event channel automatically grows as events are added to it and only decreases in size once all readers have read through the older events.</p>
<p>This mean that if you create a <code>ReaderId</code> but don't read from it on each frame, the event channel will start to consume more and more memory.</p>
</blockquote>
<h2><a class="header" href="#patterns" id="patterns">Patterns</a></h2>
<p>When using the event channel, we usually re-use the same pattern over and over again to maximize parallelism.
It goes as follow:</p>
<p>In the <strong>producer</strong> <code>System</code>, get a mutable reference to your resource:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::Write;
</span><span class="boring">use amethyst::shrev::EventChannel;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">struct MySystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
</span>type SystemData = Write&lt;'a, EventChannel&lt;MyEvent&gt;&gt;;
<span class="boring">  fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span></code></pre>
<p>In the <strong>receiver</strong> <code>System</code>s, you need to store the <code>ReaderId</code> somewhere.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::shrev::ReaderId;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span>struct ReceiverSystem {
    // The type inside of ReaderId should be the type of the event you are using.
    reader: Option&lt;ReaderId&lt;MyEvent&gt;&gt;,
}
</code></pre>
<p>and you also need to get read access:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::Read;
</span><span class="boring">use amethyst::shrev::EventChannel;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">struct MySystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
</span>    type SystemData = Read&lt;'a, EventChannel&lt;MyEvent&gt;&gt;;
<span class="boring">  fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span></code></pre>
<p>Then, in the <code>System</code>'s <code>new</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ecs::{System, SystemData, World};
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">struct MySystem { reader_id: ReaderId&lt;MyEvent&gt;, }
</span><span class="boring">
</span>impl MySystem {
    pub fn new(world: &amp;mut World) -&gt; Self {
        &lt;Self as System&lt;'_&gt;&gt;::SystemData::setup(world);
        let reader_id = world.fetch_mut::&lt;EventChannel&lt;MyEvent&gt;&gt;().register_reader();
        Self { reader_id }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
</span><span class="boring">  type SystemData = ();
</span><span class="boring">  fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span></code></pre>
<p>Finally, you can read events from your <code>System</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::Read;
</span><span class="boring">use amethyst::shrev::EventChannel;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">pub enum MyEvent {
</span><span class="boring">  A,
</span><span class="boring">  B,
</span><span class="boring">}
</span><span class="boring">struct MySystem {
</span><span class="boring">  reader_id: amethyst::shrev::ReaderId&lt;MyEvent&gt;,
</span><span class="boring">}
</span>impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MySystem {
    type SystemData = Read&lt;'a, EventChannel&lt;MyEvent&gt;&gt;;
    fn run(&amp;mut self, my_event_channel: Self::SystemData) {
        for event in my_event_channel.read(&amp;mut self.reader_id) {
            println!(&quot;Received an event: {:?}&quot;, event);
        }
    }
}
</code></pre>
<h1><a class="header" href="#pong-tutorial" id="pong-tutorial">Pong Tutorial</a></h1>
<p>To get a better feeling for how Amethyst works, we're going to implement a
Pong clone. You can find a <a href="https://github.com/amethyst/amethyst/tree/master/examples/pong_tutorial_06">full Pong example</a> (our end goal) in
Amethyst's <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> folder. This tutorial breaks that project up into discrete
steps so it's easier to understand what everything is doing.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Make sure to follow the <a href="./getting-started.html">Getting started chapter</a> before
starting with the tutorial / running the examples.</p>
<h2><a class="header" href="#running-the-code-after-a-chapter" id="running-the-code-after-a-chapter">Running the code after a chapter</a></h2>
<p>If you've cloned the Amethyst repo, you can run any of the examples like so:</p>
<pre><code class="language-norun">cargo run --example pong_tutorial_01 --features &quot;vulkan&quot;
</code></pre>
<p>The example named <code>pong_tutorial_xy</code> contains the code which you should have
after following all tutorials from 1 to xy.</p>
<blockquote>
<p><strong>Note:</strong> On macOS, you might want to use <code>&quot;metal&quot;</code> instead of <code>&quot;vulkan&quot;</code>.</p>
</blockquote>
<p>The main difference between real game code and the example code is where the 
<code>config</code> and <code>assets</code> folders are located.</p>
<p>For instance, in the pong_tutorial_01 example we have:</p>
<pre><code class="language-rust ignore">let display_config_path =
    app_root.join(&quot;examples/pong_tutorial_01/config/display.ron&quot;);

let assets_dir = app_root.join(&quot;examples/assets/&quot;);
</code></pre>
<p>But for your own project you'll probably want something like this:</p>
<pre><code class="language-rust ignore">let display_config_path = app_root.join(&quot;config/display.ron&quot;);

let assets_dir = app_root.join(&quot;assets/&quot;);
</code></pre>
<h1><a class="header" href="#setting-up-the-project" id="setting-up-the-project">Setting up the project</a></h1>
<p>In this chapter, we will go through the basics of setting up the amethyst project,
starting the logger, opening a window and preparing a simple rendering setup.</p>
<h2><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h2>
<p>Let's start a new project:</p>
<p><code>cargo new pong</code></p>
<p>Update the dependencies in the project's <code>Cargo.toml</code> so that it contains:</p>
<pre><code class="language-toml">[package]
name = &quot;pong&quot;
version = &quot;0.1.0&quot;
authors = []
edition = &quot;2018&quot;

[dependencies.amethyst]
version = &quot;0.15&quot;
features = [&quot;vulkan&quot;]
</code></pre>
<p>Alternatively, if you are developing on macOS, you might want to use the <code>metal</code> rendering backend instead of <code>vulkan</code>. In this case, you should change the <code>features</code> entry in the <code>amethyst</code> dependency table.</p>
<pre><code class="language-toml">[dependencies.amethyst]
version = &quot;0.15&quot;
features = [&quot;metal&quot;]
</code></pre>
<p>We can start with editing the <code>main.rs</code> file inside <code>src</code> directory.
You can delete everything in that file, then add these imports:</p>
<pre><code class="language-rust ignore">//! Pong Tutorial 1

use amethyst::{
    prelude::*,
    renderer::{
        plugins::{RenderFlat2D, RenderToWindow},
        types::DefaultBackend,
        RenderingBundle,
    },
    utils::application_root_dir,
};
</code></pre>
<p>We'll be learning more about these as we go through this tutorial. The prelude
includes the basic (and most important) types like <code>Application</code>, <code>World</code>, and
<code>State</code>. We also import all the necessary types to define a basic rendering pipeline.</p>
<p>Now we have all the dependencies installed and imports prepared, we are ready to start
working on defining our game code.</p>
<h2><a class="header" href="#creating-the-game-state" id="creating-the-game-state">Creating the game state</a></h2>
<p>Now we create our core game struct:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub struct Pong;
</code></pre>
<p>We'll be implementing the <a href="https://docs.amethyst.rs/stable/amethyst/prelude/trait.SimpleState.html"><code>SimpleState</code></a> trait on this struct, which is
used by Amethyst's state machine to start, stop, and update the game.</p>
<pre><code class="language-rust ignore">impl SimpleState for Pong {}
</code></pre>
<p>Implementing the <code>SimpleState</code> teaches our application what to do when a close signal
is received from your operating system. This happens when you press the close
button in your graphical environment. This allows the application to quit as needed.</p>
<p>Now that our <code>Pong</code> is already a game state, let's add some code to actually get things
started! We'll start with our <code>main()</code> function, and we'll have it return a
<code>Result</code> so that we can use <code>?</code>. This will allow us to automatically exit
if any errors occur during setup.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span>fn main() -&gt; amethyst::Result&lt;()&gt; {

    // We'll put the rest of the code here.

    Ok(())
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> The <a href="https://docs.amethyst.rs/stable/amethyst/prelude/trait.SimpleState.html">SimpleState</a> is just a simplified version of <a href="https://docs.amethyst.rs/stable/amethyst/prelude/trait.State.html">State</a> trait.
It already implements a bunch of stuff for us, like the <code>State</code>'s <code>update</code>
and <code>handle_event</code> methods that you would have to implement yourself were you
using just a regular <code>State</code>. Its behavior mostly cares about handling the exit signal cleanly,
by just quitting the application directly from the current state.</p>
</blockquote>
<h2><a class="header" href="#setting-up-the-logger" id="setting-up-the-logger">Setting up the logger</a></h2>
<p>Inside <code>main()</code> we first start the amethyst logger with a default <code>LoggerConfig</code>
so we can see errors, warnings and debug messages while the program is running.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>amethyst::start_logger(Default::default());
<span class="boring">}
</span></code></pre>
<p>From now on, every info, warning, and error will be present and clearly formatted
inside your terminal window.</p>
<blockquote>
<p><strong>Note:</strong> There are many ways to configure that logger, for example, to write the
log to the filesystem. You can find more information about how to do that in <a href="https://docs.amethyst.rs/stable/amethyst/struct.Logger.html">Logger API
reference</a>.
We will use the most basic setup in this tutorial for simplicity.</p>
</blockquote>
<h2><a class="header" href="#preparing-the-display-config" id="preparing-the-display-config">Preparing the display config</a></h2>
<p>Next, we need to create a <code>DisplayConfig</code> to store the configuration for our game's
window. We can either define the configuration in our code or better yet load it
from a file. The latter approach is handier, as it allows us to change configuration
(e.g, the window size) without having to recompile our game every time.</p>
<p>Starting the project with <code>amethyst new</code> should have automatically generated
<code>DisplayConfig</code> data in <code>config/display.ron</code>. If you created the
project manually, go ahead and create it now.</p>
<p>In either case, open <code>display.ron</code> and change its contents to the
following:</p>
<pre><code class="language-rust ignore">(
    title: &quot;Pong!&quot;,
    dimensions: Some((500, 500)),
)
</code></pre>
<blockquote>
<p><strong>Note:</strong> If you have never run into Rusty Object Notation before (or RON for short),
it is a data storage format that mirrors Rust's syntax. Here, the
data represents the <a href="https://docs.amethyst.rs/stable/amethyst_renderer/struct.DisplayConfig.html"><code>DisplayConfig</code></a> struct. If you want to
learn more about the RON syntax, you can visit the <a href="https://github.com/ron-rs/ron">official repository</a>.</p>
</blockquote>
<p>This will set the default window dimensions to 500 x 500, and make the title bar
say &quot;Pong!&quot; instead of the sad, lowercase default of &quot;pong&quot;.</p>
<p>In <code>main()</code> in <code>main.rs</code>, we will prepare the path to a file containing
the display configuration:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Error&gt;{
</span>let app_root = application_root_dir()?;
let display_config_path = app_root.join(&quot;config&quot;).join(&quot;display.ron&quot;);
<span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#creating-an-application" id="creating-an-application">Creating an application</a></h2>
<p>In <code>main()</code> in <code>main.rs</code> we are going to add the basic application setup:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    prelude::*,
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">};
</span><span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt; {
</span><span class="boring">struct Pong; impl SimpleState for Pong {}
</span>let game_data = GameDataBuilder::default();

<span class="boring">let app_root = application_root_dir()?;
</span>let assets_dir = app_root.join(&quot;assets&quot;);
let mut game = Application::new(assets_dir, Pong, game_data)?;
game.run();
<span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Here we're creating a new instance of <code>GameDataBuilder</code>, a central repository
of all the game logic that runs periodically during the game runtime. Right now it's empty,
but soon we will start adding all sorts of systems and bundles to it - which will run our game code.</p>
<p>That builder is then combined with the game state struct (<code>Pong</code>), creating the overarching
Amethyst's root object: <a href="https://docs.amethyst.rs/stable/amethyst/type.Application.html">Application</a>. It binds the OS event loop, state machines,
timers and other core components in a central place.</p>
<p>Then we call <code>.run()</code> on <code>game</code> which starts the game loop. The game will
continue to run until our <code>SimpleState</code> returns <code>Trans::Quit</code>, or when all states
have been popped off the state machine's stack.</p>
<p>Now, try compiling the code.</p>
<blockquote>
<p><strong>Note:</strong> Please note that when compiling the game for the first time, it may
take upwards an half an hour. Be assured, though, that subsequent builds of
the project will be faster.</p>
</blockquote>
<p>You should be able to see the application start, but nothing
will happen and your terminal will hang until you kill the process. This means that the
core game loop is running in circles, and is awaiting tasks. Let's give it something
to do by adding a renderer!</p>
<h2><a class="header" href="#setting-up-basic-rendering" id="setting-up-basic-rendering">Setting up basic rendering</a></h2>
<p>After preparing the display config and application scaffolding, it's time to actually use it.
Last time we left our <code>GameDataBuilder</code> instance empty, now we'll add some systems to it.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{
</span><span class="boring">        plugins::{RenderFlat2D, RenderToWindow},
</span><span class="boring">        types::DefaultBackend,
</span><span class="boring">        RenderingBundle,
</span><span class="boring">    },
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">};
</span><span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt;{
</span>let app_root = application_root_dir()?;

let display_config_path = app_root.join(&quot;config&quot;).join(&quot;display.ron&quot;);

let game_data = GameDataBuilder::default()
    .with_bundle(
        RenderingBundle::&lt;DefaultBackend&gt;::new()
            // The RenderToWindow plugin provides all the scaffolding for opening a window and drawing on it
            .with_plugin(
                RenderToWindow::from_config_path(display_config_path)?
                    .with_clear([0.0, 0.0, 0.0, 1.0]),
            )
            // RenderFlat2D plugin is used to render entities with a `SpriteRender` component.
            .with_plugin(RenderFlat2D::default()),
    )?;
<span class="boring">Ok(()) }
</span></code></pre>
<p>Here we are adding a <code>RenderingBundle</code>. Bundles are essentially sets of systems
preconfigured to work together, so you don't have to write them all down one by one.</p>
<blockquote>
<p><strong>Note:</strong> We will cover systems and bundles in more detail later. For now, think of a bundle
as a collection of systems that, in combination, will provide a certain feature to the engine.
You will surely be writing your own bundles for your own game's features soon.</p>
</blockquote>
<p>The <code>RenderingBundle</code> has a difference to most other bundles: It doesn't really do much by itself.
Instead, it relies on its own plugin system to define what should be rendered and how. We use the
<code>with_plugin</code> method to tell it that we want to add the <code>RenderToWindow</code> and <code>RenderFlat2D</code> plugins.
Those plugins will equip our renderer with the ability to open a window and draw sprites to it.</p>
<p>In this configuration, our window will have a black background.
If you want to use a different color, you can tweak the RGBA
values inside <code>with_clear</code>. Values range from <code>0.0</code> to <code>1.0</code>, try using for
instance <code>[0.00196, 0.23726, 0.21765, 1.0]</code> to get a nice cyan-colored window.</p>
<blockquote>
<p><strong>Note:</strong> This setup code is using Amethyst's <code>RenderPlugin</code> trait based system that
uses <code>rendy</code> crate to define the rendering. If you plan to go beyond the rendering
building blocks that Amethyst provides out of the box, you can read about
render graph in the <a href="https://github.com/amethyst/rendy/blob/master/docs/graph.md">rendy graph docs</a>.</p>
</blockquote>
<p>Success! Now we can compile and run this code with <code>cargo run</code> and
get a window. It should look something like this:</p>
<p><img src="pong-tutorial/../images/pong_tutorial/pong_01.png" alt="Step one" /></p>
<h1><a class="header" href="#drawing-the-paddles" id="drawing-the-paddles">Drawing the paddles</a></h1>
<p>Now let's do some drawing! But to draw something, we need something to draw. In
Amethyst, those &quot;somethings&quot; are called entities.</p>
<p>Amethyst uses an Entity-Component-System (ECS) framework called <strong>specs</strong>, also
written in Rust. You can learn more about Specs in the <a href="https://specs.amethyst.rs/docs/tutorials/">The Specs Book</a>.
Here's a basic explanation of ECS from the documentation:</p>
<blockquote>
<p>The term ECS is shorthand for Entity-Component-System. These are the three
core concepts. Each <strong>entity</strong> is associated with some <strong>components</strong>. Those entities
and components are processed by <strong>systems</strong>. This way, you have your data
(components) completely separated from the behavior (systems). An entity just
logically groups components; so a Velocity component can be applied to the
Position component of the same entity.</p>
</blockquote>
<p>I recommend at least skimming the rest of The Specs Book to get a good intuition
of how Amethyst works, especially if you're new to ECS.</p>
<h2><a class="header" href="#a-quick-refactor" id="a-quick-refactor">A quick refactor</a></h2>
<p>Before adding more of the Pong logic, we are going to separate the application
initialization code from the Pong code.</p>
<ol>
<li>
<p>In the <code>src</code> directory, create a new file called <code>pong.rs</code> and add the
following <code>use</code> statements. These are needed to make it through this chapter:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    assets::{AssetStorage, Loader, Handle},
    core::transform::Transform,
    ecs::{Component, DenseVecStorage},
    prelude::*,
    renderer::{Camera, ImageFormat, SpriteRender, SpriteSheet, SpriteSheetFormat, Texture},
};
</code></pre>
</li>
<li>
<p>Move the <code>Pong</code> struct and the <code>impl SimpleState for Pong</code> block from
<code>main.rs</code> into <code>pong.rs</code>.</p>
</li>
<li>
<p>In <code>main.rs</code> declare <code>pong</code> as a module and import the <code>Pong</code> state:</p>
<pre><code class="language-rust ignore">mod pong;

use crate::pong::Pong;
</code></pre>
</li>
</ol>
<h2><a class="header" href="#get-around-the-world" id="get-around-the-world">Get around the World</a></h2>
<p>First, in <code>pong.rs</code>, let's add a new method to our <code>State</code> implementation: <code>on_start</code>.
This method is called when the State starts. We will leave it empty for now.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">struct Pong;
</span>impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {

    }
}
</code></pre>
<p>The <code>StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;</code> is a structure given to all State methods.
The important part of its content here is its <code>world</code> field.</p>
<p>The <code>World</code> structure stores all of the game's runtime data -- entities and components.</p>
<h2><a class="header" href="#rendering-the-game-using-the-camera" id="rendering-the-game-using-the-camera">Rendering the game using the Camera</a></h2>
<p>The first thing we will need in our game is a <code>Camera</code>. This is the component that
will determine what is rendered on screen. It behaves just like a real-life
camera: it looks at a specific part of the world and can be moved around at
will.</p>
<ol>
<li>
<p>Define the size of the playable area at the top of <code>pong.rs</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub const ARENA_HEIGHT: f32 = 100.0;
pub const ARENA_WIDTH: f32 = 100.0;
</code></pre>
<p>These are public as they will be used in other modules.</p>
</li>
<li>
<p>Create the camera entity.</p>
<p>In pong, we want the camera to cover the entire arena. Let's do it in a new function <code>initialise_camera</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">const ARENA_WIDTH: f32 = 100.0;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">use amethyst::renderer::Camera;
</span><span class="boring">use amethyst::core::Transform;
</span>fn initialise_camera(world: &amp;mut World) {
    // Setup camera in a way that our screen covers whole arena and (0, 0) is in the bottom left.
    let mut transform = Transform::default();
    transform.set_translation_xyz(ARENA_WIDTH * 0.5, ARENA_HEIGHT * 0.5, 1.0);

    world
        .create_entity()
        .with(Camera::standard_2d(ARENA_WIDTH, ARENA_HEIGHT))
        .with(transform)
        .build();
}
</code></pre>
<p>This creates an entity that will carry our camera, with an orthographic
projection of the size of our arena. We also attach a <code>Transform</code> component,
representing its position in the world.</p>
<p>The <code>Camera::standard_2d</code> function creates a default 2D camera that is
pointed along the world's <strong>Z</strong> axis. The area in front of the camera has a
horizontal <strong>X</strong> axis, and a vertical <strong>Y</strong> axis. The <strong>X</strong> axis increases
moving to the right, and the <strong>Y</strong> axis increases moving up. The camera's
position is the center of the viewable area. We position the camera with
<code>set_translation_xyz</code> to the middle of our game arena so that <code>(0, 0)</code> is
the bottom left of the viewable area, and <code>(ARENA_WIDTH, ARENA_HEIGHT)</code> is
the top right.</p>
<p>Notice that we also shifted the camera <code>1.0</code> along the <strong>Z</strong> axis. This is
to make sure that the camera is able to see the sprites that sit on the
<strong>XY</strong> plane where <strong>Z</strong> is 0.0:</p>
<p><img src="pong-tutorial/../images/pong_tutorial/camera.png" alt="Camera Z shift" /></p>
<blockquote>
<p><strong>Note:</strong> Orthographic projections are a type of 3D visualization on 2D screens
that keeps the size ratio of the 2D images displayed intact. They are very
useful in games without actual 3D, like our pong example. Perspective projections
are another way of displaying graphics, more useful in 3D scenes.</p>
</blockquote>
</li>
<li>
<p>To finish setting up the camera, we need to call <code>initialise_camera</code> from the
Pong state's <code>on_start</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
</li>
</ol>
<p>Now that our camera is set up, it's time to add the paddles.</p>
<h2><a class="header" href="#our-first-component" id="our-first-component">Our first Component</a></h2>
<p>Now, we will create the <code>Paddle</code> component, all in <code>pong.rs</code>.</p>
<ol>
<li>
<p>Define constants for the paddle width and height.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub const PADDLE_HEIGHT: f32 = 16.0;
pub const PADDLE_WIDTH: f32 = 4.0;
</code></pre>
</li>
<li>
<p>Define the <code>Side</code> enum and <code>Paddle</code> struct:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">pub const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">pub const PADDLE_WIDTH: f32 = 4.0;
</span><span class="boring">
</span>#[derive(PartialEq, Eq)]
pub enum Side {
    Left,
    Right,
}

pub struct Paddle {
    pub side: Side,
    pub width: f32,
    pub height: f32,
}

impl Paddle {
    fn new(side: Side) -&gt; Paddle {
        Paddle {
            side,
            width: PADDLE_WIDTH,
            height: PADDLE_HEIGHT,
        }
    }
}
</code></pre>
<p><em>&quot;But that just looks like a regular struct!&quot;</em> you might say.</p>
<p>And you're right, the special sauce comes next.</p>
</li>
<li>
<p>Implement the <code>Component</code> trait for <code>Paddle</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">struct Paddle;
</span><span class="boring">
</span>impl Component for Paddle {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>By implementing <code>Component</code> for the <code>Paddle</code> struct, it can now be attached
to entities in the game.</p>
<p>When implementing the <code>Component</code> trait, we must specify the storage type.
Different storage types optimize for faster access, lower memory usage, or a
balance between the two. For more information on storage types, check out the
<a href="https://specs.amethyst.rs/docs/tutorials/05_storages.html#densevecstorage">Specs documentation</a>.</p>
</li>
</ol>
<h2><a class="header" href="#initialise-some-entities" id="initialise-some-entities">Initialise some entities</a></h2>
<p>Now that we have a <code>Paddle</code> component, let's define some paddle entities that
include that component and add them to our <code>World</code>.</p>
<p>First let's look at our imports:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::core::transform::Transform;
</code></pre>
<p><code>Transform</code> is an Amethyst ECS component which carries
position and orientation information. It is relative
to a parent, if one exists.</p>
<p>Okay, let's make some entities! We'll define an <code>initialise_paddles</code> function
which will create left and right paddle entities and attach a <code>Transform</code>
component to each to position them in our world. As we defined earlier,
our canvas is from <code>0.0</code> to <code>ARENA_WIDTH</code> in the horizontal dimension and
from <code>0.0</code> to <code>ARENA_HEIGHT</code> in the vertical dimension.
Keep in mind that the anchor point of our entities will be in the middle of the
image we will want to render on top of them. This is a good rule to follow in
general, as it makes operations like rotation easier.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">enum Side {
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;
</span><span class="boring">}
</span><span class="boring">impl Paddle {
</span><span class="boring">  fn new(side: Side) -&gt; Paddle { Paddle }
</span><span class="boring">}
</span><span class="boring">const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">const PADDLE_WIDTH: f32 = 4.0;
</span><span class="boring">const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">const ARENA_WIDTH: f32 = 100.0;
</span>/// Initialises one paddle on the left, and one paddle on the right.
fn initialise_paddles(world: &amp;mut World) {
    let mut left_transform = Transform::default();
    let mut right_transform = Transform::default();

    // Correctly position the paddles.
    let y = ARENA_HEIGHT / 2.0;
    left_transform.set_translation_xyz(PADDLE_WIDTH * 0.5, y, 0.0);
    right_transform.set_translation_xyz(ARENA_WIDTH - PADDLE_WIDTH * 0.5, y, 0.0);

    // Create a left plank entity.
    world
        .create_entity()
        .with(Paddle::new(Side::Left))
        .with(left_transform)
        .build();

    // Create right plank entity.
    world
        .create_entity()
        .with(Paddle::new(Side::Right))
        .with(right_transform)
        .build();
}
</code></pre>
<p>This is all the information Amethyst needs to track and move the paddles in our
virtual world, but we'll need to do some more work to actually <em>draw</em> them.</p>
<p>As a sanity check, let's make sure the code for initialising the paddles
compiles. Update the <code>on_start</code> method to the following:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">fn initialise_paddles(world: &amp;mut World) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    initialise_paddles(world);
    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
<p>Let's run our blank screen game!</p>
<pre><code class="language-text ignore">Tried to fetch resource of type `MaskedStorage&lt;Paddle&gt;`[^1] from the `World`, but the resource does not exist.

You may ensure the resource exists through one of the following methods:

* Inserting it when the world is created: `world.insert(..)`.
* If the resource implements `Default`, include it in a system's `SystemData`, and ensure the system is registered in the dispatcher.
* If the resource does not implement `Default`, insert in the world during `System::setup`.

[^1]: Full type name: `amethyst::ecs::storage::MaskedStorage&lt;pong::Paddle&gt;`
</code></pre>
<p>Uh oh, what's wrong?</p>
<p>For a <code>Component</code> to be used, there must be a <code>Storage&lt;ComponentType&gt;</code> resource
set up in the <code>World</code>. The error message above means we have registered the
<code>Paddle</code> component on an entity, but have not set up the <code>Storage</code>. We can fix
this by adding the following line before <code>initialise_paddles(world)</code> in the
<code>on_start</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;
</span><span class="boring">}
</span><span class="boring">fn register() {
</span><span class="boring">  let mut world = World::new();
</span>world.register::&lt;Paddle&gt;();
<span class="boring">}
</span></code></pre>
<p>This is rather inconvenient — to need to manually register each component
before it can be used. There <em>must</em> be a better way. <strong>Hint:</strong> there is.</p>
<p>When we add systems to our application, any component that a <code>System</code> uses is
automatically registered.
However, as we haven't got any <code>System</code>s, we have to
live with registering the <code>Paddle</code> component manually.</p>
<p>Let's run the game again.</p>
<h2><a class="header" href="#bundles" id="bundles">Bundles</a></h2>
<p>Amethyst has a lot of internal systems it uses to keep things running we need
to bring into the context of the <code>World</code>. For simplicity, these have been
grouped into &quot;Bundles&quot; which include related systems and resources. We can
add these to our Application's <code>GameData</code> using the <code>with_bundle</code> method,
similarly to how you would register a system. We already have <code>RenderBundle</code> in place,
registering another one will look similar. You have to first import
<code>TransformBundle</code>, then register it as follows:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::core::transform::TransformBundle;
<span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    prelude::*,
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">
</span>fn main() -&gt; amethyst::Result&lt;()&gt; {
<span class="boring">  amethyst::start_logger(Default::default());
</span><span class="boring">
</span><span class="boring">  let app_root = application_root_dir()?;
</span><span class="boring">  let display_config_path =
</span><span class="boring">      app_root.join(&quot;examples/pong_tutorial_02/config/display.ron&quot;);
</span><span class="boring">
</span>    // ...
    let game_data = GameDataBuilder::default()
        // ...

        // Add the transform bundle which handles tracking entity positions
        .with_bundle(TransformBundle::new())?;

<span class="boring">  let assets_dir = &quot;/&quot;;
</span><span class="boring">  let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">  Ok(())
</span>}
</code></pre>
<p>This time, when you run the game you should see the familiar black screen.
Hooray!</p>
<h2><a class="header" href="#drawing" id="drawing">Drawing</a></h2>
<p>This section will finally allow us to see something.</p>
<p>The first thing we will have to do is load the sprite sheet we will use for all
our graphics in the game. Create a <code>texture</code> folder in the <code>assets</code> directory of the project.
This will contain the <a href="pong-tutorial/../images/pong_tutorial/pong_spritesheet.png">spritesheet texture</a> <code>pong_spritesheet.png</code>, which we
need to render the elements of the game.  We will perform the loading in a new
function in <code>pong.rs</code> called <code>load_sprite_sheet</code>.</p>
<p>First, let's declare the function and load the sprite sheet's image data.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{AssetStorage, Loader, Handle},
</span><span class="boring">    core::transform::Transform,
</span><span class="boring">    ecs::{Component, DenseVecStorage},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{
</span><span class="boring">        camera::Camera,
</span><span class="boring">        formats::texture::ImageFormat,
</span><span class="boring">        sprite::{SpriteRender, SpriteSheet, SpriteSheetFormat},
</span><span class="boring">        Texture,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; {
    // Load the sprite sheet necessary to render the graphics.
    // The texture is the pixel data
    // `texture_handle` is a cloneable reference to the texture
    let texture_handle = {
        let loader = world.read_resource::&lt;Loader&gt;();
        let texture_storage = world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;();
        loader.load(
            &quot;texture/pong_spritesheet.png&quot;,
            ImageFormat::default(),
            (),
            &amp;texture_storage,
        )
    };

    //...
<span class="boring">  unimplemented!()
</span>}
</code></pre>
<p>The <code>Loader</code> is an asset loader which is defined as a resource (not an
<code>Entity</code>, <code>Component</code>, or <code>System</code>, but still a part of our ECS <code>World</code>). It was
created when we built our Application in <code>main.rs</code>, and it can read assets like
.obj files, but also it can <code>load</code> a .png as a <code>Texture</code> as in our use case.</p>
<blockquote>
<p>Resources in Specs are a type of data which can be shared between systems,
while being independent of entities, in contrast to components, which are
attached to specific entities.</p>
</blockquote>
<p>The <code>AssetStorage&lt;Texture&gt;</code> is also a resource; this is where the loader
puts the <code>Texture</code> it will load from our sprite sheet. In order to manage them
while remaining fast, Amethyst does not give us direct access to the assets we load.
If it did otherwise, we would have to wait for the texture to be fully loaded to do all the
other things we have to prepare, which would be a waste of time!
Instead, the <code>load</code> function will return a <code>Handle&lt;Texture&gt;</code>.
This handle &quot;points&quot; to the place where the asset will be loaded. In Rust terms, it is
equivalent to a reference-counted option. It is extremely useful, especially as cloning
the handle does not clone the asset in memory, so many things can use the same asset at once.</p>
<p>Alongside our sprite sheet texture, we need a file describing where the sprites
are on the sheet. Let's create, right next to it, a file called
<code>pong_spritesheet.ron</code>. It will contain the following sprite sheet definition:</p>
<pre><code class="language-text ignore">List((
    texture_width: 8,
    texture_height: 16,
    sprites: [
        (
            x: 0,
            y: 0,
            width: 4,
            height: 16,
        ),
        (
            x: 4,
            y: 0,
            width: 4,
            height: 4,
        ),
    ],
))
</code></pre>
<blockquote>
<p><strong>Note:</strong> Make sure to pay attention to the kind of parentheses in the ron file.
Especially, if you are used to writing JSON or similar format files, you might
be tempted to use curly braces there; that will however lead to very
hard-to-debug errors, especially since amethyst will not warn you about that
when compiling.</p>
</blockquote>
<p>Finally, we load the file containing the position of each sprite on the sheet.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{AssetStorage, Handle, Loader},
</span><span class="boring">    core::transform::Transform,
</span><span class="boring">    ecs::{Component, DenseVecStorage},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{
</span><span class="boring">        camera::Camera,
</span><span class="boring">        formats::texture::ImageFormat,
</span><span class="boring">        sprite::{SpriteRender, SpriteSheet, SpriteSheetFormat},
</span><span class="boring">        Texture,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">
</span>fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; {
<span class="boring">
</span><span class="boring">  let texture_handle = {
</span><span class="boring">      let loader = world.read_resource::&lt;Loader&gt;();
</span><span class="boring">      let texture_storage = world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;();
</span><span class="boring">      loader.load(
</span><span class="boring">          &quot;texture/pong_spritesheet.png&quot;,
</span><span class="boring">          ImageFormat::default(),
</span><span class="boring">          (),
</span><span class="boring">          &amp;texture_storage,
</span><span class="boring">      )
</span><span class="boring">  };
</span><span class="boring">
</span>    // ...

    let loader = world.read_resource::&lt;Loader&gt;();
    let sprite_sheet_store = world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;();
    loader.load(
        &quot;texture/pong_spritesheet.ron&quot;, // Here we load the associated ron file
        SpriteSheetFormat(texture_handle),
        (),
        &amp;sprite_sheet_store,
    )
<span class="boring">}
</span></code></pre>
<p>This is where we have to use the texture handle. The <code>Loader</code> will take the
file containing the sprites' positions and the texture handle, and create a
nicely packaged <code>SpriteSheet</code> struct. It is this struct that we will be using
to actually draw stuff on the screen.</p>
<p>Please note that the order of sprites declared in the sprite sheet file
is also significant, as sprites are referenced by the index in
the vector. If you're wondering about the ball sprite, it does exist on the
image, but we will get to it in a later part of the tutorial.</p>
<p>So far, so good. We have a sprite sheet loaded, now we need to link the sprites
to the paddles. We update the <code>initialise_paddles</code> function by changing its
signature to:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">use amethyst::{assets::Handle, renderer::sprite::SpriteSheet};
</span>fn initialise_paddles(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;)
<span class="boring">{ }
</span></code></pre>
<p>Inside <code>initialise_paddles</code>, we construct a <code>SpriteRender</code> for a paddle. We
only need one here, since the only difference between the two paddles is that
the right one is flipped horizontally.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">use amethyst::{assets::Handle, renderer::{SpriteRender, SpriteSheet}};
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) {
</span>// Assign the sprites for the paddles
let sprite_render = SpriteRender::new(sprite_sheet_handle, 0);  // paddle is the first sprite in the sprite_sheet
<span class="boring">}
</span></code></pre>
<p><code>SpriteRender</code> is the <code>Component</code> that indicates which sprite of which sprite
sheet should be drawn for a particular entity. Since the paddle is the first
sprite in the sprite sheet, we use <code>0</code> for the <code>sprite_number</code>.</p>
<p>Next we simply add the components to the paddle entities:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">use amethyst::assets::Handle;
</span><span class="boring">use amethyst::renderer::sprite::{SpriteSheet, SpriteRender};
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) {
</span><span class="boring">let sprite_render = SpriteRender::new(sprite_sheet_handle, 0);  // paddle is the first sprite in the sprite_sheet
</span>// Create a left plank entity.
world
    .create_entity()
    .with(sprite_render.clone())
    // ... other components
    .build();

// Create right plank entity.
world
    .create_entity()
    .with(sprite_render)
    // ... other components
    .build();
<span class="boring">}
</span></code></pre>
<p>We're nearly there, we just have to wire up the sprite to the paddles. We put it
all together in the <code>on_start()</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::Handle;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::renderer::{sprite::SpriteSheet, Texture};
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    // Load the spritesheet necessary to render the graphics.
    let sprite_sheet_handle = load_sprite_sheet(world);

    world.register::&lt;Paddle&gt;();

    initialise_paddles(world, sprite_sheet_handle);
    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
<p>And we're done. Let's run our game and have fun!</p>
<p>If all is well, we should get something that looks like this:</p>
<p><img src="pong-tutorial/../images/pong_tutorial/pong_02.png" alt="Step two" /></p>
<p>In the next chapter, we'll explore the &quot;S&quot; in ECS and actually get these paddles
moving!</p>
<h1><a class="header" href="#moving-the-paddles" id="moving-the-paddles">Moving the paddles</a></h1>
<p>In the previous chapter, we learned about the relationship between entities and
components, and how they represent the &quot;things&quot; in our games. This chapter
introduces Systems - the S in &quot;ECS&quot;. Systems are objects that represent
operations over entities, or more specifically, combinations of components.
Let's add a system that moves the paddles based on user input.</p>
<p>A system is nothing more than a function that runs once each frame and
potentially makes some changes to components. If you've used other game
engines, this probably sounds familiar: Unity engine calls these objects
<code>MonoBehaviour</code>s and Unreal engine calls them <code>Actor</code>s, but these all represent
the same basic idea.</p>
<p>Systems in Specs / Amethyst are slightly different. Rather than describing the
behavior of a single instance (e.g., a single enemy in your game), they describe
the behavior of all components of a specific type (all enemies). This makes
your code more modular, easier to test, and makes it run faster.</p>
<p>Let's get started.</p>
<h2><a class="header" href="#capturing-user-input" id="capturing-user-input">Capturing user input</a></h2>
<p>To capture user input, we'll need to introduce a few more files to our game.
Let's start by creating a config file under the <code>config</code> directory of our
project, called <code>bindings.ron</code>, which will contain a RON representation
of the <a href="https://docs.amethyst.rs/stable/amethyst_input/struct.Bindings.html">amethyst_input::Bindings</a> struct:</p>
<pre><code class="language-ron ignore">(
  axes: {
    &quot;left_paddle&quot;: Emulated(pos: Key(W), neg: Key(S)),
    &quot;right_paddle&quot;: Emulated(pos: Key(Up), neg: Key(Down)),
  },
  actions: {},
)
</code></pre>
<p>In Amethyst, inputs can either be axes (a range that represents an analog
controller stick or relates two buttons as opposite ends of a range), or actions
(also known as scalar input - a button that is either pressed or not).
In this file, we're creating the inputs to move each paddle up (<code>pos:</code>) or down
(<code>neg:</code>) on the vertical axis: <strong>W</strong> and <strong>S</strong> for the left paddle, and the <strong>Up</strong>
and <strong>Down</strong> arrow keys for the right paddle.
We name them <code>&quot;left_paddle&quot;</code> and <code>&quot;right_paddle&quot;</code>, which will allow us to
refer to them by name in the code when we will need to read their respective values
to update positions.</p>
<p>Next, we'll add an <code>InputBundle</code> to the game's <code>Application</code> object, that
contains an <code>InputHandler</code> system which captures inputs, and maps them to the
axes we defined. Let's make the following changes to <code>main.rs</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::core::transform::TransformBundle;
</span><span class="boring">use amethyst::utils::application_root_dir;
</span><span class="boring">use amethyst::window::DisplayConfig;
</span><span class="boring">macro_rules! env { ($x:expr) =&gt; (&quot;&quot;) }
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span>use amethyst::input::{InputBundle, StringBindings};

<span class="boring">let app_root = application_root_dir()?;
</span>let binding_path = app_root.join(&quot;config&quot;).join(&quot;bindings.ron&quot;);

let input_bundle = InputBundle::&lt;StringBindings&gt;::new()
    .with_bindings_from_file(binding_path)?;

<span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">let assets_dir = &quot;assets&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span>let game_data = GameDataBuilder::default()
    .with_bundle(TransformBundle::new())?
    .with_bundle(input_bundle)?
    // ..
    ;
let mut game = Application::new(assets_dir, Pong, game_data)?;
game.run();
<span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>For <code>InputBundle&lt;StringBindings&gt;</code>, the parameter type determines how <code>axes</code> and <code>actions</code>
are identified in the <code>bindings.ron</code> file
(in this example, <code>String</code>s are used; e.g. <code>&quot;left_paddle&quot;</code>).</p>
<p>At this point, we're ready to write a system that reads input from the
<code>InputHandler</code>, and moves the paddles accordingly. First, we'll create a
directory called <code>systems</code> under <code>src</code> to hold all our systems. We'll use a
module to collect and export each of our systems to the rest of the
application. Here's our <code>mod.rs</code> for <code>src/systems</code>:</p>
<pre><code class="language-rust ignore">pub use self::paddle::PaddleSystem;

mod paddle;
</code></pre>
<p>We're finally ready to implement the <code>PaddleSystem</code> in <code>systems/paddle.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub enum Side {
</span><span class="boring">      Left,
</span><span class="boring">      Right,
</span><span class="boring">    }
</span><span class="boring">    pub struct Paddle {
</span><span class="boring">      pub side: Side,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Paddle {
</span><span class="boring">      type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">    pub const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::core::{Transform, SystemDesc};
use amethyst::derive::SystemDesc;
use amethyst::ecs::{Join, Read, ReadStorage, System, SystemData, World, WriteStorage};
use amethyst::input::{InputHandler, StringBindings};

// You'll have to mark PADDLE_HEIGHT as public in pong.rs
use crate::pong::{Paddle, Side, ARENA_HEIGHT, PADDLE_HEIGHT};

#[derive(SystemDesc)]
pub struct PaddleSystem;

impl&lt;'s&gt; System&lt;'s&gt; for PaddleSystem {
    type SystemData = (
        WriteStorage&lt;'s, Transform&gt;,
        ReadStorage&lt;'s, Paddle&gt;,
        Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;,
    );

    fn run(&amp;mut self, (mut transforms, paddles, input): Self::SystemData) {
        for (paddle, transform) in (&amp;paddles, &amp;mut transforms).join() {
            let movement = match paddle.side {
                Side::Left =&gt; input.axis_value(&quot;left_paddle&quot;),
                Side::Right =&gt; input.axis_value(&quot;right_paddle&quot;),
            };
            if let Some(mv_amount) = movement {
                if mv_amount != 0.0 {
                    let side_name = match paddle.side {
                        Side::Left =&gt; &quot;left&quot;,
                        Side::Right =&gt; &quot;right&quot;,
                    };
                    println!(&quot;Side {:?} moving {}&quot;, side_name, mv_amount);
                }
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Alright, there's quite a bit going on here!</p>
<p>We create a unit struct <code>PaddleSystem</code>, and with the <code>SystemDesc</code> derive. This
is short for <strong>System Descriptor</strong>. In Amethyst, systems may need to access
resources from the <code>World</code> in order to be instantiated. For each <code>System</code>, an
implementation of the <code>SystemDesc</code> trait must be provided to specify the logic
to instantiate the <code>System</code>. For <code>System</code>s that do not require special
instantiation logic, the <code>SystemDesc</code> derive automatically implements the
<code>SystemDesc</code> trait on the system type itself.</p>
<p>Next, we implement the <code>System</code> trait for it with the lifetime of the components
on which it operates. Inside the implementation, we define the data the system
operates on in the <code>SystemData</code> tuple: <code>WriteStorage</code>, <code>ReadStorage</code>, and
<code>Read</code>. More specifically, the generic types we've used here tell us that the
<code>PaddleSystem</code> mutates <code>Transform</code> components, <code>WriteStorage&lt;'s, Transform&gt;</code>, it
reads <code>Paddle</code> components, <code>ReadStorage&lt;'s, Paddle&gt;</code>, and also accesses the
<code>InputHandler&lt;StringBindings&gt;</code> resource we created earlier, using the <code>Read</code>
structure.</p>
<blockquote>
<p>For <code>InputHandler&lt;StringBindings&gt;</code>, make sure the parameter type is the same
as the one used to create the <code>InputBundle</code> earlier.</p>
</blockquote>
<p>Now that we have access to the storages of the components we want, we can iterate
over them. We perform a join operation over the <code>Transform</code> and <code>Paddle</code>
storages. This will iterate over all entities that have both a <code>Paddle</code>
and <code>Transform</code> attached to them, and give us access to the actual components,
immutable for the <code>Paddle</code> and mutable for the <code>Transform</code>.</p>
<blockquote>
<p>There are many other ways to use storages. For example, you can use them to get
a reference to the component of a specific type held by an entity, or simply
iterate over them without joining. However, in practice, your most common use will
be to join over multiple storages as it is rare to have a system affect
only one specific component.</p>
</blockquote>
<blockquote>
<p>Please also note that it is possible to join over storages using multiple threads
by using <code>par_join</code> instead of <code>join</code>, but here the overhead introduced is not
worth the gain offered by parallelism.</p>
</blockquote>
<p>Let's add this system to our <code>GameDataBuilder</code> in <code>main.rs</code>:</p>
<pre><code class="language-rust ignore">mod systems; // Import the module
</code></pre>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::core::transform::TransformBundle;
</span><span class="boring">use amethyst::input::StringBindings;
</span><span class="boring">use amethyst::window::DisplayConfig;
</span>fn main() -&gt; amethyst::Result&lt;()&gt; {
// --snip--

<span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">mod systems {
</span><span class="boring">
</span><span class="boring">use amethyst::core::ecs::{System, SystemData, World};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">
</span><span class="boring">use amethyst;
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct PaddleSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">}
</span><span class="boring">let input_bundle = amethyst::input::InputBundle::&lt;StringBindings&gt;::new();
</span>let game_data = GameDataBuilder::default()
    // ...
    .with_bundle(TransformBundle::new())?
    .with_bundle(input_bundle)?
    .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;]) // Add this line
    // ...
<span class="boring">  ;
</span><span class="boring">let assets_dir = &quot;/&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">Ok(())
</span>}
</code></pre>
<p>Take a look at the <code>with</code> method call. Here, we're not adding a bundle, we're adding
a system alone. We provide an instance of the system, a string representing its name
and a list of dependencies. The dependencies are the names of the systems that
must be run before our newly added system. Here, we require the <code>input_system</code> to be run as we will use the user's input to move the paddles, so we need to have this
data be prepared. The <code>input_system</code> key itself is defined in the standard <code>InputBundle</code>.</p>
<h2><a class="header" href="#modifying-the-transform" id="modifying-the-transform">Modifying the transform</a></h2>
<p>If we run the game now, we'll see the console print our keypresses.
Let's make it update the position of the paddle. To do this, we'll modify the y
component of the transform's translation.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">use amethyst::ecs::{Join, Read, ReadStorage, System, SystemData, World, WriteStorage};
</span><span class="boring">use amethyst::input::{InputHandler, StringBindings};
</span><span class="boring">enum Side {
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">pub struct Paddle {
</span><span class="boring">  side: Side,
</span><span class="boring">}
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct PaddleSystem;
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for PaddleSystem {
</span><span class="boring"> type SystemData = (
</span><span class="boring">   WriteStorage&lt;'s, Transform&gt;,
</span><span class="boring">   ReadStorage&lt;'s, Paddle&gt;,
</span><span class="boring">   Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;,
</span><span class="boring"> );
</span>fn run(&amp;mut self, (mut transforms, paddles, input): Self::SystemData) {
    for (paddle, transform) in (&amp;paddles, &amp;mut transforms).join() {
        let movement = match paddle.side {
            Side::Left =&gt; input.axis_value(&quot;left_paddle&quot;),
            Side::Right =&gt; input.axis_value(&quot;right_paddle&quot;),
        };
        if let Some(mv_amount) = movement {
            let scaled_amount = 1.2 * mv_amount as f32;
            transform.prepend_translation_y(scaled_amount);
        }
    }
}
<span class="boring">}
</span></code></pre>
<p>This is our first attempt at moving the paddles: we take the movement and
scale it by some factor to make the motion seem smooth. In a real game, we
would use the time elapsed between frames to determine how far to move the
paddle, so that the behavior of the game would not be tied to the game's
framerate. Amethyst provides you with <a href="https://docs.amethyst.rs/stable/amethyst_core/timing/struct.Time.html"><code>amethyst::core::timing::Time</code></a>
for that purpose, but for now current approach should suffice.
If you run the game now, you'll notice the paddles are able to &quot;fall&quot; off the edges of the game area.</p>
<p>To fix this, we need to limit the paddle's movement to the arena border with
a minimum and maximum value. But as the anchor point of the paddle is in
the middle of the sprite, we also need to offset that limit by half the height
of the sprite for the paddles not to go halfway out of the screen.
Therefore, we will clamp the <strong>y</strong> value of the transform from
<code>ARENA_HEIGHT - PADDLE_HEIGHT * 0.5</code> (the top of the arena minus the offset)
to <code>PADDLE_HEIGHT * 0.5</code> (the bottom of the arena plus the offset).</p>
<p>Our run function should now look something like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">use amethyst::ecs::{Join, Read, ReadStorage, System, SystemData, World, WriteStorage};
</span><span class="boring">use amethyst::input::{InputHandler, StringBindings};
</span><span class="boring">const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">const PADDLE_WIDTH: f32 = 4.0;
</span><span class="boring">const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">const ARENA_WIDTH: f32 = 100.0;
</span><span class="boring">enum Side {
</span><span class="boring">  Left,
</span><span class="boring">  Right,
</span><span class="boring">}
</span><span class="boring">pub struct Paddle {
</span><span class="boring">  side: Side,
</span><span class="boring">}
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct PaddleSystem;
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for PaddleSystem {
</span><span class="boring"> type SystemData = (
</span><span class="boring">   WriteStorage&lt;'s, Transform&gt;,
</span><span class="boring">   ReadStorage&lt;'s, Paddle&gt;,
</span><span class="boring">   Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;,
</span><span class="boring"> );
</span>fn run(&amp;mut self, (mut transforms, paddles, input): Self::SystemData) {
    for (paddle, transform) in (&amp;paddles, &amp;mut transforms).join() {
        let movement = match paddle.side {
            Side::Left =&gt; input.axis_value(&quot;left_paddle&quot;),
            Side::Right =&gt; input.axis_value(&quot;right_paddle&quot;),
        };
        if let Some(mv_amount) = movement {
            let scaled_amount = 1.2 * mv_amount as f32;
            let paddle_y = transform.translation().y;
            transform.set_translation_y(
                (paddle_y + scaled_amount)
                    .min(ARENA_HEIGHT - PADDLE_HEIGHT * 0.5)
                    .max(PADDLE_HEIGHT * 0.5),
            );
        }
    }
}
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#automatic-set-up-of-resources-by-a-system" id="automatic-set-up-of-resources-by-a-system">Automatic set up of resources by a system.</a></h2>
<p>You might remember that we had troubles because Amethyst requires us
to <code>register</code> storage for <code>Paddle</code> before we could use it.</p>
<p>Now that we have a system in place that uses the <code>Paddle</code> component,
we no longer need to manually register it with the <code>world</code>: the system
will take care of that for us, as well as set up the storage.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::Handle;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::renderer::SpriteSheet;
</span><span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Paddle&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    // Load the spritesheet necessary to render the graphics.
    let sprite_sheet_handle = load_sprite_sheet(world);

    world.register::&lt;Paddle&gt;(); // &lt;&lt;-- No longer needed

    initialise_paddles(world, sprite_sheet_handle);
    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>In this chapter, we added an input handler to our game, so that we
could capture keypresses. We then created a system that would interpret these
keypresses, and move our game's paddles accordingly. In the next chapter, we'll
explore another key concept in real-time games: time. We'll make our game aware
of time, and add a ball for our paddles to bounce back and forth.</p>
<h1><a class="header" href="#making-a-ball-move-and-bounce" id="making-a-ball-move-and-bounce">Making a ball move and bounce</a></h1>
<p>In the previous chapter, we learned how to capture user input
to make things move on the screen by creating a <code>System</code> ourselves.
This chapter will reuse all the knowledge we acquired through the
previous chapters to add a new object to our game: a ball that moves
and bounces around!</p>
<p>First, let's define some other useful constants for this chapter in <code>pong.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub const BALL_VELOCITY_X: f32 = 75.0;
pub const BALL_VELOCITY_Y: f32 = 50.0;
pub const BALL_RADIUS: f32 = 2.0;
</code></pre>
<p>This could also be done by using an external config file. This is
especially useful when you want to edit values a lot. Here, we're
keeping it simple.</p>
<h2><a class="header" href="#create-our-next-component-the-ball-component" id="create-our-next-component-the-ball-component">Create our next Component: The ball Component!</a></h2>
<p>In <code>pong.rs</code>, let's create the <code>Ball</code> Component.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span>pub struct Ball {
    pub velocity: [f32; 2],
    pub radius: f32,
}

impl Component for Ball {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>A ball has a velocity and a radius, so we store that information in the component.</p>
<p>Then let's add an <code>initialise_ball</code> function the same way we wrote the
<code>initialise_paddles</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::assets::{Loader, AssetStorage, Handle};
</span><span class="boring">use amethyst::renderer::{Texture, SpriteRender, Sprite, SpriteSheet};
</span><span class="boring">use amethyst::core::transform::Transform;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage, World};
</span><span class="boring">pub struct Ball {
</span><span class="boring">   pub velocity: [f32; 2],
</span><span class="boring">   pub radius: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for Ball {
</span><span class="boring">   type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">const PADDLE_WIDTH: f32 = 4.0;
</span><span class="boring">const SPRITESHEET_SIZE: (f32, f32) = (8.0, 16.0);
</span><span class="boring">const BALL_RADIUS: f32 = 2.0;
</span><span class="boring">const BALL_VELOCITY_X: f32 = 75.0;
</span><span class="boring">const BALL_VELOCITY_Y: f32 = 50.0;
</span><span class="boring">const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">const ARENA_WIDTH: f32 = 100.0;
</span>/// Initialises one ball in the middle-ish of the arena.
fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) {
    // Create the translation.
    let mut local_transform = Transform::default();
    local_transform.set_translation_xyz(ARENA_WIDTH / 2.0, ARENA_HEIGHT / 2.0, 0.0);

    // Assign the sprite for the ball. The ball is the second sprite in the sheet.
    let sprite_render = SpriteRender::new(sprite_sheet_handle, 1);

    world
        .create_entity()
        .with(sprite_render)
        .with(Ball {
            radius: BALL_RADIUS,
            velocity: [BALL_VELOCITY_X, BALL_VELOCITY_Y],
        })
        .with(local_transform)
        .build();
}
</code></pre>
<p>In <a href="pong-tutorial/pong-tutorial-02.html#drawing">a previous chapter</a> we saw how to load a sprite sheet
and get things drawn on the screen. Remember sprite sheet information
is stored in <code>pong_spritesheet.ron</code>, and the ball sprite was the
second one, whose index is <code>1</code>.</p>
<p>Finally, let's make sure the code is working as intended by updating the <code>on_start</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::assets::Handle;
</span><span class="boring">use amethyst::renderer::{Texture, SpriteSheet};
</span><span class="boring">use amethyst::ecs::{Component, World, VecStorage};
</span><span class="boring">struct Paddle;
</span><span class="boring">impl Component for Paddle {
</span><span class="boring">  type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">struct Ball;
</span><span class="boring">impl Component for Ball {
</span><span class="boring">  type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    // Load the spritesheet necessary to render the graphics.
    let sprite_sheet_handle = load_sprite_sheet(world);

    world.register::&lt;Ball&gt;(); // &lt;- add this line temporarily

    initialise_ball(world, sprite_sheet_handle.clone()); // &lt;- add this line
    initialise_paddles(world, sprite_sheet_handle);
    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
<p>Don't forget to call <code>clone</code> on <code>sprite_sheet_handle</code> because <code>initialise_paddles</code> and
<code>initialise_ball</code> <em>consume</em> the handle.</p>
<p>By running the game now, you should be able to see the two paddles and the ball
in the center. In the next section, we're going to make this ball actually move!</p>
<h2><a class="header" href="#create-systems-to-make-the-ball-move" id="create-systems-to-make-the-ball-move">Create systems to make the ball move</a></h2>
<p>We're now ready to implement the <code>MoveBallsSystem</code> in <code>systems/move_balls.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">       pub velocity: [f32; 2],
</span><span class="boring">       pub radius: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">       type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::timing::Time,
    core::transform::Transform,
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{Join, Read, ReadStorage, System, SystemData, World, WriteStorage},
};

use crate::pong::Ball;

#[derive(SystemDesc)]
pub struct MoveBallsSystem;

impl&lt;'s&gt; System&lt;'s&gt; for MoveBallsSystem {
    type SystemData = (
        ReadStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
        Read&lt;'s, Time&gt;,
    );

    fn run(&amp;mut self, (balls, mut locals, time): Self::SystemData) {
        // Move every ball according to its speed, and the time passed.
        for (ball, local) in (&amp;balls, &amp;mut locals).join() {
            local.prepend_translation_x(ball.velocity[0] * time.delta_seconds());
            local.prepend_translation_y(ball.velocity[1] * time.delta_seconds());
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>This system is responsible for moving all balls according to their speed and
the elapsed time. Notice how the <code>join()</code> method is used to iterate over all
ball entities. Here we only have one ball, but if we ever need multiple, the
system will handle them out of the box.
In this system, we also want <em>framerate independence</em>.
That is, no matter the framerate, all objects move with the same speed.
To achieve that, a <strong>delta time</strong>, which is the duration since the last frame, is used.
This is commonly known as <a href="https://en.wikipedia.org/wiki/Delta_timing">&quot;delta timing&quot;</a>.
As you can see in the snippet, to gain access to time passed since the last frame,
you need to use <a href="https://docs.amethyst.rs/stable/amethyst_core/timing/struct.Time.html"><code>amethyst::core::timing::Time</code></a>, a commonly used
resource. It has a method called <code>delta_seconds</code> that does exactly what we want.</p>
<p>Now that our ball can move, let's implement a new System:
<code>BounceSystem</code> in <code>systems/bounce.rs</code>.
It will be responsible for detecting collisions between balls and
paddles, as well as balls and the top and bottom edges of the arena.
If a collision is detected, the ball bounces off. This is done
by negating the velocity of the <code>Ball</code> component on the <code>x</code> or <code>y</code> axis.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">       pub velocity: [f32; 2],
</span><span class="boring">       pub radius: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">       type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(PartialEq, Eq)]
</span><span class="boring">    pub enum Side {
</span><span class="boring">      Left,
</span><span class="boring">      Right,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct Paddle {
</span><span class="boring">      pub side: Side,
</span><span class="boring">      pub width: f32,
</span><span class="boring">      pub height: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Paddle {
</span><span class="boring">      type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::{Transform, SystemDesc},
    derive::SystemDesc,
    ecs::{Join, ReadStorage, System, SystemData, World, WriteStorage},
};

use crate::pong::{Ball, Side, Paddle, ARENA_HEIGHT};

<span class="boring">#[derive(SystemDesc)]
</span>pub struct BounceSystem;

impl&lt;'s&gt; System&lt;'s&gt; for BounceSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        ReadStorage&lt;'s, Paddle&gt;,
        ReadStorage&lt;'s, Transform&gt;,
    );

    fn run(&amp;mut self, (mut balls, paddles, transforms): Self::SystemData) {
        // Check whether a ball collided, and bounce off accordingly.
        //
        // We also check for the velocity of the ball every time, to prevent multiple collisions
        // from occurring.
        for (ball, transform) in (&amp;mut balls, &amp;transforms).join() {
            let ball_x = transform.translation().x;
            let ball_y = transform.translation().y;

            // Bounce at the top or the bottom of the arena.
            if (ball_y &lt;= ball.radius &amp;&amp; ball.velocity[1] &lt; 0.0)
                || (ball_y &gt;= ARENA_HEIGHT - ball.radius &amp;&amp; ball.velocity[1] &gt; 0.0)
            {
                ball.velocity[1] = -ball.velocity[1];
            }

            // Bounce at the paddles.
            for (paddle, paddle_transform) in (&amp;paddles, &amp;transforms).join() {
                let paddle_x = paddle_transform.translation().x - (paddle.width * 0.5);
                let paddle_y = paddle_transform.translation().y - (paddle.height * 0.5);

                // To determine whether the ball has collided with a paddle, we create a larger
                // rectangle around the current one, by subtracting the ball radius from the
                // lowest coordinates, and adding the ball radius to the highest ones. The ball
                // is then within the paddle if its center is within the larger wrapper
                // rectangle.
                if point_in_rect(
                    ball_x,
                    ball_y,
                    paddle_x - ball.radius,
                    paddle_y - ball.radius,
                    paddle_x + paddle.width + ball.radius,
                    paddle_y + paddle.height + ball.radius,
                ) {
                    if (paddle.side == Side::Left &amp;&amp; ball.velocity[0] &lt; 0.0)
                        || (paddle.side == Side::Right &amp;&amp; ball.velocity[0] &gt; 0.0)
                    {
                        ball.velocity[0] = -ball.velocity[0];
                    }
                }
            }
        }
    }
}

// A point is in a box when its coordinates are smaller or equal than the top
// right and larger or equal than the bottom left.
fn point_in_rect(x: f32, y: f32, left: f32, bottom: f32, right: f32, top: f32) -&gt; bool {
    x &gt;= left &amp;&amp; x &lt;= right &amp;&amp; y &gt;= bottom &amp;&amp; y &lt;= top
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>The following image illustrates how collisions with paddles are checked.</p>
<p><img src="pong-tutorial/../images/pong_tutorial/pong_paddle_collision.png" alt="Collision explanotary drawing" /></p>
<p>Also, don't forget to add <code>mod move_balls</code> and <code>mod bounce</code> in <code>systems/mod.rs</code>
as well as adding our new systems to the game data:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::core::transform::TransformBundle;
</span><span class="boring">use amethyst::window::DisplayConfig;
</span><span class="boring">use amethyst::input::StringBindings;
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">mod systems {
</span><span class="boring">use amethyst;
</span><span class="boring">use amethyst::core::ecs::{System, SystemData, World};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct PaddleSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct MoveBallsSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MoveBallsSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct BounceSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for BounceSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">}
</span><span class="boring">let input_bundle = amethyst::input::InputBundle::&lt;StringBindings&gt;::new();
</span>let game_data = GameDataBuilder::default()
<span class="boring">   .with_bundle(TransformBundle::new())?
</span><span class="boring">   .with_bundle(input_bundle)?
</span><span class="boring">   .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;])
</span>    // ...other systems...
    .with(systems::MoveBallsSystem, &quot;ball_system&quot;, &amp;[])
    .with(
        systems::BounceSystem,
        &quot;collision_system&quot;,
        &amp;[&quot;paddle_system&quot;, &quot;ball_system&quot;],
    );
<span class="boring">let assets_dir = &quot;/&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>You should now have a ball moving and bouncing off paddles and off the top
and bottom of the screen. However, you will quickly notice that if the ball
goes out of the screen on the right or the left, it never comes back
and the game is over. You might not even see that at all, as the ball might be already
outside of the screen when the window comes up. You might have to dramatically reduce
<code>BALL_VELOCITY_X</code> in order to see that in action. This obviously isn't a good solution for an actual game.
To fix that problem and better see what's happening we have to spawn the ball with a slight delay.</p>
<h2><a class="header" href="#spawning-ball-with-a-delay" id="spawning-ball-with-a-delay">Spawning ball with a delay</a></h2>
<p>The ball now spawns and moves off screen instantly when the game starts. This might be disorienting,
as you might be thrown into the game and lose your first point before you had the time to notice.
We also have to give some time for the operating system and the renderer to initialize the window
before the game starts. Usually, you would have a separate state with a game menu, so this isn't an issue.
Our pong game throws you right into the action, so we have to fix that problem.</p>
<p>Let's delay the first time the ball spawns. This is also a good opportunity to use our game state
struct to actually hold some data.</p>
<p>First, let's add a new method to our state: <code>update</code>.
Let's add that <code>update</code> method just below <code>on_start</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
    Trans::None
}
<span class="boring">}
</span></code></pre>
<p>That method allows you to transition out of state using its return value.
Here, we do not want to change any state, so we return <code>Trans::None</code>.</p>
<p>Now we have to move paddle creation to that method and add some delay to it. Our <code>update</code> runs every frame,
so in order to do something only once after a given time, we have to use our local state.
Additionally, notice that <code>initialise_paddles</code> requires us to provide the <code>sprite_sheet_handle</code>, but it was created
as a local variable inside <code>on_start</code>. For that reason, we have to make it a part of the state too.</p>
<p>Let's add some fields to our <code>Pong</code> struct:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst; use amethyst::renderer::SpriteSheet;
</span><span class="boring">use amethyst::assets::Handle;
</span>#[derive(Default)]
pub struct Pong {
    ball_spawn_timer: Option&lt;f32&gt;,
    sprite_sheet_handle: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
}
</code></pre>
<p>Our timer is represented by <code>Option&lt;f32&gt;</code>, which will count down to zero when available, and be replaced with <code>None</code> after
the time has passed. Our sprite sheet handle is also inside <code>Option</code> because we can't create it inside <code>Pong</code> constructor.
It will be created inside the <code>on_start</code> method instead.</p>
<p>We've also added <code>#[derive(Default)]</code>, which will automatically implement <code>Default</code> trait for us, which allows to create
default empty state. Now let's use that inside our <code>Application</code> creation code in <code>main.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)] struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">  let game_data = GameDataBuilder::default();
</span><span class="boring">  let assets_dir = &quot;/&quot;;
</span><span class="boring">  let world = World::new();
</span>let mut game = Application::new(assets_dir, Pong::default(), game_data)?;
<span class="boring">  Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Now let's finish our timer and ball spawning code. We have to do two things:</p>
<ul>
<li>First, we have to initialize our state and remove <code>initialise_ball</code> from <code>on_start</code>,</li>
<li>then we have to <code>initialise_ball</code> once after the time has passed inside <code>update</code>:</li>
</ul>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{assets::Handle, renderer::SpriteSheet};
</span><span class="boring">use amethyst::prelude::*;
</span>use amethyst::core::timing::Time;

<span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">struct Ball;
</span><span class="boring">impl amethyst::ecs::Component for Ball {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">#[derive(Default)] pub struct Pong {
</span><span class="boring">    ball_spawn_timer: Option&lt;f32&gt;,
</span><span class="boring">    sprite_sheet_handle: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = data.world;

        // Wait one second before spawning the ball.
        self.ball_spawn_timer.replace(1.0);

        // Load the spritesheet necessary to render the graphics.
        // `spritesheet` is the layout of the sprites on the image;
        // `texture` is the pixel data.
        self.sprite_sheet_handle.replace(load_sprite_sheet(world));
        initialise_paddles(world, self.sprite_sheet_handle.clone().unwrap());
        initialise_camera(world);
    }

    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        if let Some(mut timer) = self.ball_spawn_timer.take() {
            // If the timer isn't expired yet, subtract the time that passed since the last update.
            {
                let time = data.world.fetch::&lt;Time&gt;();
                timer -= time.delta_seconds();
            }
            if timer &lt;= 0.0 {
                // When timer expire, spawn the ball
                initialise_ball(data.world, self.sprite_sheet_handle.clone().unwrap());
            } else {
                // If timer is not expired yet, put it back onto the state.
                self.ball_spawn_timer.replace(timer);
            }
        }
        Trans::None
    }
}
</code></pre>
<p>Now our ball will only show up after a set delay, giving us some breathing room after startup.
This will give us a better opportunity to see what happens to the ball immediately when it spawns.</p>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>In this chapter, we finally added a ball to our game. As always, the full code
is available under the <code>pong_tutorial_04</code> example in the Amethyst repository.
In the next chapter, we'll add a system checking when a player loses the game,
and add a scoring system!</p>
<h1><a class="header" href="#winning-rounds-and-keeping-score" id="winning-rounds-and-keeping-score">Winning Rounds and Keeping Score</a></h1>
<p>Our last chapter ended on a bit of a cliffhanger. What happens when our ball
reaches the left or right edge of the screen? It just keeps going! 😦</p>
<p>In this chapter, we'll fix that by putting the ball back into play after it
leaves either side of the arena. We'll also add a scoreboard and keep track of
who's winning and losing.</p>
<h2><a class="header" href="#winning-and-losing-rounds" id="winning-and-losing-rounds">Winning and Losing Rounds</a></h2>
<p>So let's fix the big current issue; having a game that only works for one
round isn't very fun. We'll add a new system that will check if the ball has
reached either edge of the arena and reset its position and velocity. We'll also
make a note of who got the point for the round.</p>
<p>First, we'll add a new module to <code>systems/mod.rs</code></p>
<pre><code class="language-rust ignore">pub use self::winner::WinnerSystem;

mod winner;
</code></pre>
<p>Then, we'll create <code>systems/winner.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">        pub radius: f32,
</span><span class="boring">        pub velocity: [f32; 2],
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">        type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_WIDTH: f32 = 100.0;
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::transform::Transform,
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{Join, System, SystemData, World, WriteStorage},
};

use crate::pong::{Ball, ARENA_WIDTH, ARENA_HEIGHT};

#[derive(SystemDesc)]
pub struct WinnerSystem;

impl&lt;'s&gt; System&lt;'s&gt; for WinnerSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
    );

    fn run(&amp;mut self, (mut balls, mut locals): Self::SystemData) {
        for (ball, transform) in (&amp;mut balls, &amp;mut locals).join() {
            let ball_x = transform.translation().x;

            let did_hit = if ball_x &lt;= ball.radius {
                // Right player scored on the left side.
                println!(&quot;Player 2 Scores!&quot;);
                true
            } else if ball_x &gt;= ARENA_WIDTH - ball.radius {
                // Left player scored on the right side.
                println!(&quot;Player 1 Scores!&quot;);
                true
            } else {
                false
            };

            if did_hit {
                ball.velocity[0] = -ball.velocity[0]; // Reverse Direction
                transform.set_translation_x(ARENA_WIDTH / 2.0); // Reset Position
                transform.set_translation_y(ARENA_HEIGHT / 2.0); // Reset Position
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Here, we're creating a new system, joining on all <code>Entities</code> that have a <code>Ball</code>
and a <code>Transform</code> component, and then checking each ball to see if it has
reached either the left or right boundary of the arena. If so, we reverse
its direction and put it back in the middle of the screen.</p>
<p>Now, we just need to add our new system to <code>main.rs</code>, and we should be able to
keep playing after someone scores and log who got the point.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">   core::transform::TransformBundle,
</span><span class="boring">   ecs::{World, WorldExt},
</span><span class="boring">   prelude::*,
</span><span class="boring">   input::StringBindings,
</span><span class="boring">   window::DisplayConfig,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">mod systems {
</span><span class="boring">    use amethyst;
</span><span class="boring">    use amethyst::core::SystemDesc;
</span><span class="boring">    use amethyst::core::ecs::{System, SystemData, World};
</span><span class="boring">    use amethyst::derive::SystemDesc;
</span><span class="boring">
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct PaddleSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct MoveBallsSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MoveBallsSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct BounceSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for BounceSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct WinnerSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for WinnerSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">let input_bundle = amethyst::input::InputBundle::&lt;StringBindings&gt;::new();
</span><span class="boring">
</span>let game_data = GameDataBuilder::default()
<span class="boring">   .with_bundle(TransformBundle::new())?
</span><span class="boring">   .with_bundle(input_bundle)?
</span><span class="boring">   .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;])
</span><span class="boring">   .with(systems::MoveBallsSystem, &quot;ball_system&quot;, &amp;[])
</span><span class="boring">   .with(
</span><span class="boring">       systems::BounceSystem,
</span><span class="boring">       &quot;collision_system&quot;,
</span><span class="boring">       &amp;[&quot;paddle_system&quot;, &quot;ball_system&quot;],
</span><span class="boring">   )
</span>    .with(systems::WinnerSystem, &quot;winner_system&quot;, &amp;[&quot;ball_system&quot;]);
<span class="boring">
</span><span class="boring">let assets_dir = &quot;/&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#adding-a-scoreboard" id="adding-a-scoreboard">Adding a Scoreboard</a></h2>
<p>We have a pretty functional Pong game now! At this point, the least fun thing
about the game is just that players have to keep track of the score themselves.
Our game should be able to do that for us.</p>
<p>In this section, we'll set up UI rendering for our game and create a scoreboard
to display our players' scores.</p>
<p>First, let's add the UI rendering in <code>main.rs</code>. Add the following imports:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::ui::{RenderUi, UiBundle};
</code></pre>
<p>Then, add a <code>RenderUi</code> plugin to your <code>RenderBundle</code> like so:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{
</span><span class="boring">        types::DefaultBackend,
</span><span class="boring">        RenderingBundle,
</span><span class="boring">    },
</span><span class="boring">    ui::RenderUi,
</span><span class="boring">};
</span><span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt;{
</span><span class="boring">let game_data = GameDataBuilder::default()
</span>    .with_bundle(RenderingBundle::&lt;DefaultBackend&gt;::new()
        // ...
            .with_plugin(RenderUi::default()),
    )?;
<span class="boring">Ok(()) }
</span></code></pre>
<p>Finally, add the <code>UiBundle</code> after the <code>InputBundle</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    input::StringBindings,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">use amethyst::ui::UiBundle;
</span><span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt;{
</span><span class="boring">let display_config_path = &quot;&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">let game_data = GameDataBuilder::default()
</span>.with_bundle(UiBundle::&lt;StringBindings&gt;::new())?
<span class="boring">;
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>We're adding a <code>RenderUi</code> to our <code>RenderBundle</code>, and we're also adding the
<code>UiBundle</code> to our game data. This allows us to start
rendering UI visuals to our game in addition to the existing background and
sprites.</p>
<blockquote>
<p><strong>Note:</strong> We're using a <code>UiBundle</code> with type <code>StringBindings</code> here because the
<code>UiBundle</code> needs to know what types our <code>InputHandler</code> is using to map <code>actions</code>
and <code>axes</code>. So just know that your <code>UiBundle</code> type should match your
<code>InputHandler</code> type. You can read more about those here: <a href="https://docs.amethyst.rs/stable/amethyst_ui/struct.UiBundle.html">UiBundle</a>,
<a href="https://docs.amethyst.rs/stable/amethyst_input/struct.InputHandler.html">InputHandler</a>.</p>
</blockquote>
<p>Now we have everything set up so we can start rendering a scoreboard in our
game. We'll start by creating some structures in <code>pong.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    // --snip--
    ecs::{Component, DenseVecStorage, Entity},
};

/// ScoreBoard contains the actual score data
#[derive(Default)]
pub struct ScoreBoard {
    pub score_left: i32,
    pub score_right: i32,
}

/// ScoreText contains the ui text components that display the score
pub struct ScoreText {
    pub p1_score: Entity,
    pub p2_score: Entity,
}
</code></pre>
<blockquote>
<p>Don't glimpse over the <code>#[derive(Default)]</code> annotation for the <code>ScoreBoard</code> struct!</p>
</blockquote>
<p><code>ScoreBoard</code> is just a container that will allow us to keep track of each
player's score. We'll use this in another module later in this chapter, so we've
gone ahead and marked it as public (same with <code>ScoreText</code>). <code>ScoreText</code> is also
a container, but this one holds handles to the UI <code>Entity</code>s that will be
rendered to the screen. We'll create those next:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
<span class="boring">    assets::{AssetStorage, Loader},
</span><span class="boring">    ecs::Entity,
</span><span class="boring">    prelude::*,
</span>    // ...
    ui::{Anchor, LineMode, TtfFormat, UiText, UiTransform},
};

<span class="boring">pub struct Pong;
</span><span class="boring">
</span>impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
<span class="boring">      let world = data.world;
</span>        // --snip--

        initialise_scoreboard(world);
    }
}
// ...

/// Initialises a ui scoreboard
fn initialise_scoreboard(world: &amp;mut World) {
    let font = world.read_resource::&lt;Loader&gt;().load(
        &quot;font/square.ttf&quot;,
        TtfFormat,
        (),
        &amp;world.read_resource(),
    );
    let p1_transform = UiTransform::new(
        &quot;P1&quot;.to_string(), Anchor::TopMiddle, Anchor::TopMiddle,
        -50., -50., 1., 200., 50.,
    );
    let p2_transform = UiTransform::new(
        &quot;P2&quot;.to_string(), Anchor::TopMiddle, Anchor::TopMiddle,
        50., -50., 1., 200., 50.,
    );

    let p1_score = world
        .create_entity()
        .with(p1_transform)
        .with(UiText::new(
            font.clone(),
            &quot;0&quot;.to_string(),
            [1., 1., 1., 1.],
            50.,
            LineMode::Single,
            Anchor::Middle,
        ))
        .build();

    let p2_score = world
        .create_entity()
        .with(p2_transform)
        .with(UiText::new(
            font,
            &quot;0&quot;.to_string(),
            [1., 1., 1., 1.],
            50.,
            LineMode::Single,
            Anchor::Middle,
        ))
        .build();

<span class="boring">pub struct ScoreText {pub p1_score: Entity,pub p2_score: Entity,}
</span>    world.insert(ScoreText { p1_score, p2_score });
}
</code></pre>
<p>Here, we add some UI imports and create a new <code>initialise_scoreboard</code> function,
which we'll call in the <code>on_start</code> method of the <code>Pong</code> game state.</p>
<p>Inside <code>initialise_scoreboard</code>, we're first going to load up a font which we've
saved to <code>assets/font/square.ttf</code> (<a href="https://github.com/amethyst/amethyst/raw/master/examples/pong_tutorial_05/assets/font/square.ttf">download</a>). We pull
in the <code>TtfFormat</code> to match this font type, load the font as a resource in the
world, and then save the handle to a <code>font</code> variable (which we'll use to create
our <code>UiText</code> components).</p>
<p>Next, we create a transform for each of our two scores by giving them a unique
id (<code>P1</code> and <code>P2</code>), a UI <code>Anchor</code> at the top middle of our window, and then
adjust their global <code>x</code>, <code>y</code>, and <code>z</code> coordinates, <code>width</code>, <code>height</code>, and
<code>tab-order</code>.</p>
<p>After creating the <code>font</code> and <code>transform</code>s, we'll create an <code>Entity</code> in the
world for each of our players' scores, with their <code>transform</code> and a <code>UiText</code>
component (with a <code>font</code> handle, initial <code>text</code>, <code>color</code>, and <code>font_size</code>).</p>
<p>Finally, we initialize a <code>ScoreText</code> structure containing each of our UI
<code>Entity</code>s and add it as a resource to the world so we can access it from our
<code>System</code>s later.</p>
<p>If we've done everything right so far, we should see <code>0</code> <code>0</code> at the top of our
game window. You'll notice that the scores don't update yet when the ball makes
it to either side, so we'll add that next!</p>
<h2><a class="header" href="#updating-the-scoreboard" id="updating-the-scoreboard">Updating the Scoreboard</a></h2>
<p>All that's left for us to do now is update the UI whenever a player scores a
point. You'll see just how easy this is with our <code>ECS</code> design. All we have to do
is modify our <code>WinnerSystem</code> to access the players' scores and update them
accordingly:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">        pub radius: f32,
</span><span class="boring">        pub velocity: [f32; 2],
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">        type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct ScoreBoard {
</span><span class="boring">        pub score_left: i32,
</span><span class="boring">        pub score_right: i32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct ScoreText {
</span><span class="boring">        pub p1_score: Entity,
</span><span class="boring">        pub p2_score: Entity,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_WIDTH: f32 = 100.0;
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
<span class="boring">    core::transform::Transform,
</span><span class="boring">    core::SystemDesc,
</span><span class="boring">    derive::SystemDesc,
</span>    // --snip--
    ecs::{Join, ReadExpect, System, SystemData, World, Write, WriteStorage},
    ui::UiText,
};

use crate::pong::{Ball, ScoreBoard, ScoreText, ARENA_WIDTH, ARENA_HEIGHT};

#[derive(SystemDesc)]
pub struct WinnerSystem;

impl&lt;'s&gt; System&lt;'s&gt; for WinnerSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
        WriteStorage&lt;'s, UiText&gt;,
        Write&lt;'s, ScoreBoard&gt;,
        ReadExpect&lt;'s, ScoreText&gt;,
    );

    fn run(&amp;mut self, (
        mut balls,
        mut locals,
        mut ui_text,
        mut scores,
        score_text
    ): Self::SystemData) {
        for (ball, transform) in (&amp;mut balls, &amp;mut locals).join() {
<span class="boring">            let ball_x = transform.translation().x;
</span>            // --snip--

            let did_hit = if ball_x &lt;= ball.radius {
                // Right player scored on the left side.
                // We top the score at 999 to avoid text overlap.
                scores.score_right = (scores.score_right + 1)
                    .min(999);

                if let Some(text) = ui_text.get_mut(score_text.p2_score) {
                    text.text = scores.score_right.to_string();
                }
                true
            } else if ball_x &gt;= ARENA_WIDTH - ball.radius {
                // Left player scored on the right side.
                // We top the score at 999 to avoid text overlap.
                scores.score_left = (scores.score_left + 1)
                    .min(999);
                if let Some(text) = ui_text.get_mut(score_text.p1_score) {
                    text.text = scores.score_left.to_string();
                }
                true
            } else {
                false
            };

            if did_hit {
<span class="boring">                ball.velocity[0] = -ball.velocity[0]; // Reverse Direction
</span><span class="boring">                transform.set_translation_x(ARENA_WIDTH / 2.0); // Reset Position
</span><span class="boring">                transform.set_translation_y(ARENA_HEIGHT / 2.0); // Reset Position
</span>
                // --snip--

                // Print the scoreboard.
                println!(
                    &quot;Score: | {:^3} | {:^3} |&quot;,
                    scores.score_left, scores.score_right
                );
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>We've added a fair few changes here, so let's go through them. First, we want to
be able to read and write our scores, so we add the <code>UiText</code> storage, which
holds all <code>UiText</code> components, to our <code>SystemData</code>. We'll want to select our
players' scores from that, so we also add the <code>ScoreText</code> structure which holds
handles to the <code>UiText</code> components that we want. Finally, we add the
<code>ScoreBoard</code> resource so we can keep track of the actual score data.</p>
<p>We're using <code>Write</code> here to pull in the <code>ScoreBoard</code> instead of with
<code>WriteStorage</code> because we want mutable access to <code>ScoreBoard</code>, which is not a
collection of components but rather a single resource item. This item is
strictly required in all cases, but if we wanted it to be optional we could
use <code>Option&lt;Write&lt;'s, ScoreBoard&gt;&gt;</code> instead.</p>
<p>We also use <code>ReadExpect</code> to access the <code>ScoreText</code> resource immutably. Again,
<code>ScoreText</code> is a single resource item rather than a collection of components.
With <code>ReadExpect</code>, we are asserting that <code>ScoreText</code> must already exist and will
panic if it does not. We do this instead of just using <code>Read</code> because we are
manually adding the <code>ScoreText</code> resource to the game in
<code>pong.rs &gt; initialise_scoreboard</code> instead of having the system create this
resource for us automatically.</p>
<p>Inside our <code>run</code> method (after updating the signature to match our <code>SystemData</code>
changes), we replace the <code>println!</code> statements with code that will update our
<code>UiText</code> components. We first update the score stored in <code>score_board</code> by
adding 1 to it and clamping it to not exceed <code>999</code> (mostly because we don't want
our scores to overlap each other in the window). Then, we use the <code>UiText</code>
<code>Entity</code> handle that we stored in our <code>ScoreText</code> resource to get a mutable
reference to our <code>UiText</code> component. Lastly, we set the text of the <code>UiText</code>
component to the player's score, after converting it to a string.</p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>And that's it! Our game now keeps track of the score for us and displays it at
the top of our window.</p>
<p><img src="pong-tutorial/../images/pong_tutorial/pong_05.png" alt="Pong Game with Scores" /></p>
<p>Now don't go just yet, because, in the next chapter, we'll make our Pong game
even better by adding sound effects and even some music!</p>
<h1><a class="header" href="#adding-audio" id="adding-audio">Adding audio</a></h1>
<p>Now that we have a functional pong game, let's spice things up by adding some audio. In this chapter, we'll add sound effects and background music.</p>
<h2><a class="header" href="#adding-the-sounds-resource" id="adding-the-sounds-resource">Adding the Sounds Resource</a></h2>
<p>Let's get started by creating an <code>audio</code> subdirectory under <code>assets</code>. Then download <a href="pong-tutorial/./audio/bounce.ogg">the bounce sound</a> and <a href="pong-tutorial/./audio/score.ogg">the score sound</a> and put them in <code>assets/audio</code>.</p>
<p>Next, we'll create a Resource to store our sound effects in. In <code>main.rs</code>, add:</p>
<pre><code class="language-rust ignore">mod audio;
</code></pre>
<p>Create a file called <code>audio.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    assets::Loader,
    audio::{OggFormat, SourceHandle},
    ecs::{World, WorldExt},
};

const BOUNCE_SOUND: &amp;str = &quot;audio/bounce.ogg&quot;;
const SCORE_SOUND: &amp;str = &quot;audio/score.ogg&quot;;

pub struct Sounds {
    pub score_sfx: SourceHandle,
    pub bounce_sfx: SourceHandle,
}

/// Loads an ogg audio track.
fn load_audio_track(loader: &amp;Loader, world: &amp;World, file: &amp;str) -&gt; SourceHandle {
    loader.load(file, OggFormat, (), &amp;world.read_resource())
}

/// Initialise audio in the world. This will eventually include
/// the background tracks as well as the sound effects, but for now
/// we'll just work on sound effects.
pub fn initialise_audio(world: &amp;mut World) {
    let sound_effects = {
        let loader = world.read_resource::&lt;Loader&gt;();

        let sound = Sounds {
            bounce_sfx: load_audio_track(&amp;loader, &amp;world, BOUNCE_SOUND),
            score_sfx: load_audio_track(&amp;loader, &amp;world, SCORE_SOUND),
        };

        sound
    };

    // Add sound effects to the world. We have to do this in another scope because
    // world won't let us insert new resources as long as `Loader` is borrowed.
    world.insert(sound_effects);
}
</code></pre>
<p>Then, we'll need to add the Sounds Resource to our World. Update <code>pong.rs</code>:</p>
<pre><code class="language-rust ignore">use crate::audio::initialise_audio;

impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // --snip--

        initialise_audio(world);
    }
}
</code></pre>
<p>Finally, we'll need our game to include the Audio Bundle. In <code>main.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::GameDataBuilder;
</span>use amethyst::audio::AudioBundle;

fn main() -&gt; amethyst::Result&lt;()&gt; {
    // --snip--

    let game_data = GameDataBuilder::default()
        // ... other bundles
        .with_bundle(AudioBundle::default())?
        // ... systems
    ;

    // --snip--
<span class="boring">Ok(())
</span>}
</code></pre>
<h2><a class="header" href="#playing-the-bounce-sound" id="playing-the-bounce-sound">Playing the bounce sound</a></h2>
<p>Let's start by creating a function to play the bounce sound. In <code>audio.rs</code>, add:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    assets::AssetStorage,
    audio::{output::Output, Source, SourceHandle},
};
<span class="boring">
</span><span class="boring">pub struct Sounds {
</span><span class="boring">    pub score_sfx: SourceHandle,
</span><span class="boring">    pub bounce_sfx: SourceHandle,
</span><span class="boring">}
</span><span class="boring">
</span>pub fn play_bounce_sound(sounds: &amp;Sounds, storage: &amp;AssetStorage&lt;Source&gt;, output: Option&lt;&amp;Output&gt;) {
    if let Some(ref output) = output.as_ref() {
        if let Some(sound) = storage.get(&amp;sounds.bounce_sfx) {
            output.play_once(sound, 1.0);
        }
    }
}
</code></pre>
<p>Then, we'll update the Bounce System to play the sound whenever the ball bounces. Update <code>systems/bounce.rs</code>:</p>
<pre><code class="language-rust ignore">
use amethyst::{
    assets::AssetStorage,
    audio::{output::Output, Source},
    ecs::{Read, ReadExpect},
};

use crate::audio::{play_bounce_sound, Sounds};

impl&lt;'s&gt; System&lt;'s&gt; for BounceSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        ReadStorage&lt;'s, Paddle&gt;,
        ReadStorage&lt;'s, Transform&gt;,
        Read&lt;'s, AssetStorage&lt;Source&gt;&gt;,
        ReadExpect&lt;'s, Sounds&gt;,
        Option&lt;Read&lt;'s, Output&gt;&gt;,
    );

    fn run(
        &amp;mut self,
        (mut balls, paddles, transforms, storage, sounds, audio_output): Self::SystemData,
    ) {
        for (ball, transform) in (&amp;mut balls, &amp;transforms).join() {
            // --snip--

            // Bounce at the top or the bottom of the arena.
            if (ball_y &lt;= ball.radius &amp;&amp; ball.velocity[1] &lt; 0.0)
                || (ball_y &gt;= ARENA_HEIGHT - ball.radius &amp;&amp; ball.velocity[1] &gt; 0.0)
            {
                ball.velocity[1] = -ball.velocity[1];
                play_bounce_sound(&amp;*sounds, &amp;storage, audio_output.as_deref());
            }

            // Bounce at the paddles.
            for (paddle, paddle_transform) in (&amp;paddles, &amp;transforms).join() {
                // --snip--

                if point_in_rect(
                    // --snip--
                ) {
                    if (paddle.side == Side::Left &amp;&amp; ball.velocity[0] &lt; 0.0)
                        || (paddle.side == Side::Right &amp;&amp; ball.velocity[0] &gt; 0.0)
                    {
                        ball.velocity[0] = -ball.velocity[0];
                        play_bounce_sound(&amp;*sounds, &amp;storage, audio_output.as_deref());
                    }
                }
            }
        }
    }
}
</code></pre>
<p>Now try running your game (<code>cargo run</code>). Don't forget to turn up your volume!</p>
<h2><a class="header" href="#playing-the-score-sound" id="playing-the-score-sound">Playing the score sound</a></h2>
<p>Just as we did for the bounce sound, let's create a function to play the score sound. Update <code>audio.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    audio::{output::Output, Source, SourceHandle},
</span><span class="boring">    assets::AssetStorage,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct Sounds {
</span><span class="boring">    pub score_sfx: SourceHandle,
</span><span class="boring">    pub bounce_sfx: SourceHandle,
</span><span class="boring">}
</span><span class="boring">
</span>pub fn play_score_sound(sounds: &amp;Sounds, storage: &amp;AssetStorage&lt;Source&gt;, output: Option&lt;&amp;Output&gt;) {
    if let Some(ref output) = output.as_ref() {
        if let Some(sound) = storage.get(&amp;sounds.score_sfx) {
            output.play_once(sound, 1.0);
        }
    }
}
</code></pre>
<p>Then, we'll update our Winner System to play the score sound whenever a player scores. Update <code>systems/winner.rs</code>:</p>
<pre><code class="language-rust ignore">use amethyst::{
    assets::AssetStorage,
    audio::{output::Output, Source},
    ecs::Read,
};
use crate::audio::{play_score_sound, Sounds};

impl&lt;'s&gt; System&lt;'s&gt; for WinnerSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
        WriteStorage&lt;'s, UiText&gt;,
        Write&lt;'s, ScoreBoard&gt;,
        ReadExpect&lt;'s, ScoreText&gt;,
        Read&lt;'s, AssetStorage&lt;Source&gt;&gt;,
        ReadExpect&lt;'s, Sounds&gt;,
        Option&lt;Read&lt;'s, Output&gt;&gt;,
    );


    fn run(&amp;mut self, (
        mut balls,
        mut locals,
        mut ui_text,
        mut scores,
        score_text,
        storage,
        sounds,
        audio_output,
    ): Self::SystemData)  {
        for (ball, transform) in (&amp;mut balls, &amp;mut locals).join() {
            // --snip--

            if did_hit {
                ball.velocity[0] = -ball.velocity[0]; // Reverse Direction
                transform.set_translation_x(ARENA_WIDTH / 2.0); // Reset Position
                transform.set_translation_y(ARENA_HEIGHT / 2.0); // Reset Position

                play_score_sound(&amp;*sounds, &amp;storage, audio_output.as_deref());

                // Print the scoreboard.
                println!(
                    &quot;Score: | {:^3} | {:^3} |&quot;,
                    scores.score_left, scores.score_right
                );
            }
        }
    }
}
</code></pre>
<p>Now try running your game. Yay, we successfully added sound effects to our game! 🎉</p>
<p>Next, let's take our game to the next level by adding some background music.</p>
<h2><a class="header" href="#adding-background-music" id="adding-background-music">Adding background music</a></h2>
<p>Let's start by downloading <a href="pong-tutorial/./audio/Computer_Music_All-Stars_-_Albatross_v2.ogg">Albatross</a> and <a href="pong-tutorial/./audio/Computer_Music_All-Stars_-_Wheres_My_Jetpack.ogg">Where's My Jetpack?</a> Put these files in the <code>assets/audio</code> directory.</p>
<p>In <code>audio.rs</code>, add the paths to the music tracks below the paths to the sound effects:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">const BOUNCE_SOUND: &amp;str = &quot;audio/bounce.ogg&quot;;
const SCORE_SOUND: &amp;str = &quot;audio/score.ogg&quot;;

const MUSIC_TRACKS: &amp;[&amp;str] = &amp;[
    &quot;audio/Computer_Music_All-Stars_-_Wheres_My_Jetpack.ogg&quot;,
    &quot;audio/Computer_Music_All-Stars_-_Albatross_v2.ogg&quot;,
];
</code></pre>
<p>Then, create a Music Resource:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use std::{iter::Cycle, vec::IntoIter};
<span class="boring">
</span><span class="boring">use amethyst::audio::SourceHandle;
</span>
pub struct Music {
    pub music: Cycle&lt;IntoIter&lt;SourceHandle&gt;&gt;,
}
</code></pre>
<p>Since we only have two music tracks, we use a <code>Cycle</code> to infinitely alternate between the two.</p>
<p>Next, we need to add the Music Resource to our World. Update <code>initialise_audio</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use std::{iter::Cycle, vec::IntoIter};
</span><span class="boring">
</span>use amethyst::{
    audio::{AudioSink, SourceHandle},
    assets::Loader,
    ecs::{World, WorldExt},
};
<span class="boring">
</span><span class="boring">const BOUNCE_SOUND: &amp;str = &quot;audio/bounce.ogg&quot;;
</span><span class="boring">const SCORE_SOUND: &amp;str = &quot;audio/score.ogg&quot;;
</span><span class="boring">
</span><span class="boring">const MUSIC_TRACKS: &amp;[&amp;str] = &amp;[
</span><span class="boring">    &quot;audio/Computer_Music_All-Stars_-_Wheres_My_Jetpack.ogg&quot;,
</span><span class="boring">    &quot;audio/Computer_Music_All-Stars_-_Albatross_v2.ogg&quot;,
</span><span class="boring">];
</span><span class="boring">
</span><span class="boring">fn load_audio_track(loader: &amp;Loader, world: &amp;World, file: &amp;str) -&gt; SourceHandle {
</span><span class="boring">    unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Music {
</span><span class="boring">    pub music: Cycle&lt;IntoIter&lt;SourceHandle&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Sounds {
</span><span class="boring">    pub score_sfx: SourceHandle,
</span><span class="boring">    pub bounce_sfx: SourceHandle,
</span><span class="boring">}
</span>
pub fn initialise_audio(world: &amp;mut World) {
    let (sound_effects, music) = {
        let loader = world.read_resource::&lt;Loader&gt;();

        let mut sink = world.write_resource::&lt;AudioSink&gt;();
        sink.set_volume(0.25); // Music is a bit loud, reduce the volume.

        let music = MUSIC_TRACKS
            .iter()
            .map(|file| load_audio_track(&amp;loader, &amp;world, file))
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .into_iter()
            .cycle();
        let music = Music { music };

        let sound = Sounds {
            bounce_sfx: load_audio_track(&amp;loader, &amp;world, BOUNCE_SOUND),
            score_sfx: load_audio_track(&amp;loader, &amp;world, SCORE_SOUND),
        };

        (sound, music)
    };

    // Add sound effects and music to the world. We have to do this in another scope because
    // world won't let us insert new resources as long as `Loader` is borrowed.
    world.insert(sound_effects);
    world.insert(music);
}
</code></pre>
<p>Finally, let's add a DJ System to our game to play the music. In <code>main.rs</code>:</p>
<pre><code class="language-rust ignore">use amethyst::audio::DjSystemDesc;
use crate::audio::Music;

fn main() -&gt; amethyst::Result&lt;()&gt; {
    // --snip--

    let game_data = GameDataBuilder::default()
        // ... bundles
        .with_system_desc(
            DjSystemDesc::new(|music: &amp;mut Music| music.music.next()),
            &quot;dj_system&quot;,
            &amp;[],
        )
        // ... other systems
        ;

    // --snip--
<span class="boring">Ok(())
</span>}
</code></pre>
<p>Now run your game and enjoy the tunes!</p>
<h1><a class="header" href="#tutorial-completed" id="tutorial-completed">Tutorial completed!</a></h1>
<p>And... that's where the pong chapter ends. We hope you found it useful!</p>
<p>You can find the entire code with balls, score and music on the example pages available <a href="https://github.com/amethyst/amethyst/tree/master/examples/pong">here</a>.</p>
<p>Next up in this book we will explain how Amethyst does Math, Input, Assets and so on. Whenever you have a need for more learning-by-example materials just come back to this page for an overview of available resources.</p>
<h2><a class="header" href="#other-tutorials-or-examples" id="other-tutorials-or-examples">Other tutorials or examples</a></h2>
<h4><a class="header" href="#a-hrefhttpsgithubcomamethystamethyst-starter-2damethyst-quickstartera" id="a-hrefhttpsgithubcomamethystamethyst-starter-2damethyst-quickstartera"><a href="https://github.com/amethyst/amethyst-starter-2d">Amethyst Quickstarter</a></a></h4>
<p>Seed project for 2D games. This project template will get you from 0 to drawing something on the screen in no time.</p>
<h4><a class="header" href="#showcase-game-a-hrefhttpsgithubcomamethystevolievolia" id="showcase-game-a-hrefhttpsgithubcomamethystevolievolia">Showcase Game: <a href="https://github.com/amethyst/evoli">Evoli</a></a></h4>
<p>An ecosystem-simulation game, 3D</p>
<h4><a class="header" href="#showcase-game-a-hrefhttpsgithubcomamethystspace-menacespace-menacea" id="showcase-game-a-hrefhttpsgithubcomamethystspace-menacespace-menacea">Showcase Game: <a href="https://github.com/amethyst/space-menace/">Space Menace</a></a></h4>
<p>An action 2D platformer</p>
<h4><a class="header" href="#showcase-game-a-hrefhttpsgithubcomjaynussurvivalsurvivora" id="showcase-game-a-hrefhttpsgithubcomjaynussurvivalsurvivora">Showcase Game: <a href="https://github.com/jaynus/survival">Survivor</a></a></h4>
<p>(unannounced, 2D)</p>
<p>For more examples from the community you can check out this list of <a href="https://community.amethyst.rs/t/games-made-with-amethyst/134">Games made with Amethyst</a>.</p>
<h2><a class="header" href="#come-talk-to-us" id="come-talk-to-us">Come talk to us</a></h2>
<p>You can get additional help by leaving a post on <a href="https://community.amethyst.rs">our forum</a> or on our <a href="https://discord.gg/amethyst">Discord server</a>. We'd also love to hear your ideas for other tutorials we should consider adding to this book.</p>
<p>If you want to extend this tutorial (e.g., add a main menu, add pause/resume functionality, etc.), feel free to ping us on Discord or in a GitHub issue!</p>
<h1><a class="header" href="#math" id="math">Math</a></h1>
<p>Amethyst uses <a href="https://nalgebra.org/">nalgebra</a> under the hood as its math library and it is
re-exported for use under the <code>amethyst::core::math</code> namespace. As the
documentation for nalgebra is already very good, we will not go into detail
here about how to use it. Instead we will redirect you to the excellent
<a href="https://nalgebra.org/">nalgebra website</a> where you can find the documentation for nalgebra
along with excellent examples and quick references.</p>
<h1><a class="header" href="#input" id="input">Input</a></h1>
<p><strong>Input</strong> provides data on devices like a keyboard, a mouse and a controller. This data most importantly consists of buttons being pressed and buttons or devices being moved.</p>
<p>In games this data is used to activate certain events, for example:</p>
<ul>
<li>Pausing the game when the user presses escape.</li>
<li>Moving the player when the user moves the joystick of a controller.</li>
</ul>
<p>For these events to take place the game needs to check for any buttons that are pressed and take action accordingly.</p>
<p>This section explains how input works in Amethyst and how you can bind actions to user input.</p>
<h1><a class="header" href="#handling-input" id="handling-input">Handling Input</a></h1>
<p>Amethyst uses an <code>InputHandler</code> to handle user input.
You initialise this <code>InputHandler</code> by creating an <code>InputBundle</code> and adding it to the game data.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    prelude::*,
    input::{InputBundle, StringBindings},
};

<span class="boring">struct Example;
</span><span class="boring">impl SimpleState for Example {}
</span>fn main() -&gt; amethyst::Result&lt;()&gt; {
    // StringBindings is the default BindingTypes
    let input_bundle = InputBundle::&lt;StringBindings&gt;::new();

    let mut world = World::new();
    let game_data = GameDataBuilder::default()
    //..
    .with_bundle(input_bundle)?
    //..
<span class="boring">  ;
</span>
    Ok(())
}
</code></pre>
<p>To use the <code>InputHandler</code> inside a <code>System</code> you have to add it to the <code>SystemData</code>. With this you can check for events from input devices.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    prelude::*,
    input::{InputHandler, ControllerButton, VirtualKeyCode, StringBindings},
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{Read, System, SystemData, World},
};

#[derive(SystemDesc)]
struct ExampleSystem;

impl&lt;'s&gt; System&lt;'s&gt; for ExampleSystem {
    // The same BindingTypes from the InputBundle needs to be inside the InputHandler
    type SystemData = Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;;

    fn run(&amp;mut self, input: Self::SystemData) {
        // Gets mouse coordinates
        if let Some((x, y)) = input.mouse_position() {
            //..
        }
        
        // Gets all connected controllers
        let controllers = input.connected_controllers();
        for controller in controllers {
            // Checks if the A button is down on each connected controller
            let buttonA = input.controller_button_is_down(controller, ControllerButton::A);
            //..
        }

        // Checks if the A button is down on the keyboard
        let buttonA = input.key_is_down(VirtualKeyCode::A);
        //..
    }
}
</code></pre>
<p>You can find all the methods from <code>InputHandler</code> <a href="https://docs.amethyst.rs/stable/amethyst_input/struct.InputHandler.html#methods">here</a>.</p>
<p>Now you have to add the <code>System</code> to the game data, just like you would do with any other <code>System</code>. A <code>System</code> that uses an <code>InputHandler</code> needs <code>&quot;input_system&quot;</code> inside its dependencies.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{prelude::*, ecs::*, core::SystemDesc, derive::SystemDesc};
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">struct ExampleSystem; 
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for ExampleSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {}}
</span><span class="boring">
</span>let game_data = GameDataBuilder::default()
    //..
    .with(ExampleSystem, &quot;example_system&quot;, &amp;[&quot;input_system&quot;])
    //..
<span class="boring">  ;
</span></code></pre>
<h2><a class="header" href="#defining-key-bindings-in-a-file" id="defining-key-bindings-in-a-file">Defining Key Bindings in a File</a></h2>
<p>Instead of hard coding in all the key bindings, you can store all the bindings in a config file. A config file for key bindings with the RON format looks something like this:</p>
<pre><code class="language-ron ignore">(
    axes: {
        &quot;vertical&quot;: Emulated(pos: Key(W), neg: Key(S)),
        &quot;horizontal&quot;: Emulated(pos: Key(D), neg: Key(A)),
    },
    actions: {
        &quot;shoot&quot;: [[Key(Space)]],
    },
)
</code></pre>
<p>The axis values range from <code>-1.0</code> to <code>1.0</code>. For an <code>Emulated</code> axis controller such as keyboard buttons, the values are distinct:</p>
<ul>
<li><code>0.0</code> when neither, or both the <code>neg</code> or <code>pos</code> buttons are pressed.</li>
<li><code>-1.0</code> when the <code>neg</code> button is pressed.</li>
<li><code>1.0</code> when the <code>pos</code> button is pressed.</li>
</ul>
<p>Values between <code>0.0</code> and <code>1.0</code> are possible when using a controller such as a joystick. This can be enabled via the <code>&quot;sdl_controller&quot;</code> feature.</p>
<p>The action is a boolean, which is set to true when the buttons are pressed. The action binding is defined by a two-level array:</p>
<ul>
<li>The inner array specifies the buttons that must be pressed at the same time to send the action.</li>
<li>The outer array specifies different combinations of those buttons that send the action.</li>
</ul>
<p>The possible inputs you can specify for axes are listed <a href="https://docs.amethyst.rs/stable/amethyst_input/enum.Axis.html">here</a>. The possible inputs you can specify for actions are listed <a href="https://docs.amethyst.rs/stable/amethyst_input/enum.Button.html">here</a>.</p>
<p>To add these bindings to the <code>InputBundle</code> you simply need to call the <code>with_bindings_from_file</code> function on the <code>InputBundle</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{prelude::*, input::*, utils::*};
</span><span class="boring">fn main() -&gt; amethyst::Result::&lt;()&gt; {
</span>let root = application_root_dir()?;
let bindings_config = root.join(&quot;config&quot;).join(&quot;bindings.ron&quot;);

let input_bundle = InputBundle::&lt;StringBindings&gt;::new()
    .with_bindings_from_file(bindings_config)?;

//..
<span class="boring">Ok(()) }
</span></code></pre>
<p>And now you can get the <a href="https://docs.amethyst.rs/stable/amethyst_input/struct.InputHandler.html#method.axis_value">axis</a> and <a href="https://docs.amethyst.rs/stable/amethyst_input/struct.InputHandler.html#method.action_is_down">action</a> values from the <code>InputHandler</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    prelude::*,
    core::{Transform, SystemDesc},
    derive::SystemDesc,
    ecs::{Component, DenseVecStorage, Join, Read, ReadStorage, System, SystemData, World, WriteStorage},
    input::{InputHandler, StringBindings},
};

struct Player {
    id: usize,
}

impl Player {
    pub fn shoot(&amp;self) {
        println!(&quot;PEW! {}&quot;, self.id);
    }
}

impl Component for Player {
    type Storage = DenseVecStorage&lt;Self&gt;;
}

#[derive(SystemDesc)]
struct MovementSystem;

impl&lt;'s&gt; System&lt;'s&gt; for MovementSystem {
    type SystemData = (
        WriteStorage&lt;'s, Transform&gt;,
        ReadStorage&lt;'s, Player&gt;,
        Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;,
    );
    
    fn run(&amp;mut self, (mut transforms, players, input): Self::SystemData) {
        for (player, transform) in (&amp;players, &amp;mut transforms).join() {
            let horizontal = input.axis_value(&quot;horizontal&quot;).unwrap_or(0.0);
            let vertical = input.axis_value(&quot;vertical&quot;).unwrap_or(0.0);
            
            let shoot = input.action_is_down(&quot;shoot&quot;).unwrap_or(false);
            
            transform.move_up(horizontal);
            transform.move_right(vertical);
            
            if shoot {
                player.shoot();
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#how-to-define-custom-control-bindings" id="how-to-define-custom-control-bindings">How to Define Custom Control Bindings</a></h1>
<p>Instead of using <code>StringBindings</code> for an <code>InputBundle</code> you probably want to use a custom type in production, as <code>StringBindings</code> are mainly meant to be used for prototyping and not very efficient.</p>
<p>Using a custom type to handle input instead of using <code>String</code> has many advantages:</p>
<ul>
<li>A <code>String</code> uses quite a lot of memory compared to something like an enum.</li>
<li>Inputting a <code>String</code> when retrieving input data is error-prone if you mistype it or change the name.</li>
<li>A custom type can hold additional information.</li>
</ul>
<h2><a class="header" href="#defining-custom-input-bindingtypes" id="defining-custom-input-bindingtypes">Defining Custom Input <code>BindingTypes</code></a></h2>
<p>Defining a custom type for the <code>InputBundle</code> is done by implementing the <code>BindingTypes</code> trait. This trait contains two types, an <code>Axis</code> type and an <code>Action</code> type. These types are usually defined as enums.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span>use std::fmt::{self, Display};

use amethyst::input::{BindingTypes, Bindings};
use serde::{Serialize, Deserialize};

#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize)]
enum AxisBinding {
    Horizontal,
    Vertical,
}

#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize)]
enum ActionBinding {
    Shoot,
}

impl Display for AxisBinding {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{:?}&quot;, self)
    }
}

impl Display for ActionBinding {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{:?}&quot;, self)
    }
}

#[derive(Debug)]
struct MovementBindingTypes;

impl BindingTypes for MovementBindingTypes {
    type Axis = AxisBinding;
    type Action = ActionBinding;
}
</code></pre>
<p>The <code>Axis</code> and <code>Action</code> type both need to derive all the traits listed above, the first five are used by Amethyst and the last two are for reading and writing to files correctly. They also need to implement <code>Display</code> if you want to add a bindings config file.</p>
<p>For serializing and deserializing you need to add <a href="https://crates.io/crates/serde">serde</a> to the dependencies like this:</p>
<pre><code class="language-toml ignore">serde = { version = &quot;1&quot;, features = [&quot;derive&quot;] }
</code></pre>
<p>If you want to add additional information you can add it to the enum or change the <code>Axis</code> and <code>Action</code> types to a struct. For example:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize)]
enum AxisBinding {
    Horizontal(usize),
    Vertical(usize),
}

#[derive(Clone, Debug, Hash, PartialEq, Eq, Serialize, Deserialize)]
enum ActionBinding {
    Shoot(usize),
}

//..
</code></pre>
<p>We can now use this custom type in our <code>InputBundle</code> and create a RON config file for our bindings.</p>
<p>The config file might look something like this:</p>
<pre><code class="language-ron ignore">(
    axes: {
        Vertical(0): Emulated(pos: Key(W), neg: Key(S)),
        Horizontal(0): Emulated(pos: Key(D), neg: Key(A)),
        Vertical(1): Emulated(pos: Key(Up), neg: Key(Down)),
        Horizontal(1): Emulated(pos: Key(Right), neg: Key(Left)),
    },
    actions: {
        Shoot(0): [[Key(Space)]],
        Shoot(1): [[Key(Return)]],
    },
)
</code></pre>
<p>Here the number after the binding type could be the ID of the player, but you can supply any other data as long as it derives the right traits.</p>
<p>With the config file we can create an <code>InputBundle</code> like in the previous section.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::input::StringBindings as MovementBindingTypes;
</span>use amethyst::input::InputBundle;

<span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let input_config = &quot;input.ron&quot;;
</span><span class="boring">
</span>let input_bundle = 
    InputBundle::&lt;MovementBindingTypes&gt;::new()
        .with_bindings_from_file(input_config)?;
<span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>And add the <code>InputBundle</code> to the game data just like before.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::input::{InputBundle, StringBindings};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">let input_bundle = InputBundle::&lt;StringBindings&gt;::default();
</span><span class="boring">
</span>let mut world = World::new();
let game_data = GameDataBuilder::default()
    //..
    .with_bundle(input_bundle)?
    //..
<span class="boring">  ;
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#using-the-inputhandler-with-a-custom-bindingtypes" id="using-the-inputhandler-with-a-custom-bindingtypes">Using the <code>InputHandler</code> with a Custom <code>BindingTypes</code></a></h2>
<p>Now that we have added an <code>InputBundle</code> with a custom <code>BindingTypes</code>, we can use the <code>InputHandler</code> just like with <code>StringBindings</code>, but instead of using <code>String</code>s we use our custom enums.</p>
<pre><code class="language-rust edition2018 no_run noplaypen ignore"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    core::{Transform, SystemDesc},
    derive::SystemDesc,
    ecs::{Component, DenseVecStorage, Join, Read, ReadStorage, System, SystemData, World, WriteStorage},
    input::{AxisBinding, InputHandler},
};

struct Player {
    id: usize,
}

impl Player {
    pub fn shoot(&amp;self) {
        println!(&quot;PEW! {}&quot;, self.id);
    }
}

impl Component for Player {
    type Storage = DenseVecStorage&lt;Self&gt;;
}

#[derive(SystemDesc)]
struct MovementSystem;

impl&lt;'s&gt; System&lt;'s&gt; for MovementSystem {
    type SystemData = (
        WriteStorage&lt;'s, Transform&gt;,
        ReadStorage&lt;'s, Player&gt;,
        Read&lt;'s, InputHandler&lt;MovementBindingTypes&gt;&gt;,
    );

    fn run(&amp;mut self, (mut transform, player, input): Self::SystemData) {
        for (player, transform) in (&amp;player, &amp;mut transform).join() {
            let horizontal = input
                .axis_value(&amp;AxisBinding::Horizontal(player.id))
                .unwrap_or(0.0);
            let vertical = input
                .axis_value(&amp;AxisBinding::Vertical(player.id))
                .unwrap_or(0.0);
            
            let shoot = input
                .action_is_down(&amp;ActionBinding::Shoot(player.id))
                .unwrap_or(false);
            
            transform.move_up(horizontal);
            transform.move_right(vertical);
            
            if shoot {
                player.shoot();
            }
        }
    }
}
</code></pre>
<p>And don't forget to add the <code>MovementSystem</code> to the game data.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::ecs::*;
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">struct MovementSystem;
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MovementSystem {type SystemData=(); fn run(&amp;mut self, _: ()) {}}
</span>let game_data = GameDataBuilder::default()
//..
    .with(MovementSystem, &quot;movement_system&quot;, &amp;[&quot;input_system&quot;])
//..
<span class="boring">  ;
</span></code></pre>
<h1><a class="header" href="#assets" id="assets">Assets</a></h1>
<p><strong>Assets</strong> are data that's loaded by a game when it is run. These may be textures, sounds, game level scripts, and so on. In fact, any data that is loaded at runtime may be considered an asset. These are usually stored as files, and distributed alongside the game.</p>
<p>When used well, assets enhance the gaming experience. For example, in an asteroid shooter, when a bullet hits an asteroid we can do the following:</p>
<ul>
<li>Draw broken pieces of the asteroid falling away.</li>
<li>Display a fireball animation.</li>
<li>Play an explosion sound.</li>
</ul>
<h2><a class="header" href="#handles" id="handles">Handles</a></h2>
<p>In a game, the same asset may be used by different game objects. For example, a fireball texture asset can be used by many different objects that shoot fireballs. Loading the texture mutiple times is an inefficient use of memory; loading it once, and using references to the same loaded asset is <em>much</em> more efficient. We call these references, <strong>handles</strong>.</p>
<h1><a class="header" href="#formats" id="formats">Formats</a></h1>
<p>A <strong>format</strong> is a way of encoding the information of an asset so that it can be stored and read later. For example, a texture may be stored as a Bitmap (BMP), Portable Network Graphic (PNG), or Targa (TGA). Game levels can be stored using <a href="https://github.com/ron-rs/ron">RON</a>, <a href="http://json.org/">JSON</a>, <a href="https://github.com/toml-lang/toml">TOML</a> or any other suitable encoding.</p>
<p>Each format has its own strengths and weaknesses. For example, <code>RON</code> has direct mapping from the storage format to the in-memory object type. <code>JSON</code> is widely used, so it is easy to find a JSON parser in any programming language. <code>TOML</code> is easier for people to read.</p>
<h1><a class="header" href="#how-to-use-assets" id="how-to-use-assets">How to Use Assets</a></h1>
<p>This guide covers the basic usage of assets into Amethyst for existing supported formats. For a list of supported formats, please <a href="https://docs.amethyst.rs/stable/amethyst/?search=Format">use this search for &quot;Format&quot;</a> in the API documentation, and filter by the following crates:</p>
<ul>
<li>amethyst_assets</li>
<li>amethyst_audio</li>
<li>amethyst_gltf</li>
<li>amethyst_locale</li>
<li>amethyst_ui</li>
</ul>
<h2><a class="header" href="#steps" id="steps">Steps</a></h2>
<ol>
<li>
<p>Instantiate the Amethyst application with the assets directory.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    prelude::*,
<span class="boring">  ecs::{World, WorldExt},
</span>    utils::application_root_dir,
};
<span class="boring">
</span><span class="boring">pub struct LoadingState;
</span><span class="boring">impl SimpleState for LoadingState {}
</span>
fn main() -&gt; amethyst::Result&lt;()&gt; {
    // Sets up the application to read assets in
    // `&lt;app_dir&gt;/assets`
    let app_root = application_root_dir()?;
    let assets_dir = app_root.join(&quot;assets&quot;);

    //..
<span class="boring">  let world = World::new();
</span><span class="boring">  let game_data = GameDataBuilder::default();
</span>
    let mut game = Application::new(assets_dir, LoadingState, game_data)?;
<span class="boring">
</span><span class="boring">  game.run();
</span><span class="boring">  Ok(())
</span>}
</code></pre>
</li>
<li>
<p>Ensure that the <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Processor.html"><code>Processor&lt;A&gt;</code> system</a> for asset type <code>A</code> is registered in the dispatcher.</p>
<p>For asset type <code>A</code>, <code>Processor&lt;A&gt;</code> is a <code>System</code> that will asynchronously load <code>A</code> assets. Usually the crate that provides <code>A</code> will also register <code>Processor&lt;A&gt;</code> through a <code>SystemBundle</code>. Examples:</p>
<ul>
<li><code>FontAsset</code> is provided by <code>amethyst_ui</code>, <code>UiBundle</code> registers <code>Processor&lt;FontAsset&gt;</code>.</li>
<li><code>Source</code> is provided by <code>amethyst_audio</code>, <code>AudioBundle</code> registers <code>Processor&lt;Source&gt;</code>.</li>
<li><code>SpriteSheet</code> is not added by a bundle, so <code>Processor&lt;SpriteSheet&gt;</code> needs to be added
to the builder.</li>
</ul>
</li>
<li>
<p>Use the <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Loader.html"><code>Loader</code></a> resource to load the asset.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{AssetStorage, Handle, Loader, ProgressCounter},
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{formats::texture::ImageFormat, Texture},
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">};
</span><span class="boring">
</span>pub struct LoadingState {
    /// Tracks loaded assets.
    progress_counter: ProgressCounter,
    /// Handle to the player texture.
    texture_handle: Option&lt;Handle&lt;Texture&gt;&gt;,
}

impl SimpleState for LoadingState {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let loader = &amp;data.world.read_resource::&lt;Loader&gt;();
        let texture_handle = loader.load(
            &quot;player.png&quot;,
            ImageFormat::default(),
            &amp;mut self.progress_counter,
            &amp;data.world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;(),
        );

        self.texture_handle = Some(texture_handle);
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">  let app_root = application_root_dir()?;
</span><span class="boring">  let assets_dir = app_root.join(&quot;assets&quot;);
</span><span class="boring">
</span><span class="boring">  let game_data = GameDataBuilder::default();
</span><span class="boring">  let mut game = Application::new(
</span><span class="boring">      assets_dir,
</span><span class="boring">      LoadingState {
</span><span class="boring">          progress_counter: ProgressCounter::new(),
</span><span class="boring">          texture_handle: None,
</span><span class="boring">      },
</span><span class="boring">      game_data,
</span><span class="boring">  )?;
</span><span class="boring">
</span><span class="boring">  game.run();
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span></code></pre>
</li>
<li>
<p>Wait for the asset to be loaded.</p>
<p>When <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Loader.html#method.load"><code>loader.load(..)</code></a> is used to load an <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.Asset.html"><code>Asset</code></a>, the method returns immediately with a handle for the asset. The asset loading is handled asynchronously in the background, so if the handle is used to retrieve the asset, such as with <a href="https://docs.amethyst.rs/stable/specs/world/struct.World.html#method.read_resource"><code>world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;()</code></a><a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.AssetStorage.html#method.get"><code>.get(texture_handle)</code></a>, it will return <code>None</code> until the <code>Texture</code> has finished loading.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Handle, ProgressCounter},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::Texture,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct GameState {
</span><span class="boring">    /// Handle to the player texture.
</span><span class="boring">    texture_handle: Handle&lt;Texture&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SimpleState for GameState {}
</span><span class="boring">
</span><span class="boring">pub struct LoadingState {
</span><span class="boring">    /// Tracks loaded assets.
</span><span class="boring">    progress_counter: ProgressCounter,
</span><span class="boring">    /// Handle to the player texture.
</span><span class="boring">    texture_handle: Option&lt;Handle&lt;Texture&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl SimpleState for LoadingState {
    fn update(
        &amp;mut self,
        _data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;,
    ) -&gt; SimpleTrans {
        if self.progress_counter.is_complete() {
            Trans::Switch(Box::new(GameState {
                texture_handle: self.texture_handle
                    .take()
                    .expect(
                        &quot;Expected `texture_handle` to exist when \
                        `progress_counter` is complete.&quot;
                    ),
            }))
        } else {
            Trans::None
        }
    }
}
</code></pre>
<p>The asset handle can now be used:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::Handle,
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::Texture,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct GameState {
</span><span class="boring">    /// Handle to the player texture.
</span><span class="boring">    texture_handle: Handle&lt;Texture&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl SimpleState for GameState {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // Create the player entity.
        data.world
            .create_entity()
            // Use the texture handle as a component
            .with(self.texture_handle.clone())
            .build();
    }
}
</code></pre>
</li>
</ol>
<h1><a class="header" href="#how-to-define-custom-assets" id="how-to-define-custom-assets">How to Define Custom Assets</a></h1>
<p>This guide explains how to define a new asset type to be used in an Amethyst application. If you are defining a new asset type that may be useful to others, <a href="https://github.com/amethyst/amethyst/blob/master/docs/CONTRIBUTING.md">please send us a PR!</a></p>
<ol>
<li>
<p>Define the type and handle for your asset.</p>
<pre><code class="language-rust edition2018 ignore noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span>use amethyst::{
    assets::Handle,
    ecs::VecStorage,
};

/// Custom asset representing an energy blast.
#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct EnergyBlast {
    /// How much HP to subtract.
    pub hp_damage: u32,
    /// How much MP to subtract.
    pub mp_damage: u32,
}

/// A handle to a `EnergyBlast` asset.
pub type EnergyBlastHandle = Handle&lt;EnergyBlast&gt;;
</code></pre>
</li>
<li>
<p>Define the type that represents the serializable form of the asset.</p>
<p>The serializable type can be one of:</p>
<ul>
<li>
<p>The asset type itself, in which case you simply derive <code>Serialize</code> and <code>Deserialize</code> on the type:</p>
<pre><code class="language-rust ignore">#[derive(Serialize, Deserialize, ..)]
pub struct EnergyBlast { .. }
</code></pre>
</li>
<li>
<p>An enum with different variants – each for a different data layout:</p>
<pre><code class="language-rust edition2018 ignore noplaypen"><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span><span class="boring">use serde_derive::{Deserialize, Serialize};
</span>
/// Separate serializable type to support different versions
/// of energy blast configuration.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum EnergyBlastData {
    /// Early version only could damage HP.
    Version1 { hp_damage: u32 },
    /// Add support for subtracting MP.
    Version2 { hp_damage: u32, mp_damage: u32 },
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Implement the <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.Asset.html"><code>Asset</code></a> trait on the asset type.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Asset, Handle},
</span><span class="boring">    ecs::VecStorage,
</span><span class="boring">};
</span><span class="boring">use serde_derive::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">/// Custom asset representing an energy blast.
</span><span class="boring">#[derive(Clone, Debug, Default, PartialEq, Eq)]
</span><span class="boring">pub struct EnergyBlast {
</span><span class="boring">    /// How much HP to subtract.
</span><span class="boring">    pub hp_damage: u32,
</span><span class="boring">    /// How much MP to subtract.
</span><span class="boring">    pub mp_damage: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Asset for EnergyBlast {
    const NAME: &amp;'static str = &quot;my_crate::EnergyBlast&quot;;
    // use `Self` if the type is directly serialized.
    type Data = EnergyBlastData;
    type HandleStorage = VecStorage&lt;EnergyBlastHandle&gt;;
}
<span class="boring">
</span><span class="boring">/// A handle to a `EnergyBlast` asset.
</span><span class="boring">pub type EnergyBlastHandle = Handle&lt;EnergyBlast&gt;;
</span><span class="boring">
</span><span class="boring">/// Separate serializable type to support different versions
</span><span class="boring">/// of energy blast configuration.
</span><span class="boring">#[derive(Clone, Debug, Deserialize, Serialize)]
</span><span class="boring">pub enum EnergyBlastData {
</span><span class="boring">    /// Early version only could damage HP.
</span><span class="boring">    Version1 { hp_damage: u32 },
</span><span class="boring">    /// Add support for subtracting MP.
</span><span class="boring">    Version2 { hp_damage: u32, mp_damage: u32 },
</span><span class="boring">}
</span></code></pre>
</li>
<li>
<p>Implement the <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.ProcessableAsset.html"><code>ProcessableAsset</code></a> trait, providing the conversion function for <code>A::Data</code> into a <code>ProcessingState&lt;A&gt;</code> result.</p>
<p>The <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Processor.html"><code>Processor&lt;A&gt;</code> system</a> uses this trait to convert the deserialized asset data into the asset.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    error::Error,
</span><span class="boring">    assets::{Asset, Handle, ProcessingState, ProcessableAsset},
</span><span class="boring">    ecs::VecStorage,
</span><span class="boring">};
</span><span class="boring">use serde_derive::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">/// Custom asset representing an energy blast.
</span><span class="boring">#[derive(Clone, Debug, Default, PartialEq, Eq)]
</span><span class="boring">pub struct EnergyBlast {
</span><span class="boring">    /// How much HP to subtract.
</span><span class="boring">    pub hp_damage: u32,
</span><span class="boring">    /// How much MP to subtract.
</span><span class="boring">    pub mp_damage: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// A handle to a `EnergyBlast` asset.
</span><span class="boring">pub type EnergyBlastHandle = Handle&lt;EnergyBlast&gt;;
</span><span class="boring">
</span><span class="boring">impl Asset for EnergyBlast {
</span><span class="boring">    const NAME: &amp;'static str = &quot;my_crate::EnergyBlast&quot;;
</span><span class="boring">    // use `Self` if the type is directly serialized.
</span><span class="boring">    type Data = EnergyBlastData;
</span><span class="boring">    type HandleStorage = VecStorage&lt;EnergyBlastHandle&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Separate serializable type to support different versions
</span><span class="boring">/// of energy blast configuration.
</span><span class="boring">#[derive(Clone, Debug, Deserialize, Serialize)]
</span><span class="boring">pub enum EnergyBlastData {
</span><span class="boring">    /// Early version only could damage HP.
</span><span class="boring">    Version1 { hp_damage: u32 },
</span><span class="boring">    /// Add support for subtracting MP.
</span><span class="boring">    Version2 { hp_damage: u32, mp_damage: u32 },
</span><span class="boring">}
</span><span class="boring">
</span>impl ProcessableAsset for EnergyBlast {
    fn process(energy_blast_data: Self::Data) -&gt; Result&lt;ProcessingState&lt;Self&gt;, Error&gt; {
        match energy_blast_data {
            EnergyBlastData::Version1 { hp_damage } =&gt; {
                Ok(ProcessingState::Loaded(Self {
                    hp_damage,
                    ..Default::default()
                }))
            }
            EnergyBlastData::Version2 { hp_damage, mp_damage } =&gt; {
                Ok(ProcessingState::Loaded(Self {
                    hp_damage,
                    mp_damage,
                }))
            }
        }
    }
}
</code></pre>
<p>If your asset is stored using one of the existing supported formats such as RON or JSON, it can now be used:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    error::Error,
</span><span class="boring">    assets::{AssetStorage, Loader, ProcessableAsset, ProcessingState, ProgressCounter, RonFormat},
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">};
</span><span class="boring">use serde_derive::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Asset, Handle},
</span><span class="boring">    ecs::VecStorage,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">/// Custom asset representing an energy blast.
</span><span class="boring">#[derive(Clone, Debug, Default, PartialEq, Eq)]
</span><span class="boring">pub struct EnergyBlast {
</span><span class="boring">    /// How much HP to subtract.
</span><span class="boring">    pub hp_damage: u32,
</span><span class="boring">    /// How much MP to subtract.
</span><span class="boring">    pub mp_damage: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// A handle to a `EnergyBlast` asset.
</span><span class="boring">pub type EnergyBlastHandle = Handle&lt;EnergyBlast&gt;;
</span><span class="boring">
</span><span class="boring">/// Separate serializable type to support different versions
</span><span class="boring">/// of energy blast configuration.
</span><span class="boring">#[derive(Clone, Debug, Deserialize, Serialize)]
</span><span class="boring">pub enum EnergyBlastData {
</span><span class="boring">    /// Early version only could damage HP.
</span><span class="boring">    Version1 { hp_damage: u32 },
</span><span class="boring">    /// Add support for subtracting MP.
</span><span class="boring">    Version2 { hp_damage: u32, mp_damage: u32 },
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Asset for EnergyBlast {
</span><span class="boring">    const NAME: &amp;'static str = &quot;my_crate::EnergyBlast&quot;;
</span><span class="boring">    // use `Self` if the type is directly serialized.
</span><span class="boring">    type Data = EnergyBlastData;
</span><span class="boring">    type HandleStorage = VecStorage&lt;EnergyBlastHandle&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ProcessableAsset for EnergyBlast {
</span><span class="boring">    fn process(energy_blast_data: Self::Data) -&gt; Result&lt;ProcessingState&lt;Self&gt;, Error&gt; {
</span><span class="boring">        match energy_blast_data {
</span><span class="boring">            EnergyBlastData::Version1 { hp_damage } =&gt; {
</span><span class="boring">                Ok(ProcessingState::Loaded(Self {
</span><span class="boring">                    hp_damage,
</span><span class="boring">                    ..Default::default()
</span><span class="boring">                }))
</span><span class="boring">            }
</span><span class="boring">            EnergyBlastData::Version2 { hp_damage, mp_damage } =&gt; {
</span><span class="boring">                Ok(ProcessingState::Loaded(Self {
</span><span class="boring">                    hp_damage,
</span><span class="boring">                    mp_damage,
</span><span class="boring">                }))
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LoadingState {
</span><span class="boring">    /// Tracks loaded assets.
</span><span class="boring">    progress_counter: ProgressCounter,
</span><span class="boring">    /// Handle to the energy blast.
</span><span class="boring">    energy_blast_handle: Option&lt;EnergyBlastHandle&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl SimpleState for LoadingState {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let loader = &amp;data.world.read_resource::&lt;Loader&gt;();
        let energy_blast_handle = loader.load(
            &quot;energy_blast.ron&quot;,
            RonFormat,
            &amp;mut self.progress_counter,
            &amp;data.world.read_resource::&lt;AssetStorage&lt;EnergyBlast&gt;&gt;(),
        );

        self.energy_blast_handle = Some(energy_blast_handle);
    }
}
<span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">  let app_root = application_root_dir()?;
</span><span class="boring">  let assets_dir = app_root.join(&quot;assets&quot;);
</span><span class="boring">
</span><span class="boring">  let game_data = GameDataBuilder::default();
</span><span class="boring">  let mut game = Application::new(
</span><span class="boring">      assets_dir,
</span><span class="boring">      LoadingState {
</span><span class="boring">          progress_counter: ProgressCounter::new(),
</span><span class="boring">          energy_blast_handle: None,
</span><span class="boring">      },
</span><span class="boring">      game_data,
</span><span class="boring">  )?;
</span><span class="boring">
</span><span class="boring">  game.run();
</span><span class="boring">  Ok(())
</span><span class="boring">}
</span></code></pre>
<p>If the asset data is stored in a format that is not supported by Amethyst, a <a href="assets/how_to_define_custom_formats.html">custom format</a> can be implemented and provided to the <code>Loader</code> to load the asset data.</p>
</li>
</ol>
<h1><a class="header" href="#how-to-define-custom-formats" id="how-to-define-custom-formats">How to Define Custom Formats</a></h1>
<p>This guide explains how to define a new asset format. This will allow Amethyst to load assets stored in a particular encoding.</p>
<p>There is a trait in Amethyst for implementing a format: <code>Format&lt;A: Asset::Data&gt;</code>.
<code>Format</code> provides a loading implementation that provides detection when an asset should be reloaded for <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.HotReloadStrategy.html">hot reloading</a>; you don't need to implement it since it has a default implementation.
A blanket implementation will implement <code>Format::import</code> and we only need to implement 
<code>Format::import_simple</code>.</p>
<p><code>Format</code> takes a type parameter for the asset data type it supports. This guide covers a type 
parameterized implementation of <code>Format&lt;D&gt;</code> where <code>D</code> is an arbitrary <code>Asset::Data</code>, so we can
reuse it for any asset which can be loaded from deserializable asset data.</p>
<p>If you are defining a new format that may be useful to others, <a href="https://github.com/amethyst/amethyst/blob/master/docs/CONTRIBUTING.md">please send us a PR!</a></p>
<ol>
<li>
<p>Define a struct that represents the format.</p>
<p>In most cases a unit struct is sufficient. When possible, this should implement <code>Clone</code> and <code>Copy</code> for ergonomic usage.</p>
<pre><code class="language-rust edition2018 no_run noplaypen">/// Format for loading from `.mylang` files.
#[derive(Clone, Copy, Debug, Default)]
pub struct MyLangFormat;
</code></pre>
</li>
<li>
<p>Implement the <code>Format</code> trait.</p>
<p>This is where the logic to deserialize the <a href="assets/how_to_define_custom_assets.html">asset data type</a> is provided. 
Fields of the format struct can be used to specify additional parameters for 
deserialization; use a unit struct if this is not needed.</p>
<p>In this example the RON deserializer is used, though it is <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.RonFormat.html">already a supported format</a>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate ron;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span>use amethyst::{
    error::Error,
    assets::{Asset, Format},
};
use serde::Deserialize;
use ron::de::Deserializer; // Replace this in your implementation.

/// Format for loading from `.mylang` files.
#[derive(Clone, Copy, Debug, Default)]
pub struct MyLangFormat;

impl&lt;D&gt; Format&lt;D&gt; for MyLangFormat
where
    D: for&lt;'a&gt; Deserialize&lt;'a&gt; + Send + Sync + 'static,
{
    fn name(&amp;self) -&gt; &amp;'static str {
        &quot;MyLangFormat&quot;
    }

    fn import_simple(&amp;self, bytes: Vec&lt;u8&gt;) -&gt; Result&lt;D, Error&gt; {
        let mut deserializer = Deserializer::from_bytes(&amp;bytes)?;
        let val = D::deserialize(&amp;mut deserializer)?;
        deserializer.end()?;

        Ok(val)
    }
}
</code></pre>
<p>The custom format can now be used:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate ron;
</span><span class="boring">extern crate serde;
</span><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    error::Error,
</span><span class="boring">    assets::{
</span><span class="boring">        Asset, AssetStorage, Handle, Loader, Processor, ProgressCounter,
</span><span class="boring">        ProcessingState, Format,
</span><span class="boring">    },
</span><span class="boring">    ecs::{VecStorage, World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">};
</span><span class="boring">use ron::de::Deserializer;
</span><span class="boring">use serde::Deserialize as DeserializeTrait;
</span><span class="boring">use serde_derive::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">/// Custom asset representing an energy blast.
</span><span class="boring">#[derive(Clone, Debug, Default, PartialEq, Eq, Deserialize, Serialize)]
</span><span class="boring">pub struct EnergyBlast {
</span><span class="boring">    /// How much HP to subtract.
</span><span class="boring">    pub hp_damage: u32,
</span><span class="boring">    /// How much MP to subtract.
</span><span class="boring">    pub mp_damage: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// A handle to a `EnergyBlast` asset.
</span><span class="boring">pub type EnergyBlastHandle = Handle&lt;EnergyBlast&gt;;
</span><span class="boring">
</span><span class="boring">impl Asset for EnergyBlast {
</span><span class="boring">    const NAME: &amp;'static str = &quot;my_crate::EnergyBlast&quot;;
</span><span class="boring">    type Data = Self;
</span><span class="boring">    type HandleStorage = VecStorage&lt;EnergyBlastHandle&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;EnergyBlast&gt; for Result&lt;ProcessingState&lt;EnergyBlast&gt;, Error&gt; {
</span><span class="boring">    fn from(energy_blast: EnergyBlast) -&gt; Result&lt;ProcessingState&lt;EnergyBlast&gt;, Error&gt; {
</span><span class="boring">      Ok(ProcessingState::Loaded(energy_blast))
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LoadingState {
</span><span class="boring">    /// Tracks loaded assets.
</span><span class="boring">    progress_counter: ProgressCounter,
</span><span class="boring">    /// Handle to the energy blast.
</span><span class="boring">    energy_blast_handle: Option&lt;EnergyBlastHandle&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">/// Format for loading from `.mylang` files.
</span><span class="boring"> #[derive(Clone, Copy, Debug, Default)]
</span><span class="boring"> pub struct MyLangFormat;
</span><span class="boring">
</span><span class="boring"> impl&lt;D&gt; Format&lt;D&gt; for MyLangFormat
</span><span class="boring"> where
</span><span class="boring">     D: for&lt;'a&gt; DeserializeTrait&lt;'a&gt; + Send + Sync + 'static,
</span><span class="boring"> {
</span><span class="boring">     fn name(&amp;self) -&gt; &amp;'static str {
</span><span class="boring">         &quot;MyLangFormat&quot;
</span><span class="boring">     }
</span><span class="boring">
</span><span class="boring">     fn import_simple(&amp;self, bytes: Vec&lt;u8&gt;) -&gt; Result&lt;D, Error&gt; {
</span><span class="boring">         let mut deserializer = Deserializer::from_bytes(&amp;bytes)?;
</span><span class="boring">         let val = D::deserialize(&amp;mut deserializer)?;
</span><span class="boring">         deserializer.end()?;
</span><span class="boring">
</span><span class="boring">         Ok(val)
</span><span class="boring">     }
</span><span class="boring"> }
</span><span class="boring">
</span>impl SimpleState for LoadingState {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let loader = &amp;data.world.read_resource::&lt;Loader&gt;();
        let energy_blast_handle = loader.load(
            &quot;energy_blast.mylang&quot;,
            MyLangFormat,
            &amp;mut self.progress_counter,
            &amp;data.world.read_resource::&lt;AssetStorage&lt;EnergyBlast&gt;&gt;(),
        );

        self.energy_blast_handle = Some(energy_blast_handle);
    }
<span class="boring">
</span><span class="boring">    fn update(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        _data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;,
</span><span class="boring">    ) -&gt; SimpleTrans {
</span><span class="boring">        Trans::Quit
</span><span class="boring">    }
</span>}
<span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">    amethyst::start_logger(Default::default());
</span><span class="boring">    let app_root = application_root_dir()?;
</span><span class="boring">    let assets_dir = app_root.join(&quot;assets&quot;);
</span><span class="boring">
</span><span class="boring">    let game_data = GameDataBuilder::default()
</span><span class="boring">        .with(Processor::&lt;EnergyBlast&gt;::new(), &quot;&quot;, &amp;[]);
</span><span class="boring">    let mut game = Application::new(
</span><span class="boring">        assets_dir,
</span><span class="boring">        LoadingState {
</span><span class="boring">            progress_counter: ProgressCounter::new(),
</span><span class="boring">            energy_blast_handle: None,
</span><span class="boring">        },
</span><span class="boring">        game_data,
</span><span class="boring">    )?;
</span><span class="boring">
</span><span class="boring">    game.run();
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span></code></pre>
</li>
</ol>
<h1><a class="header" href="#prefabs" id="prefabs">Prefabs</a></h1>
<p>Premade fabrications, or prefabs, are templates that specify components to attach to an entity. For example, imagine a monster entity has the following components:</p>
<ul>
<li>Position</li>
<li>Velocity</li>
<li>Texture</li>
<li>Health points</li>
<li>Attack damage</li>
</ul>
<p>It is certainly possible to define the values for each monster in code. However, if the components are initialized in code, then the executable needs to be recompiled whenever the component values are changed. Waiting a number of minutes to every time a small change is made is both inefficient and frustrating.</p>
<p>In data-oriented design, instantiating monsters is logic and is part of the executable, but the values to use for the components is data. The executable can instantiate any monster using the data for the monsters read from a <em>prefab</em> file like the following:</p>
<pre><code class="language-rust ignore">// monster_weak.ron
//
// This is simply an example of what a prefab can look like.
// Other game engines may store prefabs in binary formats which require
// an editor to read and update.

#![enable(implicit_some)]
Prefab (
    entities: [
        (
            data: (
                position: (0.0, 0.0, 0.0),
                velocity: (0.0, 0.0, 0.0),
                texture: Asset(File(&quot;textures/monster.png&quot;, PngFormat, ())),
                health: 100,
                attack: 10,
            ),
        ),
    ],
)
</code></pre>
<p>The prefab is distributed alongside the executable as part of the game.</p>
<h2><a class="header" href="#uses" id="uses">Uses</a></h2>
<p>Prefabs have the following properties:</p>
<ul>
<li>All entity instances created based on that prefab will receive changes made on the prefab.</li>
<li>Prefabs may nest other prefabs, allowing larger prefabs to be composed of other smaller prefabs.</li>
</ul>
<p>These make prefabs ideal to use to define scenes or levels:</p>
<ul>
<li>City prefab composed of terrain, buildings, and foliage prefabs.</li>
<li>Maze prefab composed of walls, a player, and monster prefabs.</li>
</ul>
<h1><a class="header" href="#prefabs-in-amethyst" id="prefabs-in-amethyst">Prefabs in Amethyst</a></h1>
<blockquote>
<p><strong>Note:</strong> This page assumes you have read and understood <a href="prefabs/../assets.html">assets</a>.</p>
</blockquote>
<p>Many game engines – including Amethyst – treat prefabs as <a href="prefabs/../assets.html">assets</a>, and so they are usually stored as files and loaded at runtime. After loading the asset(s), prefabs have additional processing to turn them into <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>s and attach them to entities.</p>
<h2><a class="header" href="#representation" id="representation">Representation</a></h2>
<p>There are two representations of a prefab:</p>
<ul>
<li>Stored representation, distributed alongside the application.</li>
<li>Loaded representation, used at runtime to instantiate entities with components.</li>
</ul>
<p>The remainder of this page explains these at a conceptual level; subsequent pages contain guides on how Amethyst applies this at a code level.</p>
<h3><a class="header" href="#the-basics" id="the-basics">The Basics</a></h3>
<blockquote>
<p><strong>Note:</strong> The prefab examples on this page include the <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a> type names. These are written out for clarity. However, as per the RON specification, these are not strictly required.</p>
</blockquote>
<p>In its stored form, a prefab is a serialized list of entities and their components that should be instantiated together. To begin, we will look at a simple prefab that attaches a simple component to a single entity. We will use the following <code>Position</code> component:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate derivative;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Prefab, PrefabData},
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::DenseVecStorage,
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use derivative::Derivative;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
<span class="boring">#[serde(deny_unknown_fields)]
</span>pub struct Position(pub f32, pub f32, pub f32);
</code></pre>
<p>The important derives are the <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a> and <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a> – <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a> means it can be attached to an entity; <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a> means it can be loaded as part of a prefab. The <code>#[prefab(Component)]</code> attribute informs the <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a> derive that this type is a <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>, as opposed to being composed of fields which implement <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a>. This will only be important when implementing a custom prefab.</p>
<p>Here is an example <code>.ron</code> file of a prefab with an entity with a <code>Position</code>:</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        PrefabEntity(
            // parent: None // Optional
            data: Position(1.0, 2.0, 3.0),
        ),
    ],
)
</code></pre>
<p>The top level type is a <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Prefab.html"><code>Prefab</code></a>, and holds a list of <code>entities</code>. These are not the <a href="https://docs.amethyst.rs/stable/specs/struct.Entity.html"><code>Entity</code></a> type used at runtime, but the <a href="https://github.com/amethyst/amethyst/blob/v0.10.0/amethyst_assets/src/prefab/mod.rs#L110-L115"><code>PrefabEntity</code></a> type – a template for what <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>s to attach to entities at runtime. Each of these holds two pieces of information:</p>
<ul>
<li>
<p><code>data</code>: Specifies the <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>s to attach to the entity.</p>
<p>This must be a type that implements <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a>. When this prefab is instantiated, it will attach a <code>Position</code> component to the entity.</p>
</li>
<li>
<p><code>parent</code>: (Optional) index of this entity's <a href="https://docs.amethyst.rs/stable/amethyst_core/transform/components/struct.Parent.html"><code>Parent</code></a> entity. The value is the index of the parent entity which resides within this prefab file.</p>
</li>
</ul>
<p>When we load this prefab, the prefab entity is read as:</p>
<pre><code class="language-rust ignore">PrefabEntity { parent: None, data: Some(Position(1.0, 2.0, 3.0)) }
</code></pre>
<p>Next, we create an entity with the prefab handle, <code>Handle&lt;Prefab&lt;Position&gt;&gt;</code>:</p>
<table><thead><tr><th>Entity</th><th>Handle&lt;Prefab&lt;Position&gt;&gt;</th></tr></thead><tbody>
<tr><td>Entity(0, Generation(1))</td><td>Handle { id: 0 }</td></tr>
</tbody></table>
<p>In the background, the <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.PrefabLoaderSystem.html"><code>PrefabLoaderSystem</code></a> will run, and attach the <code>Position</code> component:</p>
<table><thead><tr><th>Entity</th><th>Handle&lt;Prefab&lt;Position&gt;&gt;</th><th>Position</th></tr></thead><tbody>
<tr><td>Entity(0, Generation(1))</td><td>Handle { id: 0 }</td><td>Position(1.0, 2.0, 3.0)</td></tr>
</tbody></table>
<p>This can be seen by running the <code>prefab_basic</code> example from the Amethyst repository:</p>
<pre><code class="language-bash">cargo run --example prefab_basic
</code></pre>
<h3><a class="header" href="#multiple-components" id="multiple-components">Multiple Components</a></h3>
<p>If there are multiple components to be attached to the entity, then we need a type that aggregates the <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>s:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate derivative;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Prefab, PrefabData, ProgressCounter},
</span><span class="boring">    core::Named,
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::{DenseVecStorage, VecStorage},
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use derivative::Derivative;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
</span><span class="boring">#[prefab(Component)]
</span><span class="boring">#[serde(deny_unknown_fields)]
</span><span class="boring">pub struct Position(pub f32, pub f32, pub f32);
</span><span class="boring">
</span>#[derive(Debug, Deserialize, Serialize, PrefabData)]
<span class="boring">#[serde(deny_unknown_fields)]
</span>pub struct Player {
    player: Named,
    position: Position,
}
</code></pre>
<p>Here, the <code>Player</code> type is <strong>not</strong> a <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>, but it does implement <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a>. Each of its fields is a <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E"><code>PrefabData</code></a> as well as a <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>.</p>
<p>The corresponding prefab file is written as follows:</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        PrefabEntity(
            data: Player(
                player: Named(name: &quot;Zero&quot;),
                position: Position(1.0, 2.0, 3.0),
            ),
        ),
    ],
)
</code></pre>
<p>When an entity is created with this prefab, Amethyst will recurse into each of the prefab data fields – <a href="https://docs.amethyst.rs/stable/amethyst_core/struct.Named.html"><code>Named</code></a> and <code>Position</code> – to attach their respective components to the entity.</p>
<p>Now, when we create an entity with the prefab handle, both components will be attached:</p>
<table><thead><tr><th>Handle&lt;Prefab&lt;Player&gt;&gt;</th><th>Position</th><th>Player</th></tr></thead><tbody>
<tr><td>Handle { id: 0 }</td><td>Position(1.0, 2.0, 3.0)</td><td>Named { name: &quot;Zero&quot; }</td></tr>
</tbody></table>
<p>This can be seen by running the <code>prefab_multi</code> example from the Amethyst repository:</p>
<pre><code class="language-bash">cargo run --example prefab_multi
</code></pre>
<h3><a class="header" href="#multiple-entities-different-components" id="multiple-entities-different-components">Multiple Entities, Different Components</a></h3>
<p>The next level is to instantiate multiple entities, each with their own set of <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>s. The current implementation of <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Prefab.html"><code>Prefab</code></a> requires the <code>data</code> field to be the same type for <em>every</em> <a href="https://github.com/amethyst/amethyst/blob/v0.10.0/amethyst_assets/src/prefab/mod.rs#L110-L115"><code>PrefabEntity</code></a> in the list. This means that to have different types of entity in the same prefab they must be variants of an enum. For instance, a prefab like this:</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        // Player
        PrefabEntity(
            data: Player(
                player: Named(name: &quot;Zero&quot;),
                position: Position(1.0, 2.0, 3.0),
            ),
        ),
        // Weapon
        PrefabEntity(
            parent: 0,
            data: Weapon(
                weapon_type: Sword,
                position: Position(4.0, 5.0, 6.0),
            ),
        ),
    ],
)
</code></pre>
<p>Could be implemented using an enum like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate derivative;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Prefab, PrefabData, ProgressCounter},
</span><span class="boring">    core::Named,
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::{DenseVecStorage, VecStorage},
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use derivative::Derivative;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
</span><span class="boring">#[prefab(Component)]
</span><span class="boring">#[serde(deny_unknown_fields)]
</span><span class="boring">pub struct Position(pub f32, pub f32, pub f32);
</span><span class="boring">
</span>#[derive(Clone, Copy, Component, Debug, Derivative, Deserialize, Serialize, PrefabData)]
#[derivative(Default)]
#[prefab(Component)]
#[storage(VecStorage)]
pub enum Weapon {
    #[derivative(Default)]
    Axe,
    Sword,
}

#[derive(Debug, Deserialize, Serialize, PrefabData)]
#[serde(deny_unknown_fields)]
pub enum CustomPrefabData {
    Player {
        name: Named,
        position: Option&lt;Position&gt;,
    },
    Weapon {
        weapon_type: Weapon,
        position: Option&lt;Position&gt;,
    },
}

</code></pre>
<p>When we run this, we start off by creating one entity:</p>
<table><thead><tr><th>Entity</th><th>Handle&lt;Prefab&lt;CustomPrefabData&gt;&gt;&gt;</th></tr></thead><tbody>
<tr><td>Entity(0, Generation(1))</td><td>Handle { id: 0 }</td></tr>
</tbody></table>
<p>When the <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.PrefabLoaderSystem.html"><code>PrefabLoaderSystem</code></a> runs, this becomes the following:</p>
<table><thead><tr><th>Entity</th><th>Handle&lt;Prefab&lt;CustomPrefabData&gt;&gt;&gt;</th><th>Parent</th><th>Position</th><th>Player</th><th>Weapon</th></tr></thead><tbody>
<tr><td>Entity(0, Generation(1))</td><td>Handle { id: 0 }</td><td>None</td><td>Position(1.0, 2.0, 3.0)</td><td>Named { name: &quot;Zero&quot; }</td><td>None</td></tr>
<tr><td>Entity(1, Generation(1))</td><td>None</td><td>Entity(0, Generation(1))</td><td>Position(4.0, 5.0, 6.0)</td><td>None</td><td>Sword</td></tr>
</tbody></table>
<ul>
<li>The entity that the <code>Handle&lt;Prefab&lt;T&gt;&gt;</code> is attached will be augmented with <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a>s from the first <a href="https://github.com/amethyst/amethyst/blob/v0.10.0/amethyst_assets/src/prefab/mod.rs#L110-L115"><code>PrefabEntity</code></a>.</li>
<li>A new entity is created for subsequent <a href="https://github.com/amethyst/amethyst/blob/v0.10.0/amethyst_assets/src/prefab/mod.rs#L110-L115"><code>PrefabEntity</code></a> entries in the <code>entities</code> list.</li>
</ul>
<p>Note that the <code>Weapon</code> has a parent with index <code>0</code>. Let's see what happens when multiple entities are created with this prefab. First, two entities are created with the prefab handle:</p>
<table><thead><tr><th>Entity</th><th>Handle&lt;Prefab&lt;CustomPrefabData&gt;&gt;&gt;</th></tr></thead><tbody>
<tr><td>Entity(0, Generation(1))</td><td>Handle { id: 0 }</td></tr>
<tr><td>Entity(1, Generation(1))</td><td>Handle { id: 0 }</td></tr>
</tbody></table>
<p>Next, the <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.PrefabLoaderSystem.html"><code>PrefabLoaderSystem</code></a> runs and creates and augments the entities:</p>
<table><thead><tr><th>Entity</th><th>Handle&lt;Prefab&lt;CustomPrefabData&gt;&gt;&gt;</th><th>Parent</th><th>Position</th><th>Player</th><th>Weapon</th></tr></thead><tbody>
<tr><td>Entity(0, Generation(1))</td><td>Handle { id: 0 }</td><td>None</td><td>Position(1.0, 2.0, 3.0)</td><td>Named { name: &quot;Zero&quot; }</td><td>None</td></tr>
<tr><td>Entity(1, Generation(1))</td><td>Handle { id: 0 }</td><td>None</td><td>Position(1.0, 2.0, 3.0)</td><td>Named { name: &quot;Zero&quot; }</td><td>None</td></tr>
<tr><td>Entity(2, Generation(1))</td><td>None</td><td>Entity(0, Generation(1))</td><td>Position(4.0, 5.0, 6.0)</td><td>None</td><td>Sword</td></tr>
<tr><td>Entity(3, Generation(1))</td><td>None</td><td>Entity(1, Generation(1))</td><td>Position(4.0, 5.0, 6.0)</td><td>None</td><td>Sword</td></tr>
</tbody></table>
<p>The sword entity <code>2</code> has player entity <code>0</code> as its parent, and sword entity <code>3</code> has player entity <code>1</code> as its parent.</p>
<p>This can be seen by running the <code>prefab_custom</code> example from the Amethyst repository:</p>
<pre><code class="language-bash">cargo run --example prefab_custom
</code></pre>
<hr />
<p>Phew, that was long! Now that you have an understanding of how prefabs work in Amethyst, the next page covers the technical aspects in more detail.</p>
<h1><a class="header" href="#how-to-define-prefabs-prelude" id="how-to-define-prefabs-prelude">How to Define Prefabs: Prelude</a></h1>
<p>This page is <strong>not</strong> a guide, but since prefabs are extremely complicated, this is a dedicated page to help you choose <em>which guide</em> to use.</p>
<p>If you are looking for a guide for how to define prefab data that combines the components of multiple existing prefabs, please see <a href="prefabs/how_to_define_prefabs_aggregate.html">How to Define Prefabs: Aggregate</a>.</p>
<p>If you are looking for a guide to define prefab data for a <code>Component</code>, first we need to figure out its type based on its serialized representation. The following table summarizes the types, and links to the relevant guide. For additional detail, refer to the code snippets below the table.</p>
<table><thead><tr><th>Component</th><th>Serialized representation</th><th>Example(s)</th><th>Prefab Data</th><th>Guide</th></tr></thead><tbody>
<tr><td><code>YourType</code></td><td><code>Self</code> – <code>YourType</code></td><td><code>Position</code></td><td><code>Position</code></td><td><a href="prefabs/how_to_define_prefabs_simple.html">Simple</a></td></tr>
<tr><td><code>YourType</code></td><td>Multiple – <code>V1(..)</code>, <code>V2(..)</code></td><td><a href="https://docs.amethyst.rs/stable/amethyst_rendy/struct.Camera.html"><code>Camera</code></a></td><td><a href="https://docs.amethyst.rs/stable/amethyst_rendy/camera/enum.CameraPrefab.html"><code>CameraPrefab</code></a></td><td><a href="prefabs/how_to_define_prefabs_adapter.html">Adapter</a></td></tr>
<tr><td><code>YourType</code></td><td>Subset of <code>YourType</code></td><td><a href="https://docs.amethyst.rs/stable/amethyst_audio/struct.AudioListener.html"><code>AudioListener</code></a></td><td><a href="https://docs.amethyst.rs/stable/amethyst_audio/struct.AudioPrefab.html"><code>AudioPrefab</code></a></td><td><a href="prefabs/how_to_define_prefabs_asset.html">Asset</a></td></tr>
<tr><td><code>Handle&lt;A&gt;</code></td><td>Loaded from <code>A::Data</code></td><td><a href="https://docs.amethyst.rs/stable/amethyst_rendy/rendy/mesh/struct.Mesh.html"><code>Mesh</code></a>, <a href="https://docs.amethyst.rs/stable/amethyst_rendy/rendy/texture/struct.Texture.html"><code>Texture</code></a></td><td><a href="https://docs.amethyst.rs/stable/amethyst_rendy/types/struct.MeshData.html"><code>MeshData</code></a>, <a href="https://docs.amethyst.rs/stable/amethyst_rendy/formats/texture/enum.TexturePrefab.html"><code>TexturePrefab</code></a></td><td><a href="prefabs/how_to_define_prefabs_asset.html">Asset</a></td></tr>
<tr><td><code>ManyHandles</code></td><td>Data that component stores handles of</td><td><a href="https://docs.amethyst.rs/stable/amethyst_rendy/struct.Material.html"><code>Material</code></a></td><td><a href="https://docs.amethyst.rs/stable/amethyst_rendy/formats/mtl/struct.MaterialPrefab.html"><code>MaterialPrefab</code></a></td><td><a href="prefabs/how_to_define_prefabs_multi_handle.html">Multi-Handle</a></td></tr>
</tbody></table>
<h3><a class="header" href="#serialized-representation" id="serialized-representation">Serialized Representation</a></h3>
<ul>
<li>
<p><strong><code>Self</code></strong></p>
<p>This is where the <code>Component</code> type itself is completely serializable – the data is self-contained.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::{storage::DenseVecStorage, Component};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Component, Debug, Deserialize, Serialize /* .. */)]
pub struct Position(pub f32, pub f32, pub f32);
</code></pre>
<p>Applicable guide: <a href="prefabs/how_to_define_prefabs_simple.html">How to Define Prefabs: Simple</a>.</p>
</li>
<li>
<p><strong>Multiple</strong></p>
<p>This is where are multiple ways to construct the component, and a user should be able to choose which one to use.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::{storage::DenseVecStorage, Component};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Component, Debug, Deserialize, Serialize /* .. */)]
</span><span class="boring">pub struct Position {
</span><span class="boring">    pub x: f32,
</span><span class="boring">    pub y: f32,
</span><span class="boring">    pub z: f32,
</span><span class="boring">};
</span><span class="boring">
</span>impl From&lt;(i32, i32, i32)&gt; for Position {
    fn from((x, y, z): (i32, i32, i32)) -&gt; Position {
        Position {
            x: x as f32,
            y: y as f32,
            z: z as f32,
        }
    }
}

impl From&lt;(f32, f32, f32)&gt; for Position {
    fn from((x, y, z): (f32, f32, f32)) -&gt; Position {
        Position { x, y, z }
    }
}
</code></pre>
<p>Applicable guide: <a href="prefabs/how_to_define_prefabs_adapter.html">How to Define Prefabs: Adapter</a>.</p>
</li>
<li>
<p><strong>Component Subset</strong></p>
<p>This is where most of the component is serializable, but there is also data that is only accessible at runtime, such as a device ID or an asset handle.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst_audio;
</span><span class="boring">extern crate amethyst_core;
</span><span class="boring">
</span><span class="boring">use amethyst_audio::output::Output;
</span><span class="boring">use amethyst_core::{
</span><span class="boring">    math::Point3,
</span><span class="boring">    ecs::{storage::HashMapStorage, Component},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(Debug, Component)]
<span class="boring">#[storage(HashMapStorage)]
</span>pub struct AudioListener {
    /// Output used by this listener to emit sounds to
    pub output: Output, // &lt;--- NOTE: Only available at runtime
    // ..
<span class="boring">    /// Position of the left ear relative to the global transform on this entity.
</span><span class="boring">    pub left_ear: Point3&lt;f32&gt;,
</span><span class="boring">    /// Position of the right ear relative to the global transform on this entity.
</span><span class="boring">    pub right_ear: Point3&lt;f32&gt;,
</span>}
</code></pre>
<p>Applicable guide: <a href="prefabs/how_to_define_prefabs_asset.html">How to Define Prefabs: Asset</a>.</p>
</li>
<li>
<p><strong>Asset</strong></p>
<p>When using <code>Handle&lt;A&gt;</code> as a component, <code>A</code> must <code>impl Asset</code>, and therefore <code>A::Data</code> must be serializable.</p>
<p>This is where you want to load <code>A</code> as part of a prefab.</p>
<p>Applicable guide: <a href="prefabs/how_to_define_prefabs_asset.html">How to Define Prefabs: Asset</a>.</p>
</li>
<li>
<p><strong>Multi-Handle</strong></p>
<p>This is where the <code>Component</code> itself stores <code>Handle&lt;_&gt;</code>s.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::Handle,
</span><span class="boring">    ecs::{storage::DenseVecStorage, Component},
</span><span class="boring">    renderer::Texture,
</span><span class="boring">};
</span><span class="boring">
</span>/// Material struct.
#[derive(Clone, PartialEq)]
pub struct Material {
    /// Diffuse map.
    pub albedo: Handle&lt;Texture&gt;,
    /// Emission map.
    pub emission: Handle&lt;Texture&gt;,
    // ..
}

impl Component for Material {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>Applicable guide: <a href="prefabs/how_to_define_prefabs_multi_handle.html">How to Define Prefabs: Multi-Handle</a>.</p>
</li>
</ul>
<h1><a class="header" href="#how-to-define-prefabs-simple" id="how-to-define-prefabs-simple">How to Define Prefabs: Simple</a></h1>
<p>This guide explains how to enable a [<code>[Component]</code>(https://docs.amethyst.rs/stable/specs/trait.Component.html)] to be used in a [<code>[Prefab]</code>(https://docs.amethyst.rs/stable/amethyst_assets/struct.Prefab.html)]. This can be applied where the [<code>[Component]</code>(https://docs.amethyst.rs/stable/specs/trait.Component.html)] type itself is completely serializable – the data is self-contained:</p>
<pre><code class="language-rust no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::{storage::DenseVecStorage, Component};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Component, Debug, Deserialize, Serialize /* .. */)]
pub struct Position(pub f32, pub f32, pub f32);
</code></pre>
<p>If you are attempting to adapt a more complex type, please choose the appropriate guide from the [available guides][bk_prefab_prelude].</p>
<h2><a class="header" href="#steps-1" id="steps-1">Steps</a></h2>
<ol>
<li>
<p>Ensure your crate has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
amethyst = &quot;..&quot; # Minimum version 0.10
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
</code></pre>
</li>
<li>
<p>Import the following items:</p>
<pre><code class="language-rust ignore">use amethyst::{
    assets::{PrefabData, ProgressCounter},
    derive::PrefabData,
    ecs::Entity,
    Error,
};
use serde::{Deserialize, Serialize};
</code></pre>
</li>
<li>
<p>Add the following attributes on your type:</p>
<pre><code class="language-rust ignore">#[derive(Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[serde(default)] // &lt;--- optional
#[serde(deny_unknown_fields)]
</code></pre>
<p>Example:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate derivative;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{Prefab, PrefabData},
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::DenseVecStorage,
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use derivative::Derivative;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[serde(deny_unknown_fields)]
pub struct Position(pub f32, pub f32, pub f32);
</code></pre>
<p>The [<code>[PrefabData]</code>(https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData)]<a href="https://docs.amethyst.rs/stable/amethyst_derive/derive.PrefabData.html">api_pf_derive</a> derive implements the <code>[PrefabData]</code> trait for the type. The <code>#[prefab(Component)]</code> attribute informs the <code>[PrefabData]</code> derive that this type is a [<code>[Component]</code>(https://docs.amethyst.rs/stable/specs/trait.Component.html)], as opposed to being composed of fields which implement <code>[PrefabData]</code>.</p>
<p>The [<a href="https://serde.rs/container-attrs.html#default"><code>#[serde(default)]</code></a>] attribute allows fields to not be specified in the prefab, and the fields' default value will be used. If this attribute is not present, then all fields must be specified in the prefab.</p>
<p>Finally, the [<a href="https://serde.rs/container-attrs.html#deny_unknown_fields"><code>#[serde(deny_unknown_fields)]</code></a>] ensures that deserialization produces an error if it encounters an unknown field. This will help expose mistakes in the prefab file, such as when there is a typo.</p>
</li>
<li>
<p>Now the type can be used in a prefab:</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        PrefabEntity(
            data: Position(1.0, 2.0, 3.0),
        ),
    ],
)
</code></pre>
</li>
</ol>
<p>To see this in a complete example, run the <a href="https://github.com/amethyst/amethyst/tree/master/examples/prefab_basic"><code>prefab_basic</code> example</a> from the Amethyst repository:</p>
<pre><code class="language-bash">cargo run --example prefab_basic
</code></pre>
<h1><a class="header" href="#how-to-define-prefabs-aggregate" id="how-to-define-prefabs-aggregate">How to Define Prefabs: Aggregate</a></h1>
<p>This guide explains how to define a [<code>PrefabData</code>] that encapsulates other [<code>PrefabData</code>].</p>
<p>If you intend to include a [<code>Component</code>] that has not yet got a corresponding [<code>PrefabData</code>], please use an appropriate guide from the [available guides][bk_prefab_prelude] to create its [<code>PrefabData</code>] first.</p>
<h2><a class="header" href="#steps-2" id="steps-2">Steps</a></h2>
<ol>
<li>
<p>Ensure your crate has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
amethyst = &quot;..&quot; # Minimum version 0.10
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
</code></pre>
</li>
<li>
<p>Import the following items:</p>
<pre><code class="language-rust ignore">use amethyst::{
    assets::{PrefabData, ProgressCounter},
    derive::PrefabData,
    ecs::Entity,
    Error,
};
use serde::{Deserialize, Serialize};
</code></pre>
</li>
<li>
<p>Define the aggregate prefab data type.</p>
<p>In these examples, <code>Named</code>, <code>Position</code>, and <code>Weapon</code> all derive [<code>PrefabData</code>].</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{PrefabData, ProgressCounter},
</span><span class="boring">    core::Named,
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::DenseVecStorage,
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[serde(deny_unknown_fields)]
pub struct Position(pub f32, pub f32, pub f32);

/// **Note:** All fields must be specified in the prefab. If a field is
/// not specified, then the prefab will fail to load.
#[derive(Deserialize, Serialize, PrefabData)]
#[serde(deny_unknown_fields)]
pub struct Player {
    name: Named,
    position: Position,
}
</code></pre>
<p>If you want to mix different types of entities within a single prefab then you must define an enum that implements <code>PrefabData</code>. Each variant is treated in the same way as <code>PrefabData</code> structs.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{PrefabData, ProgressCounter},
</span><span class="boring">    core::Named,
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::{DenseVecStorage, VecStorage},
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[serde(deny_unknown_fields)]
pub struct Position(pub f32, pub f32, pub f32);

#[derive(Clone, Copy, Component, Debug, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[storage(VecStorage)]
pub enum Weapon {
    Axe,
    Sword,
}

/// All fields implement `PrefabData`.
///
/// **Note:** If a field is of type `Option&lt;_&gt;` and not specified in the prefab, it will default
/// to `None`.
#[derive(Debug, Deserialize, Serialize, PrefabData)]
#[serde(deny_unknown_fields)]
pub enum CustomPrefabData {
    Player {
        name: Named,
        position: Option&lt;Position&gt;,
    },
    Weapon {
        weapon_type: Weapon,
        position: Option&lt;Position&gt;,
    },
}

</code></pre>
<p><strong>Note:</strong> There is an important limitation when building <code>PrefabData</code>s, particularly enum <code>PrefabData</code>s. No two fields in the <code>PrefabData</code> or in any nested <code>PrefabData</code>s under it can access the same <code>Component</code> unless all accesses are reads. This is still true even if the fields appear in different variants of an enum. This means that the following <code>PrefabData</code> will fail at runtime when loaded:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{PrefabData, ProgressCounter},
</span><span class="boring">    core::Named,
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::{DenseVecStorage, VecStorage},
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::sprite::prefab::SpriteScenePrefab,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span>
#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[serde(deny_unknown_fields)]
pub struct SpecialPower;

#[derive(Debug, Deserialize, Serialize, PrefabData)]
#[serde(deny_unknown_fields)]
pub enum CustomPrefabData {
    MundaneCreature {
        sprite: SpriteScenePrefab,
    },
    MagicalCreature {
        special_power: SpecialPower,
        sprite: SpriteScenePrefab,
    },
}

</code></pre>
<p>The problem is that both the <code>SpriteScenePrefab</code>s need to write to <code>Transform</code> and several other common <code>Components</code>. Because Amythest's underlyng ECS system determines what resources are accessed based on static types it can't determine that only one of the <code>SpriteScenePrefab</code>s will be accessed at a time and it attempts a double mutable borrow which fails. The solution is to define the <code>PrefabData</code> hierarchically so each component only appears once:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{PrefabData, ProgressCounter},
</span><span class="boring">    core::Named,
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        storage::{DenseVecStorage, VecStorage},
</span><span class="boring">        Component, Entity, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::sprite::prefab::SpriteScenePrefab,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span>
#[derive(Clone, Copy, Component, Debug, Default, Deserialize, Serialize, PrefabData)]
#[prefab(Component)]
#[serde(deny_unknown_fields)]
pub struct SpecialPower;

#[derive(Debug, Deserialize, Serialize, PrefabData)]
#[serde(deny_unknown_fields)]
pub enum CreatureDetailsPrefab {
    MundaneCreature {
    },
    MagicalCreature {
        special_power: SpecialPower,
    },
}
#[derive(Debug, Deserialize, Serialize, PrefabData)]
#[serde(deny_unknown_fields)]
pub struct CustomPrefabData {
    sprite: SpriteScenePrefab,
    creature_details: CreatureDetailsPrefab,
}

</code></pre>
<p>The [<code>PrefabData</code>][api_pf_derive] derive implements the [<code>PrefabData</code>] trait for the type. The generated code will handle invoking the appropriate [<code>PrefabData</code>] methods when loading and attaching components to an entity. <strong>Note:</strong> This differs from the simple component [<code>PrefabData</code>] derive implementation – there is no <code>#[prefab(Component)]</code> attribute.</p>
<p>The [<code>#[serde(default)]</code>] attribute allows fields to not be specified in the prefab, and the fields' default value will be used. If this attribute is not present, then all fields must be specified in the prefab.</p>
<p>Finally, the [<code>#[serde(deny_unknown_fields)]</code>] ensures that deserialization produces an error if it encounters an unknown field. This will help expose mistakes in the prefab file, such as when there is a typo.</p>
</li>
<li>
<p>Now the type can be used in a prefab.</p>
<ul>
<li>
<p><code>struct</code> prefab data:</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        PrefabEntity(
            data: Player(
                name: Named(name: &quot;Zero&quot;),
                position: Position(1.0, 2.0, 3.0),
            ),
        ),
    ],
)
</code></pre>
</li>
<li>
<p><code>enum</code> prefab data:</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        // Player
        PrefabEntity(
            data: Player(
                name: Named(name: &quot;Zero&quot;),
                position: Position(1.0, 2.0, 3.0),
            ),
        ),
        // Weapon
        PrefabEntity(
            parent: 0,
            data: Weapon(
                weapon_type: Sword,
                position: Position(4.0, 5.0, 6.0),
            ),
        ),
    ],
)
</code></pre>
</li>
</ul>
</li>
</ol>
<p>To see this in a complete example, run the [<code>prefab_custom</code> example][repo_prefab_custom] or the [<code>prefab_multi</code> example][repo_prefab_multi] from the Amethyst repository:</p>
<pre><code class="language-bash">cargo run --example prefab_custom # superset prefab
cargo run --example prefab_multi # object prefab
</code></pre>
<p>[<code>#[serde(default)]</code>]: https://serde.rs/container-attrs.html#default
[<code>#[serde(deny_unknown_fields)]</code>]: https://serde.rs/container-attrs.html#deny_unknown_fields
[<code>Component</code>]: https://docs.amethyst.rs/stable/specs/trait.Component.html
[<code>Prefab</code>]: https://docs.amethyst.rs/stable/amethyst_assets/struct.Prefab.html
[<code>PrefabData</code>]: https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E
[api_pf_derive]: https://docs.amethyst.rs/stable/amethyst_derive/derive.PrefabData.html
[bk_prefab_prelude]: how_to_define_prefabs_prelude.html
[repo_prefab_custom]: https://github.com/amethyst/amethyst/tree/master/examples/prefab_custom
[repo_prefab_multi]: https://github.com/amethyst/amethyst/tree/master/examples/prefab_multi</p>
<h1><a class="header" href="#how-to-define-prefabs-adapter" id="how-to-define-prefabs-adapter">How to Define Prefabs: Adapter</a></h1>
<p>This guide explains how to define a [<code>PrefabData</code>] for a [<code>Component</code>] using an intermediate type called an adapter. This pattern is used when there are multiple ways to serialize / construct the [<code>Component</code>]:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::{storage::DenseVecStorage, Component};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Component, Debug, Deserialize, Serialize /* .. */)]
</span><span class="boring">pub struct Position(pub f32, pub f32, pub f32);
</span><span class="boring">
</span>impl From&lt;(i32, i32, i32)&gt; for Position {
    fn from((x, y, z): (i32, i32, i32)) -&gt; Position {
        Position(x as f32, y as f32, z as f32)
    }
}

impl From&lt;(f32, f32, f32)&gt; for Position {
    fn from((x, y, z): (f32, f32, f32)) -&gt; Position {
        Position(x, y, z)
    }
}
</code></pre>
<p>If you are attempting to adapt a more complex type, please choose the appropriate guide from the [available guides][bk_prefab_prelude].</p>
<h2><a class="header" href="#steps-3" id="steps-3">Steps</a></h2>
<ol>
<li>
<p>Ensure your crate has the following dependencies:</p>
<pre><code class="language-toml">[dependencies]
amethyst = &quot;..&quot; # Minimum version 0.10
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
</code></pre>
</li>
<li>
<p>Define the adapter prefab data type.</p>
<p>Create a (de)serializable enum type with a variant for each representation. The following is an example of an adapter type for the [<code>Position</code>] component, which allows either <code>i32</code> or <code>f32</code> values to be specified in the prefab:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span>use amethyst::{
    assets::{PrefabData, ProgressCounter},
    ecs::{Entity, WriteStorage},
    Error,
};
use serde::{Deserialize, Serialize};

#[derive(Clone, Copy, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub enum PositionPrefab {
    Pos3f { x: f32, y: f32, z: f32 },
    Pos3i { x: i32, y: i32, z: i32 },
}
</code></pre>
<p>The [<code>#[serde(deny_unknown_fields)]</code>] ensures that deserialization produces an error if it encounters an unknown field. This will help expose mistakes in the prefab file, such as when there is a typo.</p>
<p><strong>Note:</strong> You may already have a type that captures the multiple representations. For example, for the [<code>Camera</code>] component, the [<code>Projection</code>] enum captures the different representations:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::core::math::{Orthographic3, Perspective3};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span>#[derive(Clone, Deserialize, PartialEq, Serialize)]
pub enum Projection {
    Orthographic(Orthographic3&lt;f32&gt;),
    Perspective(Perspective3&lt;f32&gt;),
}
</code></pre>
</li>
<li>
<p>Implement the [<code>PrefabData</code>] trait for the adapter type.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate serde;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{PrefabData, ProgressCounter},
</span><span class="boring">    ecs::{storage::DenseVecStorage, Component, Entity, WriteStorage},
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">
</span><span class="boring">#[derive(Component, Debug, Deserialize, Serialize /* .. */)]
</span><span class="boring">pub struct Position(pub f32, pub f32, pub f32);
</span><span class="boring">
</span><span class="boring">impl From&lt;(i32, i32, i32)&gt; for Position {
</span><span class="boring">    fn from((x, y, z): (i32, i32, i32)) -&gt; Position {
</span><span class="boring">        Position(x as f32, y as f32, z as f32)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl From&lt;(f32, f32, f32)&gt; for Position {
</span><span class="boring">    fn from((x, y, z): (f32, f32, f32)) -&gt; Position {
</span><span class="boring">        Position(x, y, z)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Deserialize, PartialEq, Serialize)]
</span><span class="boring">#[serde(deny_unknown_fields)]
</span><span class="boring">pub enum PositionPrefab {
</span><span class="boring">    Pos3f { x: f32, y: f32, z: f32 },
</span><span class="boring">    Pos3i { x: i32, y: i32, z: i32 },
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; PrefabData&lt;'a&gt; for PositionPrefab {
    // To attach the `Position` to the constructed entity,
    // we write to the `Position` component storage.
    type SystemData = WriteStorage&lt;'a, Position&gt;;

    // This associated type is not used in this pattern,
    // so the empty tuple is specified.
    type Result = ();

    fn add_to_entity(
        &amp;self,
        entity: Entity,
        positions: &amp;mut Self::SystemData,
        _entities: &amp;[Entity],
        _children: &amp;[Entity],
    ) -&gt; Result&lt;(), Error&gt; {
        let position = match *self {
            PositionPrefab::Pos3f { x, y, z } =&gt; (x, y, z).into(),
            PositionPrefab::Pos3i { x, y, z } =&gt; (x, y, z).into(),
        };
        positions.insert(entity, position).map(|_| ())?;
        Ok(())
    }
}
</code></pre>
</li>
<li>
<p>Now the adapter type can be used in a prefab to attach the component to the entity.</p>
<pre><code class="language-rust ignore">#![enable(implicit_some)]
Prefab(
    entities: [
        PrefabEntity(
            data: Pos3f(x: 1.0, y: 2.0, z: 3.0),
        ),
        PrefabEntity(
            data: Pos3i(x: 4, y: 5, z: 6),
        ),
    ],
)
</code></pre>
</li>
</ol>
<p>To see this in a complete example, run the [<code>prefab_adapter</code> example][repo_prefab_adapter] from the Amethyst repository:</p>
<pre><code class="language-bash">cargo run --example prefab_adapter
</code></pre>
<p>[<code>#[serde(default)]</code>]: https://serde.rs/container-attrs.html#default
[<code>#[serde(deny_unknown_fields)]</code>]: https://serde.rs/container-attrs.html#deny_unknown_fields
[<code>Camera</code>]: https://docs.amethyst.rs/stable/amethyst_renderer/struct.Camera.html
[<code>Component</code>]: https://docs.amethyst.rs/stable/specs/trait.Component.html
[<code>Prefab</code>]: https://docs.amethyst.rs/stable/amethyst_assets/struct.Prefab.html
[<code>PrefabData</code>]: https://docs.amethyst.rs/stable/amethyst_assets/trait.PrefabData.html#impl-PrefabData%3C%27a%3E
[<code>Projection</code>]: https://docs.amethyst.rs/stable/amethyst_renderer/enum.Projection.html
[bk_prefab_prelude]: how_to_define_prefabs_prelude.html
[repo_prefab_adapter]: https://github.com/amethyst/amethyst/tree/master/examples/prefab_adapter</p>
<h1><a class="header" href="#how-to-define-prefabs-asset" id="how-to-define-prefabs-asset">How to Define Prefabs: Asset</a></h1>
<!-- **TODO:** Remember to link `AssetPrefab` -->
<blockquote>
<p><strong>Note:</strong> This guide is not yet written. Please check back later!</p>
<p>If you would like to contribute, please let us know in <a href="https://github.com/amethyst/amethyst/issues/1114">#1114</a></p>
</blockquote>
<h1><a class="header" href="#how-to-define-prefabs-multi-handle" id="how-to-define-prefabs-multi-handle">How to Define Prefabs: Multi-Handle</a></h1>
<blockquote>
<p><strong>Note:</strong> This guide is not yet written. Please check back later!</p>
<p>If you would like to contribute, please let us know in <a href="https://github.com/amethyst/amethyst/issues/1114">#1114</a></p>
</blockquote>
<h1><a class="header" href="#prefabs-technical-explanation" id="prefabs-technical-explanation">Prefabs Technical Explanation</a></h1>
<p>A <code>Prefab</code> in Amethyst is at the core a simple list of future entities, where each entry in
the list consists of two pieces of optional data:</p>
<ul>
<li>a parent index that refers to a different entry in the list</li>
<li>a data collection implementing the trait <code>PrefabData</code></li>
</ul>
<p>To instantiate a <code>Prefab</code>, we put a <code>Handle&lt;Prefab&lt;T&gt;&gt;</code> on an <code>Entity</code>. The <code>Entity</code> we put
the <code>Handle</code> on is referred to as the main <code>Entity</code>, and the first entry in the list inside a
<code>Prefab</code> refers to this <code>Entity</code>. All other entries in the list will spawn a new <code>Entity</code> on
instantiation.</p>
<p>NOTE: This means that we currently cannot target multiple existing entities from a single <code>Prefab</code>.
This restriction is likely to be removed in the future.</p>
<p>The lifetime of a <code>Prefab</code> can roughly be divided into three distinct parts:</p>
<p><strong>Loading</strong></p>
<p>This is the same as for all assets in Amethyst, the user initiates a load using <code>Loader</code>, a
<code>Source</code> and a <code>Format</code>. The <code>Format</code> returns a <code>Prefab</code>, and the user is handed a <code>Handle&lt;Prefab&lt;T&gt;&gt;</code>,
for some <code>T</code> that implements <code>PrefabData</code>.</p>
<p><strong>Sub asset loading</strong></p>
<p>A <code>PrefabData</code> implementation could refer to other assets that need to be loaded asynchronously, and
we don't want the user get a <code>Complete</code> notification on their <code>Progress</code> before everything has been
loaded.</p>
<p>Because of this, once the <code>Format</code> have loaded the <code>Prefab</code> from the <code>Source</code>, and a <code>PrefabLoaderSystem</code>
runs <code>process</code> on the <code>AssetStorage</code>, the system will invoke the <code>load_sub_assets</code> function on the
<code>PrefabData</code> implementation. If any asset loads are triggered during this, they must adhere to the following
rules:</p>
<ul>
<li>the given <code>ProgressCounter</code> must be used as a parameter to the load function on <code>Loader</code>, so load tracking
works correctly</li>
<li>the function must return <code>Ok(true)</code> (unless an <code>Error</code> occurred)</li>
</ul>
<p>Note that during this phase the <code>PrefabData</code> is mutable, which means it can morph inside the <code>Prefab</code>. An
example of this is the <code>AssetPrefab</code>, which will morph into <code>AssetPrefab::Handle</code>.</p>
<p>Once all sub asset loading is finished, which the <code>PrefabLoaderSystem</code> will track using the <code>ProgressCounter</code>,
a <code>Complete</code> signal will be sent upwards.</p>
<p><strong>Prefab instantiation</strong></p>
<p>This stage happens after the <code>Prefab</code> has been fully loaded and <code>Complete</code> has been signaled, and the
<code>Handle&lt;Prefab&lt;T&gt;&gt;</code> is put on an <code>Entity</code>. At this point we know that all internal data has been loaded,
and all sub assets have been processed. The <code>PrefabLoaderSystem</code> will then walk through the <code>Prefab</code> data
immutably and create a new <code>Entity</code> for all but the first entry in the list, and then for each instance
of <code>PrefabData</code> call the <code>add_to_entity</code> function.</p>
<p>Note that for prefabs that reference other prefabs, to make instantiation be performed inside a single frame,
lower level <code>PrefabLoaderSystem</code>s need to depend on the higher level ones. To see how this works out check the gltf
example, where we have a scene prefab, and the gltf loader (which use the prefab system internally).</p>
<h2><a class="header" href="#prefabdata" id="prefabdata"><code>PrefabData</code></a></h2>
<p>Ok, so what would a simple implementation of <code>PrefabData</code> look like?</p>
<p>Let's take a look at the implementation for <code>Transform</code>, which is a core concept in Amethyst:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::PrefabData;
</span><span class="boring">use amethyst::ecs::{WriteStorage, Entity, Component, NullStorage};
</span><span class="boring">use amethyst::Error;
</span><span class="boring">
</span><span class="boring">// We declare that struct for the sake of automated testing.
</span><span class="boring">#[derive(Default, Clone)]
</span><span class="boring">struct Transform;
</span><span class="boring">impl Component for Transform {
</span><span class="boring">  type Storage = NullStorage&lt;Transform&gt;;
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; PrefabData&lt;'a&gt; for Transform {
    type SystemData = WriteStorage&lt;'a, Transform&gt;;
    type Result = ();

    fn add_to_entity(
        &amp;self,
        entity: Entity,
        storage: &amp;mut Self::SystemData,
        _: &amp;[Entity],
        _: &amp;[Entity],
    ) -&gt; Result&lt;(), Error&gt; {
        storage.insert(entity, self.clone()).map(|_| ()).map_err(Into::into)
    }
}
</code></pre>
<p>First, we specify a <code>SystemData</code> type, this is the data required from <code>World</code> in order to load and
instantiate this <code>PrefabData</code>. Here we only need to write to <code>Transform</code>.</p>
<p>Second, we specify what result the <code>add_to_entity</code> function returns. In our case this is unit <code>()</code>, for
other implementations it could return a <code>Handle</code> etc. For an example of this, look at the <code>TexturePrefab</code>
in the renderer crate.</p>
<p>Next, we define the <code>add_to_entity</code> function, which is used to actually instantiate data. In our case here,
we insert the local <code>Transform</code> data on the referenced <code>Entity</code>. In this scenario we aren't using the third
parameter to the function. This parameter contains a list of all entities affected by the <code>Prefab</code>, the first
entry in the list will be the main <code>Entity</code>, and the rest will be the entities that were created for all the
entries in the data list inside the <code>Prefab</code>.</p>
<p>Last of all, we can see that this does not implement <code>load_sub_assets</code>, which is because there
are no secondary assets to load from <code>Source</code> here.</p>
<p>Let's look at a slightly more complex implementation, the <code>AssetPrefab</code>. This <code>PrefabData</code> is used to
load extra <code>Asset</code>s as part of a <code>Prefab</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">#[macro_use] extern crate serde_derive;
</span><span class="boring">use amethyst::assets::{Asset, AssetStorage, Loader, Format, Handle, ProgressCounter};
</span><span class="boring">use amethyst::assets::PrefabData;
</span><span class="boring">use amethyst::ecs::{WriteStorage, ReadExpect, Read, Entity};
</span><span class="boring">use amethyst::Error;
</span><span class="boring">
</span>#[derive(Deserialize, Serialize)]
pub enum AssetPrefab&lt;A, F&gt;
where
    A: Asset,
    F: Format&lt;A::Data&gt;,
{
    /// From existing handle
    #[serde(skip)]
    Handle(Handle&lt;A&gt;),

    /// From file, (name, format, format options)
    File(String, F),
}

impl&lt;'a, A, F&gt; PrefabData&lt;'a&gt; for AssetPrefab&lt;A, F&gt;
where
    A: Asset,
    F: Format&lt;A::Data&gt; + Clone,
{
    type SystemData = (
        ReadExpect&lt;'a, Loader&gt;,
        WriteStorage&lt;'a, Handle&lt;A&gt;&gt;,
        Read&lt;'a, AssetStorage&lt;A&gt;&gt;,
    );

    type Result = Handle&lt;A&gt;;

    fn add_to_entity(
        &amp;self,
        entity: Entity,
        system_data: &amp;mut Self::SystemData,
        _: &amp;[Entity],
        _: &amp;[Entity],
    ) -&gt; Result&lt;Handle&lt;A&gt;, Error&gt; {
        let handle = match *self {
            AssetPrefab::Handle(ref handle) =&gt; handle.clone(),
            AssetPrefab::File(ref name, ref format) =&gt; system_data.0.load(
                name.as_str(),
                format.clone(),
                (),
                &amp;system_data.2,
            ),
        };
        Ok(system_data.1.insert(entity, handle.clone())?.unwrap())
    }

    fn load_sub_assets(
        &amp;mut self,
        progress: &amp;mut ProgressCounter,
        system_data: &amp;mut Self::SystemData,
    ) -&gt; Result&lt;bool, Error&gt; {
        let handle = match *self {
            AssetPrefab::File(ref name, ref format) =&gt; Some(system_data.0.load(
                name.as_str(),
                format.clone(),
                progress,
                &amp;system_data.2,
            )),
            _ =&gt; None,
        };
        if let Some(handle) = handle {
            *self = AssetPrefab::Handle(handle);
        }
        Ok(true)
    }
}
</code></pre>
<p>So, there are two main differences to this <code>PrefabData</code> compared the <code>Transform</code> example.
The first difference is that the <code>add_to_entity</code> function now return a <code>Handle&lt;A&gt;</code>.
The second difference is that <code>load_sub_assets</code> is implemented, this is because we load
a sub asset. The <code>load_sub_assets</code> function here will do the actual loading, and morph the
internal representation to the <code>AssetPrefab::Handle</code> variant, so when <code>add_to_entity</code> runs later
it will straight up use the internally stored <code>Handle</code>.</p>
<h3><a class="header" href="#special-prefabdata-implementations" id="special-prefabdata-implementations">Special <code>PrefabData</code> implementations</a></h3>
<p>There are a few special blanket implementations provided by the asset system:</p>
<ul>
<li><code>Option&lt;T&gt;</code> for all <code>T: PrefabData</code>.</li>
<li>Tuples of types that implemented <code>PrefabData</code>, up to a size of 20.</li>
</ul>
<h3><a class="header" href="#deriving-prefabdata-implementations" id="deriving-prefabdata-implementations">Deriving <code>PrefabData</code> implementations</a></h3>
<p>Amethyst supplies a derive macro for creating the <code>PrefabData</code> implementation for the following scenarios:</p>
<ul>
<li>Single <code>Component</code></li>
<li>Aggregate <code>PrefabData</code> structs or enums which contain other <code>PrefabData</code> constructs, and optionally simple data <code>Component</code>s</li>
</ul>
<p>In addition, deriving a <code>Prefab</code> requires that <code>amethyst::Error</code>, <code>amethyst::ecs::Entity</code> and
<code>amethyst:assets::{PrefabData, ProgressCounter}</code> are imported
and visible in the current scope. This is due to how Rust macros work.</p>
<p>An example of a single <code>Component</code> derive:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#[macro_use] extern crate amethyst;
</span><span class="boring">#[macro_use] extern crate serde_derive;
</span><span class="boring">use amethyst::{
</span><span class="boring">    assets::{
</span><span class="boring">        Asset, AssetStorage, Loader, Format, Handle, ProgressCounter, PrefabData
</span><span class="boring">    },
</span><span class="boring">    derive::PrefabData,
</span><span class="boring">    ecs::{
</span><span class="boring">        Component, DenseVecStorage, Entity, Read, ReadExpect, WriteStorage,
</span><span class="boring">    },
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(Clone, PrefabData)]
#[prefab(Component)]
pub struct SomeComponent {
    pub id: u64,
}

impl Component for SomeComponent {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>This will derive a <code>PrefabData</code> implementation that inserts <code>SomeComponent</code> on an <code>Entity</code> in the <code>World</code>.</p>
<p>Lets look at an example of an aggregate struct:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#[macro_use] extern crate amethyst;
</span><span class="boring">#[macro_use] extern crate serde_derive;
</span><span class="boring">use amethyst::assets::{Asset, AssetStorage, Loader, Format, Handle, ProgressCounter, PrefabData, AssetPrefab};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">use amethyst::ecs::{WriteStorage, ReadExpect, Read, Entity, DenseVecStorage, Component};
</span><span class="boring">use amethyst::renderer::{Mesh, formats::mesh::ObjFormat};
</span><span class="boring">use amethyst::Error;
</span>
#[derive(PrefabData)]
pub struct MyScenePrefab {
    mesh: AssetPrefab&lt;Mesh, ObjFormat&gt;,
    transform: Transform,
}
</code></pre>
<p>This can now be used to create <code>Prefab</code>s with <code>Transform</code> and <code>Mesh</code> on entities.</p>
<p>One last example that also adds a custom pure data <code>Component</code> into the aggregate <code>PrefabData</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#[macro_use] extern crate amethyst;
</span><span class="boring">#[macro_use] extern crate serde_derive;
</span><span class="boring">use amethyst::assets::{Asset, AssetStorage, Loader, Format, Handle, ProgressCounter, PrefabData, AssetPrefab};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">use amethyst::ecs::{WriteStorage, ReadExpect, Read, Entity, DenseVecStorage, Component};
</span><span class="boring">use amethyst::renderer::{Mesh, formats::mesh::ObjFormat};
</span><span class="boring">use amethyst::Error;
</span>
#[derive(PrefabData)]
pub struct MyScenePrefab {
    mesh: AssetPrefab&lt;Mesh, ObjFormat&gt;,
    transform: Transform,

    #[prefab(Component)]
    some: SomeComponent,
}

#[derive(Clone)]
pub struct SomeComponent {
    pub id: u64,
}

impl Component for SomeComponent {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>You might notice here that <code>SomeComponent</code> has no <code>PrefabData</code> derive on its own, it is simply
used directly in the aggregate <code>PrefabData</code>, and annotated so the derive knows to do a simple
<code>WriteStorage</code> insert.</p>
<h2><a class="header" href="#working-with-prefabs" id="working-with-prefabs">Working with <code>Prefab</code>s</a></h2>
<p>So now we know how the <code>Prefab</code> system works on the inside, but how do we use it?</p>
<p>From the point of the user, there are a few parts to using a <code>Prefab</code>:</p>
<ul>
<li>Loading it, using <code>Loader</code> + <code>AssetStorage</code>, or using the helper <code>PrefabLoader</code>, which is a
simple wrapper around the former. For this to work we need a <code>Format</code> that returns <code>Prefab</code>s.</li>
<li>Managing the returned <code>Handle&lt;Prefab&lt;T&gt;&gt;</code>.</li>
<li>Waiting for the <code>Prefab</code> to be fully loaded, using <code>Progress</code>.</li>
<li>Requesting instantiation by placing the <code>Handle&lt;Prefab&lt;T&gt;&gt;</code> on an <code>Entity</code> in the <code>World</code>.</li>
</ul>
<h2><a class="header" href="#prefab-formats" id="prefab-formats"><code>Prefab</code> formats</a></h2>
<p>There are a few provided formats that create <code>Prefab</code>s, some with very specific <code>PrefabData</code>, and
two that are generic:</p>
<ul>
<li><code>RonFormat</code> - this format can be used to load <code>Prefab</code>s in <code>ron</code> format with any <code>PrefabData</code>
that also implements <code>serde::Deserialize</code>.</li>
<li><code>JsonFormat</code> - this format can be used to load <code>Prefab</code>s in <code>Json</code> format with any <code>PrefabData</code>
that also implements <code>serde::Deserialize</code>. It can be enabled with the <code>json</code> feature flag.</li>
<li><code>GltfSceneFormat</code> - used to load <code>Gltf</code> files</li>
<li><code>UiFormat</code> - used to load UI components in a specialised DSL format.</li>
</ul>
<p>For an example of a <code>Prefab</code> in <code>ron</code> format, look at <code>examples/assets/prefab/example.ron</code>. The
<code>PrefabData</code> for this is:</p>
<pre><code class="language-rust ignore">(
    Option&lt;GraphicsPrefab&lt;ObjFormat, TextureFormat&gt;&gt;,
    Option&lt;Transform&gt;,
    Option&lt;Light&gt;,
    Option&lt;CameraPrefab&gt;,
)
</code></pre>
<p>For a more advanced example, and also a custom <code>PrefabData</code> implementation, look at the <code>gltf</code> example
and <code>examples/assets/prefab/puffy_scene.ron</code>.</p>
<h1><a class="header" href="#animation" id="animation">Animation</a></h1>
<p>Animation in computer graphics can be viewed as controlled mutation of attributes of objects 
over time, using a predefined function. Examples of this are:</p>
<ul>
<li>Changing coordinates of vertices — movement, scaling up or down</li>
<li>Changing the hue of a texture — for a &quot;power up&quot; effect</li>
</ul>
<p>To determine the values each attribute should have at a particular point in time, we define 
a set of known values at certain points in the animation — called key frames — 
and a function to interpolate the value for the attribute.</p>
<p>This section will guide you in learning how to make use of the animation functionality in Amethyst.</p>
<h1><a class="header" href="#interpolation" id="interpolation">Interpolation</a></h1>
<p>Interpolation is the calculation of an attribute value that lies in between two key frames.</p>
<p>For example, if an object should move in a circle, then we can define an animation that mutates
its X and Y coordinate attributes.</p>
<p>The animation definition can represent this using 5 key frames:</p>
<table><thead><tr><th>Key Frame #</th><th>X coordinate</th><th>Y coordinate</th></tr></thead><tbody>
<tr><td>0</td><td>0.0</td><td>1.0</td></tr>
<tr><td>1</td><td>1.0</td><td>0.0</td></tr>
<tr><td>2</td><td>0.0</td><td>-1.0</td></tr>
<tr><td>3</td><td>-1.0</td><td>0.0</td></tr>
<tr><td>4</td><td>0.0</td><td>1.0</td></tr>
</tbody></table>
<h2><a class="header" href="#non-interpolation" id="non-interpolation">Non-interpolation</a></h2>
<p>For a perfect circle, the values in between the key frames can be calculated by the <code>sin(..)</code>
function for the X coordinate, and the <code>cos(..)</code> function for the Y coordinate. So, if we 
were trying to calculate what the coordinates should be when <code>t = 0.5</code>, we could go <code>sin( 0.5 * π )</code>.</p>
<p>However, what if we <strong>do not</strong> have such perfect coordinate control, and we only have 
the values at the specified key frames?</p>
<h2><a class="header" href="#interpolation-1" id="interpolation-1">Interpolation</a></h2>
<p>To move in a circle, the X coordinate first increases with a larger step, and the step size
decreases as it approaches the circle boundary on the X axis, where it then flips, and 
increases in the negative direction. For the Y coordinate, the magnitude of the step 
size increases downwards, then decreases once it has gotten past the halfway point.</p>
<p>The changing step size means, given the first two key frames, 0 and 1, the values do 
not change in constant step increments — <em>linear</em>ly (<a href="https://en.wikipedia.org/wiki/Linear_interpolation">LERP</a>) —, 
but <em>spherical linear</em>ly (<a href="https://en.wikipedia.org/wiki/Slerp">SLERP</a>).</p>
<p>The spherical linear function is a way of saying, given these two key frame values, 
and some proportion of time between the two key frames, what should the actual value 
be given that the step increments change as they would on a sphere?</p>
<h2><a class="header" href="#interpolation-functions" id="interpolation-functions">Interpolation Functions</a></h2>
<p>In computer graphics, there are a number of methods commonly used to calculate the interpolated
values. The following functions are available in Amethyst, implemented by the 
<a href="https://crates.io/crates/minterpolate"><code>minterpolate</code></a> library, namely:</p>
<ul>
<li>Linear</li>
<li>SphericalLinear</li>
<li>Step</li>
<li>CatmullRomSpline</li>
<li>CubicSpline</li>
</ul>
<p>Amethyst also allows you to specify your own custom interpolation function.</p>
<h1><a class="header" href="#channel" id="channel">Channel</a></h1>
<p>An independent grouping or type of functions that operate on attributes of a component.</p>
<p>Some attributes may be mutated by different functions. These functions can be independent of each other, or they may also be dependent each other. An example of these are translation, scaling, and rotation.</p>
<p>Given the following functions are part of the same animation:</p>
<ul>
<li>Translate the object to the right</li>
<li>Translate the object upwards</li>
<li>Scale the object up</li>
</ul>
<p>We want to be able to individually apply related functions, i.e. &quot;apply all translations&quot;, &quot;apply all scalings&quot;, and &quot;apply all rotations&quot;. Each of these groupings is called a <strong>channel</strong>.</p>
<h1><a class="header" href="#sampler" id="sampler">Sampler</a></h1>
<p>In Amethyst, a <code>Sampler</code> is the lowest level working block of an animation. It defines the interpolation function, and what attribute or set of attributes the function mutates.</p>
<p>The <code>input</code> holds the timing of the key frames. The <code>output</code> holds the values used in the interpolation function for each of the key frames.</p>
<p>You can imagine the interpolation function as <code>fn(Time) -&gt; ChannelValue</code></p>
<h1><a class="header" href="#definition" id="definition">Definition</a></h1>
<p>Animations can be defined for objects made of a single entity, or complex objects made up of multiple entities.</p>
<p>Right now we do not have a tutorial for defining an animation from scratch, but take a look at the following resources to get an idea of how to write one:</p>
<ul>
<li><a href="https://github.com/amethyst/amethyst/tree/master/examples/animation">animation example</a></li>
<li><a href="https://github.com/amethyst/amethyst/tree/master/examples/gltf">gltf example</a></li>
<li><a href="https://github.com/amethyst/amethyst/tree/master/examples/sprite_animation">sprite animation example</a></li>
<li><a href="https://docs.amethyst.rs/stable/amethyst_animation/">API docs</a></li>
</ul>
<h1><a class="header" href="#controlling-system-execution" id="controlling-system-execution">Controlling System Execution</a></h1>
<p>When writing a game you'll eventually reach a point where you want to have more control over when certain <code>System</code>s are executed, such as running them for specific <code>State</code>s or pausing them when a certain condition is met. Right now you have these three options to achieve said control:</p>
<ul>
<li>
<p><strong>Custom GameData:</strong></p>
<p>Store multiple <code>Dispatcher</code>s in a custom <code>GameData</code>. Each <code>Dispatcher</code> has its own assigned <code>System</code>s and <code>State</code>s determines which <code>Dispatcher</code>s to run.</p>
</li>
<li>
<p><strong>State-specific Dispatcher:</strong></p>
<p>A <code>State</code> contains its own <code>Dispatcher</code> with its own <code>System</code>s and the <code>State</code> handles the execution.</p>
</li>
<li>
<p><strong>Pausable Systems:</strong></p>
<p>When registering a <code>System</code> with a <code>Dispatcher</code>, specify the value of a <code>Resource</code> <code>R</code>. The <code>System</code> runs only if the <code>Resource</code> equals that value. This allows for more selective enabling and disabling of <code>System</code>s.</p>
</li>
</ul>
<p>This section contains guides that demonstrate each of these methods.</p>
<h1><a class="header" href="#custom-gamedata" id="custom-gamedata">Custom <code>GameData</code></a></h1>
<p>So far we've been using the <code>Amethyst</code> supplied <code>GameData</code> struct to handle
our <code>System</code>s. This works well for smaller games and demos, but once we
start building a larger game, we will quickly realise we need to 
manipulate the <code>System</code> dispatch based on game <code>State</code>, or we need to pass
data between <code>State</code>s that aren't <code>Send + Sync</code> which can't be added to <code>World</code>.</p>
<p>The solution to our troubles here is to create a custom <code>GameData</code> structure 
to house what we need that can not be added to <code>World</code>.</p>
<p>In this tutorial we will look at how one could structure a <code>Paused</code> <code>State</code>, 
which disables the game logic, only leaving a few core systems running that 
are essential (like rendering, input and UI).</p>
<p>Let's start by creating the <code>GameData</code> structure:</p>
<pre><code class="language-rust no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::prelude::Dispatcher;
</span><span class="boring">
</span>pub struct CustomGameData&lt;'a, 'b&gt; {
    core_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
    running_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
}
</code></pre>
<p>We also add a utility function for performing dispatch:</p>
<pre><code class="language-rust no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::prelude::{Dispatcher, World};
</span><span class="boring">
</span><span class="boring">pub struct CustomGameData&lt;'a, 'b&gt; {
</span><span class="boring">    core_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">    running_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a, 'b&gt; CustomGameData&lt;'a, 'b&gt; {
    /// Update game data
    pub fn update(&amp;mut self, world: &amp;World, running: bool) {
        if running {
            if let Some(dispatcher) = self.running_dispatcher.as_mut() {
                dispatcher.dispatch(&amp;world);
            }
        }
        if let Some(dispatcher) = self.core_dispatcher.as_mut() {
            dispatcher.dispatch(&amp;world);
        }
    }
}
</code></pre>
<p>To be able to use this structure with <code>Amethyst</code>s <code>Application</code> we need to create
a builder that implements <code>DataInit</code>, as well as implement <code>DataDispose</code> for our
<code>GameData</code> structure. These are the only requirements placed on the
<code>GameData</code> structure.</p>
<pre><code class="language-rust no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::prelude::{Dispatcher, DispatcherBuilder, System, World, WorldExt};
</span><span class="boring">use amethyst::core::SystemBundle;
</span><span class="boring">use amethyst::{Error, DataInit, DataDispose};
</span><span class="boring">
</span><span class="boring">pub struct CustomGameData&lt;'a, 'b&gt; {
</span><span class="boring">    core_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">    running_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::core::ArcThreadPool;

pub struct CustomGameDataBuilder&lt;'a, 'b&gt; {
    pub core: DispatcherBuilder&lt;'a, 'b&gt;,
    pub running: DispatcherBuilder&lt;'a, 'b&gt;,
}

impl&lt;'a, 'b&gt; Default for CustomGameDataBuilder&lt;'a, 'b&gt; {
    fn default() -&gt; Self {
        CustomGameDataBuilder::new()
    }
}

impl&lt;'a, 'b&gt; CustomGameDataBuilder&lt;'a, 'b&gt; {
    pub fn new() -&gt; Self {
        CustomGameDataBuilder {
            core: DispatcherBuilder::new(),
            running: DispatcherBuilder::new(),
        }
    }

    pub fn with_base_bundle&lt;B&gt;(mut self, world: &amp;mut World, bundle: B) -&gt; Result&lt;Self, Error&gt;
    where
        B: SystemBundle&lt;'a, 'b&gt;,
    {
        bundle.build(world, &amp;mut self.core)?;
        Ok(self)
    }

    pub fn with_running&lt;S&gt;(mut self, system: S, name: &amp;str, dependencies: &amp;[&amp;str]) -&gt; Self
    where
        for&lt;'c&gt; S: System&lt;'c&gt; + Send + 'a,
    {
        self.running.add(system, name, dependencies);
        self
    }
}

impl&lt;'a, 'b&gt; DataInit&lt;CustomGameData&lt;'a, 'b&gt;&gt; for CustomGameDataBuilder&lt;'a, 'b&gt; {
    fn build(self, world: &amp;mut World) -&gt; CustomGameData&lt;'a, 'b&gt; {
        // Get a handle to the `ThreadPool`.
        let pool = (*world.read_resource::&lt;ArcThreadPool&gt;()).clone();

        let mut core_dispatcher = self.core.with_pool(pool.clone()).build();
        let mut running_dispatcher = self.running.with_pool(pool.clone()).build();
        core_dispatcher.setup(world);
        running_dispatcher.setup(world);

        let core_dispatcher = Some(core_dispatcher);
        let running_dispatcher = Some(running_dispatcher);

        CustomGameData { core_dispatcher, running_dispatcher }
    }
}

impl&lt;'a,'b&gt; DataDispose for CustomGameData&lt;'a,'b&gt; {
    // We dispose each dispatcher owned by the `CustomGameData` structure.
    fn dispose(&amp;mut self, world: &amp;mut World) {
        if let Some(dispatcher) = self.core_dispatcher.take() {
            dispatcher.dispose(world);
        }
        if let Some(dispatcher) = self.running_dispatcher.take() {
            dispatcher.dispose(world);
        }
    }
}
</code></pre>
<p>We can now use <code>CustomGameData</code> in place of the provided <code>GameData</code> when building
our <code>Application</code>, but first we should create some <code>State</code>s.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::ecs::prelude::{Dispatcher, World};
</span><span class="boring">use amethyst::prelude::{State, StateData, StateEvent, Trans};
</span><span class="boring">use amethyst::input::{is_close_requested, is_key_down, VirtualKeyCode};
</span><span class="boring">
</span><span class="boring">pub struct CustomGameData&lt;'a, 'b&gt; {
</span><span class="boring">    core_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">    running_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b&gt; CustomGameData&lt;'a, 'b&gt; {
</span><span class="boring">    /// Update game data
</span><span class="boring">    pub fn update(&amp;mut self, world: &amp;World, running: bool) {
</span><span class="boring">        if running {
</span><span class="boring">            if let Some(dispatcher) = self.running_dispatcher.as_mut() {
</span><span class="boring">                  dispatcher.dispatch(&amp;world);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        if let Some(dispatcher) = self.core_dispatcher.as_mut() {
</span><span class="boring">              dispatcher.dispatch(&amp;world);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn initialise(world: &amp;World) {}
</span><span class="boring">fn create_paused_ui(world: &amp;World) {}
</span><span class="boring">fn delete_paused_ui(world: &amp;World) {}
</span><span class="boring">
</span>struct Main;
struct Paused;

impl&lt;'a, 'b&gt; State&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; for Paused {
    fn on_start(&amp;mut self, data: StateData&lt;CustomGameData&gt;) {
        create_paused_ui(data.world);
    }

    fn handle_event(
        &amp;mut self,
        data: StateData&lt;CustomGameData&gt;,
        event: StateEvent,
    ) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        if let StateEvent::Window(event) = &amp;event {
            if is_close_requested(&amp;event) || is_key_down(&amp;event, VirtualKeyCode::Escape) {
                Trans::Quit
            } else if is_key_down(&amp;event, VirtualKeyCode::Space) {
                delete_paused_ui(data.world);
                Trans::Pop
            } else {
                Trans::None
            }
        } else {
            Trans::None
        }
    }

    fn update(&amp;mut self, data: StateData&lt;CustomGameData&gt;) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        data.data.update(&amp;data.world, false); // false to say we should not dispatch running
        Trans::None
    }
}

impl&lt;'a, 'b&gt; State&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; for Main {
    fn on_start(&amp;mut self, data: StateData&lt;CustomGameData&gt;) {
        initialise(data.world);
    }

    fn handle_event(
        &amp;mut self,
        _: StateData&lt;CustomGameData&gt;,
        event: StateEvent,
    ) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        if let StateEvent::Window(event) = &amp;event {
            if is_close_requested(&amp;event) || is_key_down(&amp;event, VirtualKeyCode::Escape) {
                Trans::Quit
            } else if is_key_down(&amp;event, VirtualKeyCode::Space) {
                Trans::Push(Box::new(Paused))
            } else {
                Trans::None
            }
        } else {
            Trans::None
        }
    }

    fn update(&amp;mut self, data: StateData&lt;CustomGameData&gt;) -&gt; Trans&lt;CustomGameData&lt;'a, 'b&gt;, StateEvent&gt; {
        data.data.update(&amp;data.world, true); // true to say we should dispatch running
        Trans::None
    }
}
</code></pre>
<p>The only thing that remains now is to use our <code>CustomGameDataBuilder</code> when building the
<code>Application</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    core::{transform::TransformBundle, SystemBundle},
</span><span class="boring">    ecs::{Dispatcher, DispatcherBuilder, World, WorldExt},
</span><span class="boring">    input::{InputBundle, StringBindings},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{
</span><span class="boring">        plugins::{RenderFlat2D, RenderToWindow},
</span><span class="boring">        types::DefaultBackend,
</span><span class="boring">        RenderingBundle,
</span><span class="boring">    },
</span><span class="boring">    ui::{RenderUi, UiBundle},
</span><span class="boring">    utils::application_root_dir,
</span><span class="boring">    DataInit, Error, DataDispose,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct CustomGameData&lt;'a, 'b&gt; {
</span><span class="boring">    core_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">    running_dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct CustomGameDataBuilder&lt;'a, 'b&gt; {
</span><span class="boring">    pub core: DispatcherBuilder&lt;'a, 'b&gt;,
</span><span class="boring">    pub running: DispatcherBuilder&lt;'a, 'b&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b&gt; Default for CustomGameDataBuilder&lt;'a, 'b&gt; {
</span><span class="boring">    fn default() -&gt; Self { unimplemented!() }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b&gt; CustomGameDataBuilder&lt;'a, 'b&gt; {
</span><span class="boring">    pub fn new() -&gt; Self { unimplemented!() }
</span><span class="boring">    pub fn with_base_bundle&lt;B&gt;(mut self, world: &amp;mut World, bundle: B) -&gt; Result&lt;Self, Error&gt;
</span><span class="boring">    where
</span><span class="boring">        B: SystemBundle&lt;'a, 'b&gt;,
</span><span class="boring">    {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn with_running&lt;S&gt;(mut self, system: S, name: &amp;str, dependencies: &amp;[&amp;str]) -&gt; Self
</span><span class="boring">    where
</span><span class="boring">        for&lt;'c&gt; S: System&lt;'c&gt; + Send + 'a,
</span><span class="boring">    {
</span><span class="boring">        unimplemented!()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b&gt; DataInit&lt;CustomGameData&lt;'a, 'b&gt;&gt; for CustomGameDataBuilder&lt;'a, 'b&gt; {
</span><span class="boring">    fn build(self, world: &amp;mut World) -&gt; CustomGameData&lt;'a, 'b&gt; { unimplemented!() }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b&gt; DataDispose for CustomGameDataBuilder&lt;'a, 'b&gt; {
</span><span class="boring">    fn dispose(&amp;mut self, world: &amp;mut World) { unimplemented!() }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">
</span>let mut app_builder = Application::build(assets_directory, Main)?;
let game_data = CustomGameDataBuilder::default()
    .with_running(ExampleSystem, &quot;example_system&quot;, &amp;[])
    .with_base_bundle(
        &amp;mut app_builder.world,
        RenderingBundle::&lt;DefaultBackend&gt;::new()
            // The RenderToWindow plugin provides all the scaffolding for opening a window and
            // drawing on it
            .with_plugin(
                RenderToWindow::from_config_path(display_config_path)
                    .with_clear([0.34, 0.36, 0.52, 1.0]),
            )
            .with_plugin(RenderFlat2D::default())
            .with_plugin(RenderUi::default()),
    )?
    .with_base_bundle(&amp;mut app_builder.world, TransformBundle::new())?
    .with_base_bundle(&amp;mut app_builder.world, UiBundle::&lt;StringBindings&gt;::new())?
    .with_base_bundle(
        &amp;mut app_builder.world,
        InputBundle::&lt;StringBindings&gt;::new().with_bindings_from_file(key_bindings_path)?,
    )?;

let mut game = app_builder.build(game_data)?;
game.run();
<span class="boring">
</span><span class="boring">}
</span></code></pre>
<p>Those are the basics of creating a custom <code>GameData</code> structure. Now get out there and
build your game!</p>
<h1><a class="header" href="#how-to-define-state-dispatcher" id="how-to-define-state-dispatcher">How to Define State Dispatcher</a></h1>
<p>This guide explains how to define a state-specific <code>Dispatcher</code> whose <code>System</code>s are only executed within the context of a defined <code>State</code>. </p>
<p>First of all we required a <code>DispatcherBuilder</code>. The <code>DispatcherBuilder</code> handles the actual creation of the <code>Dispatcher</code> and the assignment of <code>System</code>s to our <code>Dispatcher</code>. </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span>let mut dispatcher_builder = DispatcherBuilder::new();
</code></pre>
<p>To add <code>System</code>s to the <code>DispatcherBuilder</code> we use a similar syntax to the one we used to add <code>System</code>s to <code>GameData</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct MoveBallsSystem; struct MovePaddlesSystem;
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MoveBallsSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {} }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MovePaddlesSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {} }
</span>let mut dispatcher_builder = DispatcherBuilder::new();

dispatcher_builder.add(MoveBallsSystem, &quot;move_balls_system&quot;, &amp;[]);
dispatcher_builder.add(MovePaddlesSystem, &quot;move_paddles_system&quot;, &amp;[]);
</code></pre>
<p>Alternatively we can add <code>Bundle</code>s of <code>System</code>s to our <code>DispatcherBuilder</code> directly.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    core::bundle::SystemBundle,
</span><span class="boring">    ecs::{DispatcherBuilder, World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">#[derive(Default)] struct PongSystemsBundle;
</span><span class="boring">impl&lt;'a, 'b&gt; SystemBundle&lt;'a, 'b&gt; for PongSystemsBundle {
</span><span class="boring">    fn build(self, _: &amp;mut World, _: &amp;mut DispatcherBuilder&lt;'a, 'b&gt;) -&gt; Result&lt;(), amethyst::Error&gt; {
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let mut world = World::new();
</span>let mut dispatcher_builder = DispatcherBuilder::new();

PongSystemsBundle::default()
    .build(&amp;mut world, &amp;mut dispatcher_builder)
    .expect(&quot;Failed to register PongSystemsBundle&quot;);
</code></pre>
<p>The <code>DispatcherBuilder</code> can be initialized and populated wherever desired, be it inside the <code>State</code> or in an external location. However, the <code>Dispatcher</code> needs to modify the <code>World</code>s resources in order to initialize the resources used by its <code>System</code>s. Therefore, we need to defer building the <code>Dispatcher</code> until we can access the <code>World</code>. This is commonly done in the <code>State</code>s <code>on_start</code> method. To showcase how this is done, we'll create a <code>SimpleState</code> with a <code>dispatcher</code> field and a <code>on_start</code> method that builds the <code>Dispatcher</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">    core::ArcThreadPool,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct MoveBallsSystem; struct MovePaddlesSystem;
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MoveBallsSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {} }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MovePaddlesSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {} }
</span><span class="boring">
</span>#[derive(Default)]
pub struct CustomState&lt;'a, 'b&gt; {
    /// The `State` specific `Dispatcher`, containing `System`s only relevant for this `State`.
    dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
}

impl&lt;'a, 'b&gt; SimpleState for CustomState&lt;'a, 'b&gt; {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = &amp;mut data.world;
        
        // Create the `DispatcherBuilder` and register some `System`s that should only run for this `State`.
        let mut dispatcher_builder = DispatcherBuilder::new();
        dispatcher_builder.add(MoveBallsSystem, &quot;move_balls_system&quot;, &amp;[]);
        dispatcher_builder.add(MovePaddlesSystem, &quot;move_paddles_system&quot;, &amp;[]);

        // Build and setup the `Dispatcher`.
        let mut dispatcher = dispatcher_builder
            .with_pool((*world.read_resource::&lt;ArcThreadPool&gt;()).clone())
            .build();
        dispatcher.setup(world);

        self.dispatcher = Some(dispatcher);
    }
}
</code></pre>
<p>By default, the dispatcher will create its own pool of worker threads to execute systems in, but Amethyst's main dispatcher already has a thread pool setup and configured. As reusing it is more efficient, we pull the global pool from the world and attach the dispatcher to it with <code>.with_pool()</code>.</p>
<p>The <code>CustomState</code> requires two annotations (<code>'a</code> and <code>'b</code>) to satisfy the lifetimes of the <code>Dispatcher</code>. Now that we have our <code>Dispatcher</code> we need to ensure that it is executed. We do this in the <code>State</code>s <code>update</code> method.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct CustomState&lt;'a, 'b&gt; {
</span><span class="boring">    /// The `State` specific `Dispatcher`, containing `System`s only relevant for this `State`.
</span><span class="boring">    dispatcher: Option&lt;Dispatcher&lt;'a, 'b&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">struct MoveBallsSystem; struct MovePaddlesSystem;
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MoveBallsSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {} }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MovePaddlesSystem { type SystemData = (); fn run(&amp;mut self, _: ()) {} }
</span><span class="boring">
</span>impl&lt;'a, 'b&gt; SimpleState for CustomState&lt;'a, 'b&gt; {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = &amp;mut data.world;
         
        // Create the `DispatcherBuilder` and register some `System`s that should only run for this `State`.
        let mut dispatcher_builder = DispatcherBuilder::new();
        dispatcher_builder.add(MoveBallsSystem, &quot;move_balls_system&quot;, &amp;[]);
        dispatcher_builder.add(MovePaddlesSystem, &quot;move_paddles_system&quot;, &amp;[]);
 
        // Build and setup the `Dispatcher`.
        let mut dispatcher = dispatcher_builder.build();
        dispatcher.setup(world);
 
        self.dispatcher = Some(dispatcher);
    }
 
    fn update(&amp;mut self, data: &amp;mut StateData&lt;GameData&gt;) -&gt; SimpleTrans {
        if let Some(dispatcher) = self.dispatcher.as_mut() {
            dispatcher.dispatch(&amp;data.world);
        }

        Trans::None
    }
}
</code></pre>
<p>Now, any <code>System</code>s in this <code>State</code>-specific <code>Dispatcher</code> will only run while this <code>State</code> is active and the <code>update</code> method is called. </p>
<h1><a class="header" href="#pausable-systems" id="pausable-systems">Pausable Systems</a></h1>
<p>Custom <code>GameData</code> and state-specific <code>System</code>s are great when it comes to handling groups of <code>System</code>. But when it comes single <code>System</code>s or a group of <code>System</code>s spread over multiple <code>Dispatcher</code>s or <code>State</code>s, pausable <code>Sytem</code>s come in handy.</p>
<p>Pausable <code>System</code>s can be enabled or disabled depending on the value of a<code>Resource</code> registered to your <code>World</code>. When this value changes, the state of your <code>System</code> changes as well.</p>
<p>Let's get started by creating a new <code>Resource</code> that represents the state of our game.</p>
<pre><code class="language-rust no_run noplaypen">#[derive(PartialEq)]
pub enum CurrentState {
    Running,
    Paused,
}

impl Default for CurrentState {
    fn default() -&gt; Self {
        CurrentState::Paused
    }
}
</code></pre>
<p>We'll use this <code>enum</code> <code>Resource</code> to control whether or not our <code>System</code> is running. Next we'll register our <code>System</code> and set it as pausable.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(PartialEq)]
</span><span class="boring">pub enum CurrentState {
</span><span class="boring">    Running,
</span><span class="boring">    Paused,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for CurrentState {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        CurrentState::Paused
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Default)] struct MovementSystem;
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MovementSystem {
</span><span class="boring">  type SystemData = ();
</span><span class="boring">
</span><span class="boring">  fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">let mut dispatcher = DispatcherBuilder::new();
</span>dispatcher.add(
    MovementSystem::default().pausable(CurrentState::Running),
    &quot;movement_system&quot;,
    &amp;[&quot;input_system&quot;],
);
</code></pre>
<p><code>pausable(CurrentState::Running)</code> creates a wrapper around our <code>System</code> that controls its execution depending on the <code>CurrentState</code> <code>Resource</code> registered with the <code>World</code>. As long as the value of the <code>Resource</code> is set to <code>CurrentState::Running</code>, the <code>System</code> is executed.</p>
<p>To register the <code>Resource</code> or change its value, we can use the following code:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">#[derive(PartialEq)]
</span><span class="boring">pub enum CurrentState {
</span><span class="boring">   Running,
</span><span class="boring">   Paused,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for CurrentState {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        CurrentState::Paused
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct GameplayState;

impl SimpleState for GameplayState {
    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
<span class="boring">      let my_condition = true;
</span>        if (my_condition) {
            *data.world.write_resource::&lt;CurrentState&gt;() = CurrentState::Paused;
        }
        
        Trans::None
    }
}
</code></pre>
<p>However, this cannot be done inside the pausable <code>System</code> itself. A pausable <code>System</code> can only access its pause <code>Resource</code> with immutable <code>Read</code> and cannot modify the value, thus the <code>System</code> cannot decide on its own if it should run on not. This has to be done from a different location.</p>
<h1><a class="header" href="#sprites" id="sprites">Sprites</a></h1>
<p>Sprites are 2D images that represent an object or background. Sprites are represented by two main chunks of data:</p>
<ul>
<li><strong>Texture:</strong> The image made of pixels.</li>
<li><strong>Sprite Layout:</strong> The (rectangular) coordinates of the sprites on that image.</li>
</ul>
<p>In Amethyst, these are represented by the <a href="https://docs.amethyst.rs/stable/amethyst_rendy/enum.Texture.html"><code>Texture</code></a> and <a href="https://docs.amethyst.rs/stable/amethyst_rendy/struct.SpriteSheet.html"><code>SpriteSheet</code></a> types respectively. The pages in this section will explain how to set up your application to load and display sprites.</p>
<blockquote>
<p><strong>Note:</strong> The code snippets in this section explain the parts of setting up sprite rendering separately. For complete application examples, please refer to the <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites_ordered"><em>sprites_ordered</em></a> example in the <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> directory.</p>
</blockquote>
<h1><a class="header" href="#set-up-the-render-plugin" id="set-up-the-render-plugin">Set Up The Render plugin</a></h1>
<p>Amethyst supports drawing sprites using the <code>RenderFlat2D</code> render plugin.
To enable this you have to do the following:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    ecs::{World, WorldExt},
    prelude::*,
    renderer::{
        plugins::RenderFlat2D,
        types::DefaultBackend,
        RenderingBundle,
    }
};
<span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt; {
</span><span class="boring">
</span><span class="boring">let game_data = GameDataBuilder::default()
</span><span class="boring">    .with_bundle(
</span><span class="boring">
</span>// inside your rendering bundle setup
RenderingBundle::&lt;DefaultBackend&gt;::new()
    .with_plugin(RenderFlat2D::default())

<span class="boring">)?;
</span><span class="boring">Ok(()) }
</span></code></pre>
<h1><a class="header" href="#load-the-texture" id="load-the-texture">Load The <code>Texture</code></a></h1>
<p>The first part of loading sprites into Amethyst is to read the image into memory.</p>
<p>The following snippet shows how to load a PNG / JPEG / GIF / ICO image:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::assets::{AssetStorage, Handle, Loader};
use amethyst::prelude::*;
use amethyst::renderer::{formats::texture::ImageFormat, Texture};

pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; Handle&lt;Texture&gt;
where
    N: Into&lt;String&gt;,
{
    let loader = world.read_resource::&lt;Loader&gt;();
    loader.load(
        name,
        ImageFormat::default(),
        (),
        &amp;world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;(),
    )
}

#[derive(Debug)]
struct ExampleState;

impl SimpleState for ExampleState {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>There is one thing that may surprise you.</p>
<ul>
<li>
<p>You don't get back the <a href="https://docs.amethyst.rs/stable/amethyst_renderer/struct.Texture.html"><code>Texture</code></a>, but a <a href="https://docs.amethyst.rs/stable/amethyst_assets/type.Handle.html"><code>Handle&lt;Texture&gt;</code></a>, which is a 
cloneable reference to the texture.</p>
<p>When you use <a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.Loader.html#method.load"><code>loader.load(..)</code></a> to load an <a href="https://docs.amethyst.rs/stable/amethyst_assets/trait.Asset.html"><code>Asset</code></a>, the method returns immediately with a unique handle for your texture. The actual asset loading is handled asynchronously, so if you attempt to use the texture handle to retrieve the texture, such as with <a href="https://docs.amethyst.rs/stable/specs/world/struct.World.html#method.read_resource"><code>world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;()</code></a><a href="https://docs.amethyst.rs/stable/amethyst_assets/struct.AssetStorage.html#method.get"><code>.get(texture_handle)</code></a>, you will get a <code>None</code> until the <code>Texture</code> has finished loading.</p>
</li>
</ul>
<p>The loaded texture will use nearest filtering, i.e. the pixels won't be interpolated.
If you want to tweak the sampling, you can change <code>ImageFormat::default()</code> to
<code>ImageFormat(my_config)</code>, and create your own <code>my_config</code> like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::renderer::rendy::hal::image::{Filter, SamplerInfo, WrapMode};
use amethyst::renderer::rendy::texture::image::{ImageTextureConfig, Repr, TextureKind};

let my_config = ImageTextureConfig {
    // Determine format automatically
    format: None,
    // Color channel
    repr: Repr::Srgb,
    // Two-dimensional texture
    kind: TextureKind::D2,
    sampler_info: SamplerInfo::new(Filter::Linear, WrapMode::Clamp),
    // Don't generate mipmaps for this image
    generate_mips: false,
    premultiply_alpha: true,
};
</code></pre>
<h1><a class="header" href="#define-the-spritesheet" id="define-the-spritesheet">Define The <code>SpriteSheet</code></a></h1>
<p>With the texture loaded, Amethyst still needs to know <em>where the sprites are</em> on the image.
There are two ways to load a sprite sheet definition: from a file or from code.</p>
<h2><a class="header" href="#load-the-sheet-from-a-file" id="load-the-sheet-from-a-file">Load the sheet from a file</a></h2>
<p>The easiest way to load your sprites is to use a sprite sheet definition ron file.
Here is an example of such a definition file using a list of sprites:</p>
<pre><code class="language-text ignore">List((
    // Width of the texture used by the sprite sheet
    texture_width: 48,
    // Height of the texture used by the sprite sheet
    texture_height: 16,
    // List of sprites the sheet holds
    sprites: [
        (
            // Horizontal position of the sprite in the sprite sheet
            x: 0,
            // Vertical position of the sprite in the sprite sheet
            y: 0,
            // Width of the sprite
            width: 16,
            // Height of the sprite
            height: 16,
            // Number of pixels to shift the sprite to the left and down relative to the entity holding it when rendering
            offsets: Some((0.0, 0.0)), // This is optional and defaults to (0.0, 0.0)
        ),
        (
            x: 16,
            y: 0,
            width: 32,
            height: 16,
        ),
        // etc...
    ],
))
</code></pre>
<p>Or you can use a grid based definition, for example:</p>
<pre><code class="language-text ignore">Grid((
    // Width of the texture used by the sprite sheet
    texture_width: 48,
    // Height of the texture used by the sprite sheet
    texture_height: 16,
    // Specifies the number of columns in the sprite sheet
    columns: 2,
    // Specifies the number of sprites in the spritesheet.
    sprite_count: Some(2)
))
</code></pre>
<p><code>Option</code> types need to be wrapped in the <code>Some</code> variant. For convenience, this can be left out if the line <code>#![enable(implicit_some)]</code> is added at the top of the definition file.  For example, <code>sprite_count: Some(2),</code> could be replaced by <code>sprite_count: 2,</code>.</p>
<p>For more information about list and grid based sprite sheets, including the types of their fields, see <a href="https://docs.amethyst.rs/stable/amethyst_rendy/sprite/struct.SpriteGrid.html"><code>SpriteGrid</code></a> or <a href="https://docs.amethyst.rs/stable/amethyst_rendy/sprite/struct.SpriteList.html"><code>SpriteList</code></a>.</p>
<p>Once you have ron file ready, you can load it using the texture handle of the sheet's image you loaded earlier:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::{Loader, AssetStorage, Handle};
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">use amethyst::renderer::{SpriteSheetFormat, SpriteSheet, Texture};
</span><span class="boring">
</span><span class="boring">fn load_texture() -&gt; Handle&lt;Texture&gt; {
</span><span class="boring">   unimplemented!()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn load_sprite_sheet() {
</span><span class="boring">  let world = World::new();
</span><span class="boring">  let loader = world.read_resource::&lt;Loader&gt;();
</span><span class="boring">  let texture_handle = load_texture();
</span><span class="boring">  let spritesheet_storage = world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;();
</span>let spritesheet_handle = loader.load(
    &quot;my_spritesheet.ron&quot;,
    SpriteSheetFormat(texture_handle),
    (),
    &amp;spritesheet_storage,
);
<span class="boring">}
</span></code></pre>
<p>This will get you the <code>Handle&lt;SpriteSheet&gt;</code> you will then use to draw the sprites.</p>
<h2><a class="header" href="#load-the-sheet-from-code" id="load-the-sheet-from-code">Load the sheet from code</a></h2>
<p>While it is not the recommended way, it is also possible to manually build your sheet with code.</p>
<p>Importantly, <strong>we use pixel coordinates as well as texture coordinates</strong> to define the sprite layout. Pixel coordinates indicate the dimensions of the sprite to draw on screen; texture coordinates indicate which part of the image contains the sprite, and are expressed as a proportion of the image.</p>
<p>The following table lists the differences between the coordinate systems:</p>
<table><thead><tr><th>Pixel coordinates</th><th>Texture coordinates</th></tr></thead><tbody>
<tr><td>Begin at the top left of the image</td><td>Begin at the bottom left of the image</td></tr>
<tr><td>Increase to the right and down</td><td>Increase to the right and up</td></tr>
<tr><td>Range from 0 to (width or height - 1)</td><td>Range from 0.0 to 1.0</td></tr>
</tbody></table>
<p>In Amethyst, pixel dimensions and texture coordinates are stored in the <code>Sprite</code> struct. Since texture coordinates can be derived from pixel coordinates, Amethyst provides the <code>Sprite::from_pixel_values</code> function to create a <code>Sprite</code>.</p>
<p>The following snippet shows you how to naively define a <code>SpriteSheet</code>. In a real application, you would typically use the sprite sheet from file feature, which is much more convenient.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::assets::Handle;
use amethyst::renderer::{sprite::TextureCoordinates, Sprite, SpriteSheet, Texture};

/// Returns a `SpriteSheet`.
///
/// # Parameters
///
/// * `texture`: Handle of the texture.
pub fn load_sprite_sheet(texture: Handle&lt;Texture&gt;) -&gt; SpriteSheet {
    let sprite_count = 1; // number of sprites
    let mut sprites = Vec::with_capacity(sprite_count);

    let image_w = 100;
    let image_h = 20;
    let sprite_w = 10;
    let sprite_h = 10;

    // Here we are loading the 5th sprite on the bottom row.
    let offset_x = 50; // 5th sprite * 10 pixel sprite width
    let offset_y = 10; // Second row (1) * 10 pixel sprite height
    let offsets = [5.0; 2]; // Align the sprite with the middle of the entity.

    let sprite = Sprite::from_pixel_values(
        image_w, image_h, sprite_w, sprite_h, offset_x, offset_y, offsets, false, false,
    );
    sprites.push(sprite);

    SpriteSheet {
        texture,
        sprites,
    }
}
</code></pre>
<h1><a class="header" href="#spriterender-component" id="spriterender-component"><code>SpriteRender</code> Component</a></h1>
<p>After loading the <code>SpriteSheet</code>, you need to attach it to an entity using the <code>SpriteRender</code> component and indicate which sprite to draw. The <code>SpriteRender</code> component looks like this:</p>
<pre><code class="language-rust ignore">#[derive(Clone, Debug, PartialEq)]
pub struct SpriteRender {
    /// Handle to the sprite sheet of the sprite
    pub sprite_sheet: Handle&lt;SpriteSheet&gt;,
    /// Index of the sprite on the sprite sheet
    pub sprite_number: usize,
}
</code></pre>
<p>The sprite number is the index of the sprite loaded in the sprite sheet. What's left is the <code>Handle&lt;SpriteSheet&gt;</code>.</p>
<p>In the previous section you wrote a function that returns a <code>SpriteSheet</code>. This can be turned into a <code>Handle&lt;SpriteSheet&gt;</code> using the <code>Loader</code> resource as follows:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::assets::{AssetStorage, Loader, Handle};
<span class="boring">use amethyst::prelude::*;
</span>use amethyst::renderer::{SpriteSheet, Texture};

<span class="boring">pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; Handle&lt;Texture&gt;
</span><span class="boring">where
</span><span class="boring">    N: Into&lt;String&gt;,
</span><span class="boring">{
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn load_sprite_sheet(texture: Handle&lt;Texture&gt;) -&gt; SpriteSheet {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span>#[derive(Debug)]
struct ExampleState;

impl SimpleState for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
<span class="boring">        let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);
</span>        // ...

        let sprite_sheet = load_sprite_sheet(texture_handle);
        let sprite_sheet_handle = {
            let loader = data.world.read_resource::&lt;Loader&gt;();
            loader.load_from_data(
                sprite_sheet,
                (),
                &amp;data.world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;(),
            )
        };
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Cool, finally we have all the parts, let's build a <code>SpriteRender</code> and attach it to an entity:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::{AssetStorage, Loader, Handle};
</span>use amethyst::core::transform::Transform;
<span class="boring">use amethyst::prelude::*;
</span>use amethyst::renderer::{
    SpriteRender, SpriteSheet,
    Texture, Transparent
};
use amethyst::window::ScreenDimensions;

<span class="boring">pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; Handle&lt;Texture&gt;
</span><span class="boring">where
</span><span class="boring">    N: Into&lt;String&gt;,
</span><span class="boring">{
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn load_sprite_sheet(texture: Handle&lt;Texture&gt;) -&gt; SpriteSheet {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span>#[derive(Debug)]
struct ExampleState;

impl SimpleState for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
<span class="boring">        let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);
</span><span class="boring">
</span><span class="boring">        let sprite_sheet = load_sprite_sheet(texture_handle);
</span><span class="boring">        let sprite_sheet_handle = {
</span><span class="boring">            let loader = data.world.read_resource::&lt;Loader&gt;();
</span><span class="boring">            loader.load_from_data(
</span><span class="boring">                sprite_sheet,
</span><span class="boring">                (),
</span><span class="boring">                &amp;data.world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;(),
</span><span class="boring">            )
</span><span class="boring">        };
</span>        // ...

        self.initialize_sprite(&amp;mut data.world, sprite_sheet_handle);
    }
}

impl ExampleState {
    fn initialize_sprite(
        &amp;mut self,
        world: &amp;mut World,
        sprite_sheet_handle: Handle&lt;SpriteSheet&gt;,
    ) {
        let (width, height) = {
            let dim = world.read_resource::&lt;ScreenDimensions&gt;();
            (dim.width(), dim.height())
        };

        // Move the sprite to the middle of the window
        let mut sprite_transform = Transform::default();
        sprite_transform.set_translation_xyz(width / 2., height / 2., 0.);

        // 0 indicates the first sprite in the sheet.
        let sprite_render = SpriteRender::new(sprite_sheet_handle, 0);  // First sprite

        world
            .create_entity()
            .with(sprite_render)
            .with(sprite_transform)
            .with(Transparent) // If your sprite is transparent
            .build();
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Got that? Sweet!</p>
<h1><a class="header" href="#modify-the-texture" id="modify-the-texture">Modify The <code>Texture</code></a></h1>
<p>The colors of the sprite will show up exactly as in the source file,
but sometimes being able to slightly modify the overall color
is useful - for instance, coloring an angry enemy more red, or
making a frozen enemy blue. Amethyst has a <a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a> called
<a href="https://docs.amethyst.rs/stable/amethyst_rendy/resources/struct.Tint.html"><code>Tint</code></a> to do this.</p>
<p>To use <a href="https://docs.amethyst.rs/stable/amethyst_rendy/resources/struct.Tint.html"><code>Tint</code></a>, register <a href="https://docs.amethyst.rs/stable/amethyst_rendy/resources/struct.Tint.html"><code>Tint</code></a> as a new
<a href="https://docs.amethyst.rs/stable/specs/trait.Component.html"><code>Component</code></a> with the world and build it as part of the entity.
<a href="https://docs.amethyst.rs/stable/amethyst_rendy/resources/struct.Tint.html"><code>Tint</code></a> will multiply the color values of the sprite by its
own values, so a <a href="https://docs.amethyst.rs/stable/amethyst_rendy/resources/struct.Tint.html"><code>Tint</code></a> with a white color will have no
effect on the sprite.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::{AssetStorage, Loader, Handle};
</span>use amethyst::core::transform::Transform;
<span class="boring">use amethyst::prelude::*;
</span>use amethyst::renderer::{
    palette::Srgba,
    resources::Tint,
    SpriteRender, SpriteSheet,
    Texture, Transparent
};
use amethyst::window::ScreenDimensions;

<span class="boring">pub fn load_texture&lt;N&gt;(name: N, world: &amp;World) -&gt; Handle&lt;Texture&gt;
</span><span class="boring">where
</span><span class="boring">    N: Into&lt;String&gt;,
</span><span class="boring">{
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn load_sprite_sheet(texture: Handle&lt;Texture&gt;) -&gt; SpriteSheet {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span>#[derive(Debug)]
struct ExampleState;

impl SimpleState for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
<span class="boring">        let texture_handle = load_texture(&quot;texture/sprite_sheet.png&quot;, &amp;data.world);
</span><span class="boring">
</span><span class="boring">        let sprite_sheet = load_sprite_sheet(texture_handle);
</span><span class="boring">        let sprite_sheet_handle = {
</span><span class="boring">            let loader = data.world.read_resource::&lt;Loader&gt;();
</span><span class="boring">            loader.load_from_data(
</span><span class="boring">                sprite_sheet,
</span><span class="boring">                (),
</span><span class="boring">                &amp;data.world.read_resource::&lt;AssetStorage&lt;SpriteSheet&gt;&gt;(),
</span><span class="boring">            )
</span><span class="boring">        };
</span>        // ...

        self.initialize_sprite(&amp;mut data.world, sprite_sheet_handle);
    }
}

impl ExampleState {
    fn initialize_sprite(
        &amp;mut self,
        world: &amp;mut World,
        sprite_sheet_handle: Handle&lt;SpriteSheet&gt;,
    ) {
        // ..

<span class="boring">        let (width, height) = {
</span><span class="boring">            let dim = world.read_resource::&lt;ScreenDimensions&gt;();
</span><span class="boring">            (dim.width(), dim.height())
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Move the sprite to the middle of the window
</span><span class="boring">        let mut sprite_transform = Transform::default();
</span><span class="boring">        sprite_transform.set_translation_xyz(width / 2., height / 2., 0.);
</span><span class="boring">
</span><span class="boring">        let sprite_render = SpriteRender::new(sprite_sheet_handle, 0);  // First sprite
</span>
        // White shows the sprite as normal.
        // You can change the color at any point to modify the sprite's tint.
        let tint = Tint(Srgba::new(1.0, 1.0, 1.0, 1.0));

        world
            .create_entity()
            .with(sprite_render)
            .with(sprite_transform)
            .with(tint)
            .build();
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<h1><a class="header" href="#orthographic-camera" id="orthographic-camera">Orthographic Camera</a></h1>
<p>Finally, you need to tell Amethyst to draw in 2D space. This is done by creating an entity with a <code>Camera</code> component using orthographic projection. For more information about orthographic projection, refer to the <a href="https://opengl-notes.readthedocs.io/en/latest/topics/transforms/viewing.html#orthographic-projection">OpenGL documentation</a>.</p>
<p>The following snippet demonstrates how to set up a <code>Camera</code> that sees entities within screen bounds, where the entities' Z position is between -10.0 and 10.0:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    core::{math::Orthographic3, transform::Transform},
    prelude::*,
    renderer::camera::Camera,
    window::ScreenDimensions,
};

#[derive(Debug)]
struct ExampleState;

impl SimpleState for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // ...

        self.initialize_camera(&amp;mut data.world);
    }
}

impl ExampleState {
    fn initialize_camera(&amp;mut self, world: &amp;mut World) {
        let (width, height) = {
            let dim = world.read_resource::&lt;ScreenDimensions&gt;();
            (dim.width(), dim.height())
        };

        // Translate the camera to Z coordinate 10.0, and it looks back toward
        // the origin with depth 20.0
        let mut transform = Transform::default();
        transform.set_translation_xyz(0., height, 10.);

        let camera = Camera::orthographic(
            0.0,
            width,
            0.0,
            height,
            0.0,
            20.0,
        );

        let camera = world
            .create_entity()
            .with(transform)
            .with(camera)
            .build();
    }
}
</code></pre>
<p>And you're done! If you would like to see this in practice, check out the <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites"><em>sprites</em></a> or <a href="https://github.com/amethyst/amethyst/tree/master/examples/sprites_ordered"><em>sprites_ordered</em></a> examples in the <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> directory.</p>
<h1><a class="header" href="#tiles" id="tiles">Tiles</a></h1>
<p>Tile maps are a grouping of tiles containing a sprite; they are primarily represented by:</p>
<ul>
<li><strong>TileMap:</strong> A structure for storing tiles and functionality for reading/modifying the map.</li>
<li><strong>Tile:</strong> A container for a sprite and other rendering information.</li>
</ul>
<p>In Amethyst, the <a href="https://docs.amethyst.rs/stable/amethyst_tiles/trait.Tile.html"><code>Tile</code></a> is a trait that must be implemented within you crate which is provided to the <a href="https://docs.amethyst.rs/stable/amethyst_tiles/struct.TileMap.html"><code>TileMap</code></a> and <a href="https://docs.amethyst.rs/stable/amethyst_tiles/struct.RenderTiles2D.html"><code>RenderTiles2D</code></a>. The pages in this section will explain how to add tile maps to your application. </p>
<blockquote>
<p><strong>Note:</strong> The code snippets in this section explain the parts of creating tile maps separately. For complete application examples, please refer to the <a href="https://github.com/amethyst/amethyst/tree/master/examples/tiles"><em>tiles</em></a> example in the <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> directory.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> This section uses <a href="../sprites.html"><em>sprites</em></a> and assumes knowledge of loading sprites and spritesheets.</p>
</blockquote>
<h1><a class="header" href="#setup" id="setup">Setup</a></h1>
<h2><a class="header" href="#install-the-tiles-feature" id="install-the-tiles-feature">Install the tiles feature</a></h2>
<p>In order to use the tiles package you need add the <code>tiles</code> feature to your <code>Cargo.toml</code>:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = { version = &quot;LATEST_CRATES.IO_VERSION&quot;, features = [&quot;tiles&quot;] }
</code></pre>
<h2><a class="header" href="#setup-the-render-pass" id="setup-the-render-pass">Setup the Render Pass</a></h2>
<p>Now you can add the render pass to your application:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    core::math::Point3,
    ecs::{World, WorldExt},
    prelude::*,
    renderer::{
        plugins::RenderFlat2D,
        types::DefaultBackend,
        RenderingBundle,
    },
    tiles::{RenderTiles2D, Tile},
};

#[derive(Clone, Default)]
struct SimpleTile;
impl Tile for SimpleTile {
    fn sprite(&amp;self, _coords: Point3&lt;u32&gt;, _: &amp;World) -&gt; Option&lt;usize&gt; {
        Some(1)
    }
}

<span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt; {
</span><span class="boring">
</span><span class="boring">let game_data = GameDataBuilder::default()
</span><span class="boring">    .with_bundle(
</span><span class="boring">
</span>// inside your rendering bundle setup
RenderingBundle::&lt;DefaultBackend&gt;::new()
    .with_plugin(RenderFlat2D::default())
    .with_plugin(RenderTiles2D::&lt;SimpleTile&gt;::default())

<span class="boring">)?;
</span><span class="boring">Ok(()) }
</span></code></pre>
<p>The render plugin requires a tile implementation, so we create a struct, <code>SimpleTile</code> and implment <code>Tile</code>, which is needed by the render plugin in order to provide the sprite number and tint (not implemented in this example) to the renderer. The tile we created will also be used later when we create the tile map.</p>
<h1><a class="header" href="#create-a-tile-map" id="create-a-tile-map">Create a Tile Map</a></h1>
<p>With the <code>tiles</code> feature installed and our <code>RenderTiles2D</code> render pass setup, we can create a <code>TileMap</code> component and add it an entity. We need to have a sprite sheet loaded before the creation so this example assume a handle to a sprite sheet exists.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    core::{
        math::{Point3, Vector3},
        transform::Transform,
    },
    tiles::{Tile, TileMap},
};
<span class="boring">use amethyst::{
</span><span class="boring">    assets::Handle,
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::SpriteSheet,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Default)]
</span><span class="boring">struct SimpleTile;
</span><span class="boring">impl Tile for SimpleTile {
</span><span class="boring">    fn sprite(&amp;self, _coords: Point3&lt;u32&gt;, _: &amp;World) -&gt; Option&lt;usize&gt; {
</span><span class="boring">        Some(1)
</span><span class="boring">    }
</span><span class="boring">}
</span>
<span class="boring">pub fn load_sprite_sheet() -&gt; Handle&lt;SpriteSheet&gt; {
</span><span class="boring">    unimplemented!();
</span><span class="boring">}
</span>
#[derive(Debug)]
struct ExampleState;

impl SimpleState for ExampleState {
    fn on_start(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
<span class="boring">       let world = data.world;
</span>        let sprite_sheet_handle = load_sprite_sheet();
        // ...
        init_map(world, sprite_sheet_handle.clone())
    }
}

fn init_map(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) {
        let map = TileMap::&lt;SimpleTile&gt;::new(
            Vector3::new(10, 10, 1), // The dimensions of the map
            Vector3::new(16, 16, 1), // The dimensions of each tile
            Some(sprite_sheet_handle),
        );
        let transform = Transform::default();
        
        world
            .create_entity()
            .with(map)
            .with(transform)
            .build();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>The tile map component was created and added to the entity we created and thats it! Check out the <a href="https://github.com/amethyst/amethyst/tree/master/examples/tiles"><em>tiles</em></a> example in the <a href="https://github.com/amethyst/amethyst/tree/master/examples">examples</a> directory.</p>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>The most usual way to have your players interact with your game is through your user interface or UI.
In general UI includes all kinds of widgets from images, buttons, progress bars, text, sliders, popup menus, etc.</p>
<p>The API in Amethyst was designed more to provide users with building blocks for the UI and without 
a specific layout system. The reason is that you don't often see, if any, layout systems 
used in games, although are very popular GUI frameworks. </p>
<p>Please note that not all forementinoted widgets exist in Amethyst yet.</p>
<h2><a class="header" href="#setting-up-the-ui" id="setting-up-the-ui">Setting up the UI</a></h2>
<p>The first thing you need to add to your systems is the <a href="https://docs.amethyst.rs/master/amethyst_ui/struct.UiBundle.html">UiBundle</a>. The <code>UiBundle</code> registers
all the needed components,systems and resources in order to be able use the UI. Another <strong>very important thing</strong>
is that you want to add the <a href="https://docs.amethyst.rs/master/amethyst_input/struct.InputBundle.html">InputBundle</a> 
<strong>before</strong> the <code>UiBundle</code>,
otherwise the application will panic, since it is a dependency for the <code>UiBundle</code>!</p>
<p>Now you are able to create your widgets! Unfortunately you won't be able to see them. That's why you also need 
to add a plugin to your rendering bundle called <a href="https://docs.amethyst.rs/master/amethyst_ui/struct.RenderUi.html">RenderUi</a> in order
to draw these widgets.</p>
<p>A minimalistic game data would now look like this:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    GameDataBuilder,
</span><span class="boring">    input::{InputBundle, StringBindings},
</span><span class="boring">    renderer::{types::DefaultBackend, RenderingBundle, RenderToWindow},
</span><span class="boring">    Result,
</span><span class="boring">    ui::{RenderUi, UiBundle}
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub fn main() -&gt; Result&lt;()&gt; {
</span>    let game_data = GameDataBuilder::default()
        .with_bundle(InputBundle::&lt;StringBindings&gt;::new())?
        .with_bundle(UiBundle::&lt;StringBindings&gt;::new())?
        .with_bundle(
            RenderingBundle::&lt;DefaultBackend&gt;::new()
                .with_plugin(RenderToWindow::from_config(Default::default())
                        .with_clear([0.0, 0.0, 0.0, 1.0]),
                )
                .with_plugin(RenderUi::default()),
        )?;
<span class="boring">  Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Make sure that the <code>InputBundle</code> and <code>UiBundle</code> have same binding types. In this case these
are <code>StringBindings</code>.</p>
<h1><a class="header" href="#build-your-own" id="build-your-own">Build your own!</a></h1>
<p>In this chapter we will guide you through building your own button in Amethyst!</p>
<h3><a class="header" href="#bulding-blocks" id="bulding-blocks">Bulding blocks</a></h3>
<p>The components you can use in order to build your button are as goes:</p>
<ul>
<li>
<p><a href="https://docs.amethyst.rs/master/amethyst_ui/struct.UiTransform.html">UiTransform</a> -
used for positioning your button on the screen (same as Transform but for the UI elements)</p>
</li>
<li>
<p><a href="https://docs.amethyst.rs/master/amethyst_ui/struct.UiText.html">UiText</a> -
if you want your button to have any text displayed</p>
</li>
<li>
<p><a href="https://docs.amethyst.rs/master/amethyst_ui/enum.UiImage.html">UiImage</a> -
if you want your button to display a texture</p>
</li>
</ul>
<p>You don't have to use all three at the same time of course but variations of two (<code>UiTransfrom</code> is always needed!).</p>
<h3><a class="header" href="#creating-the-uitransform" id="creating-the-uitransform">Creating the <code>UiTransform</code></a></h3>
<p>One way of defining a <code>UiTransform</code> is like so:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ui::{Anchor, UiTransform};
</span>
let ui_transform = UiTransform::new(
    String::from(&quot;simple_button&quot;), // id
    Anchor::Middle,                // anchor
    Anchor::Middle,                // pivot
    0f32,                          // x
    0f32,                          // y
    0f32,                          // z
    100f32,                        // width
    30f32,                         // height
);
</code></pre>
<p>The <code>id</code> field of the transform is basically like the name. You can use this in combination with the
<a href="https://docs.amethyst.rs/master/amethyst_ui/struct.UiFinder.html">UiFinder</a> to fetch the transfrom through a system.</p>
<p>Assuming the entity has no parent, whatever is set as the <code>anchor</code> field will be placed relative to the screen. In our case
we set it to <code>Anchor::Middle</code> and it will be drawn in the middle of the screen. The <code>pivot</code> field will center the widget
relative to itself - this in turn is the reason why our <code>x</code> and <code>y</code> fields are <code>0f32</code>. The <code>z</code> field of this struct 
is used for &quot;depth&quot; ordering of the ui elements.</p>
<p>The <code>width</code> and <code>height</code> fields are also important. They represent the area that will register the events like hovering over 
with the mouse, clicking and dragging. If you built the entity with the <code>UiText</code> component this also determines if the text will be rendered, 
meaning you need
to set the area big enough for the text to fit in!</p>
<h3><a class="header" href="#creating-the-uitext" id="creating-the-uitext">Creating the <code>UiText</code></a></h3>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::{AssetStorage, Loader};
</span><span class="boring">use amethyst::ui::{Anchor, FontAsset, get_default_font, LineMode, UiText};
</span><span class="boring">use amethyst::prelude::{World, WorldExt};
</span><span class="boring">
</span><span class="boring">fn some_function(world: &amp;mut World) {
</span><span class="boring">   let font_handle = {
</span><span class="boring">       let loader = world.read_resource::&lt;Loader&gt;();
</span><span class="boring">       let font_storage = world.read_resource::&lt;AssetStorage&lt;FontAsset&gt;&gt;();
</span><span class="boring">       get_default_font(&amp;loader, &amp;font_storage)
</span><span class="boring">   };
</span>    let ui_text = UiText::new(
        font_handle,                   // font
        String::from(&quot;Simple Button&quot;), // text
        [1.0, 1.0, 1.0, 0.5],          // color
        25f32,                         // font_size
        LineMode::Single,              // line mode
        Anchor::Middle,                // alignment
    );
<span class="boring">}
</span></code></pre>
<p>The <code>text</code> field of this struct is pretty self explanatory. It's what you would want to access if
you were to dynamically change the text on the screen through systems.</p>
<p>You also need to load a specific font handle and provide it for the text.</p>
<p>If you had some state implemented you can create the button on its <code>on_start</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::{AssetStorage, Loader};
</span><span class="boring">use amethyst::ui::{
</span><span class="boring">    Anchor, FontAsset, get_default_font, LineMode, UiText, UiTransform,
</span><span class="boring">};
</span><span class="boring">use amethyst::prelude::{Builder, GameData, SimpleState, SimpleTrans, StateData, Trans, World, WorldExt};
</span><span class="boring">
</span><span class="boring">pub struct State;
</span><span class="boring">
</span><span class="boring">impl SimpleState for State {
</span><span class="boring">
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    /* Create the transform */
    let ui_transform = UiTransform::new(
        // ...
<span class="boring">        String::from(&quot;simple_button&quot;), // id
</span><span class="boring">        Anchor::Middle,                // anchor
</span><span class="boring">        Anchor::Middle,                // pivot
</span><span class="boring">        0f32,                          // x
</span><span class="boring">        0f32,                          // y
</span><span class="boring">        0f32,                          // z
</span><span class="boring">        100f32,                        // width
</span><span class="boring">        30f32,                         // height
</span>    );
<span class="boring">
</span><span class="boring">   let font_handle = {
</span><span class="boring">       let loader = world.read_resource::&lt;Loader&gt;();
</span><span class="boring">       let font_storage = world.read_resource::&lt;AssetStorage&lt;FontAsset&gt;&gt;();
</span><span class="boring">       get_default_font(&amp;loader, &amp;font_storage)
</span><span class="boring">   };
</span>
    /* Create the text */
    let ui_text = UiText::new(
        // ...
<span class="boring">      font_handle,                   // font
</span><span class="boring">      String::from(&quot;Simple Button&quot;), // text
</span><span class="boring">      [1.0, 1.0, 1.0, 0.5],          // color
</span><span class="boring">      25f32,                         // font_size
</span><span class="boring">      LineMode::Single,
</span><span class="boring">      Anchor::Middle,
</span>    );

    /* Building the entity */
    let _ = world.create_entity()
        .with(ui_transform)
        .with(ui_text)
        .build();
}
<span class="boring">
</span><span class="boring">    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
</span><span class="boring">        Trans::None
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre>
<p>It is recommended to keep the entity either in your state or some kind of resource so you
can hide or delete it when you change the states (like changing menus)!</p>
<p>If you were to run this you would get a button in the middle of the screen saying <code>&quot;Simple Button&quot;</code>, but
you won't be able to interact with it (which doesn't actually make it a button yet)!</p>
<h3><a class="header" href="#interacting-with-the-button" id="interacting-with-the-button">Interacting with the button!</a></h3>
<p>In order for the ui to generate events you need to add an <a href="https://docs.amethyst.rs/master/amethyst_ui/struct.Interactable.html">Interactable</a> 
component to your entity (either when building it or dynamically).</p>
<p>This will not work if the entity doesn't
have a <code>UiTransform</code> component!</p>
<p>The code snippet would look like this now:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::assets::{AssetStorage, Loader};
</span><span class="boring">use amethyst::ui::{
</span><span class="boring">    Anchor, FontAsset, get_default_font, LineMode, UiText, UiTransform, Interactable,
</span><span class="boring">};
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">use amethyst::prelude::{GameData, SimpleTrans, StateData};
</span><span class="boring">
</span><span class="boring">fn some_function(world: &amp;mut World) {
</span><span class="boring">   let ui_transform = UiTransform::new(
</span><span class="boring">        String::from(&quot;simple_button&quot;), // id
</span><span class="boring">        Anchor::Middle,                // anchor
</span><span class="boring">        Anchor::Middle,                // pivot
</span><span class="boring">        0f32,                          // x
</span><span class="boring">        0f32,                          // y
</span><span class="boring">        0f32,                          // z
</span><span class="boring">        100f32,                        // width
</span><span class="boring">        30f32,                         // height
</span><span class="boring">   );
</span><span class="boring">
</span><span class="boring">   let font_handle = {
</span><span class="boring">       let loader = world.read_resource::&lt;Loader&gt;();
</span><span class="boring">       let font_storage = world.read_resource::&lt;AssetStorage&lt;FontAsset&gt;&gt;();
</span><span class="boring">       get_default_font(&amp;loader, &amp;font_storage)
</span><span class="boring">   };
</span><span class="boring">   /* Create the text */
</span><span class="boring">   let ui_text = UiText::new(
</span><span class="boring">      font_handle,                   // font
</span><span class="boring">      String::from(&quot;Simple Button&quot;), // text
</span><span class="boring">      [1.0, 1.0, 1.0, 0.5],          // color
</span><span class="boring">      25f32,                         // font_size
</span><span class="boring">      LineMode::Single,
</span><span class="boring">      Anchor::Middle,
</span><span class="boring">   );
</span>
let _ = world.create_entity()
    .with(ui_transform)
    .with(ui_text)
    .with(Interactable)
    .build();
<span class="boring">}
</span></code></pre>
<h1><a class="header" href="#interaction" id="interaction">Interaction!</a></h1>
<p>Now that we have a button we can interact with, let's see how we actually do this.
We will show you how to do this in two ways. One way will be interaction through a system,
and the latter interaction through <code>handle_event</code> method of your active state.</p>
<h2><a class="header" href="#creating-the-system" id="creating-the-system">Creating the system</a></h2>
<p>Let's start of with some boilerplate code: </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::System;
</span>
pub struct SimpleButtonSystem;

impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {
	
    }
}
</code></pre>
<p>This was shown in previous <a href="ui/../concepts/system/system_initialization.html">chapters</a>.
The way you will be able to read the generated 
events is with a <a href="https://docs.amethyst.rs/master/specs/prelude/struct.ReaderId.html">ReaderId</a>.
The <code>ReaderId</code> is added as a field to the system struct.</p>
<p>The events we want to read are of type <a href="https://docs.amethyst.rs/master/amethyst_ui/struct.UiEvent.html">UiEvent</a>.
We also need to fetch the <a href="https://docs.amethyst.rs/master/shrev/struct.EventChannel.html">EventChannel</a> in our <code>SystemData</code>, 
since the <code>ReaderId</code> actually pulls (reads) information  from the <code>EventChannel</code>.</p>
<p>Adding it up, it should look like this: </p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Read};
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ui::UiEvent;
</span>
pub struct SimpleButtonSystem {
    reader_id: ReaderId&lt;UiEvent&gt;,
}

impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
    type SystemData = Read&lt;'s, EventChannel&lt;UiEvent&gt;&gt;;

    fn run(&amp;mut self, events: Self::SystemData) {

    }
}
</code></pre>
<p>We also need a constructor for our system:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Read};
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ui::UiEvent;
</span><span class="boring">
</span><span class="boring">pub struct SimpleButtonSystem {
</span><span class="boring">   reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
</span><span class="boring">    type SystemData = Read&lt;'s, EventChannel&lt;UiEvent&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn run(&amp;mut self, events: Self::SystemData) {
</span><span class="boring">
</span><span class="boring">    }
</span><span class="boring">}
</span>impl SimpleButtonSystem {
    pub fn new(reader_id: ReaderId&lt;UiEvent&gt;) -&gt; Self {
        Self {
            reader_id,	
        }
    }
}
</code></pre>
<p>To add the system to our game data we actually need a <code>SystemDesc</code> implementation for our system:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, World, Read, Write, SystemData};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ui::UiEvent;
</span><span class="boring">pub struct SimpleButtonSystem {
</span><span class="boring">   reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
</span><span class="boring">    type SystemData = Read&lt;'s, EventChannel&lt;UiEvent&gt;&gt;;
</span><span class="boring">
</span><span class="boring">    fn run(&amp;mut self, events: Self::SystemData) {
</span><span class="boring">
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">impl SimpleButtonSystem {
</span><span class="boring">    pub fn new(reader_id: ReaderId&lt;UiEvent&gt;) -&gt; Self {
</span><span class="boring">       Self {
</span><span class="boring">            reader_id,	
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">}
</span>pub struct SimpleButtonSystemDesc;

impl&lt;'a, 'b&gt; SystemDesc&lt;'a, 'b, SimpleButtonSystem&gt; for SimpleButtonSystemDesc {
    fn build(self, world: &amp;mut World) -&gt; SimpleButtonSystem {
        let mut event_channel = &lt;Write&lt;EventChannel&lt;UiEvent&gt;&gt;&gt;::fetch(world);
        let reader_id = event_channel.register_reader();

        SimpleButtonSystem::new(reader_id)
    }
}
</code></pre>
<p>Now that this is done we can start reading our events!</p>
<p>In our systems <code>run</code> method we are going to loop through all the events:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, World, Read};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ui::UiEvent;
</span><span class="boring">pub struct SimpleButtonSystem {
</span><span class="boring">   reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
</span><span class="boring">    type SystemData = Read&lt;'s, EventChannel&lt;UiEvent&gt;&gt;;
</span><span class="boring">
</span>fn run(&amp;mut self, events: Self::SystemData) {
    for event in events.read(&amp;mut self.reader_id) {
        println!(&quot;{:?}&quot;, event);	
    }
}
<span class="boring">}
</span></code></pre>
<p>Let's try and change the text color when the button receives a hovered event!</p>
<p>Firstly we need to fetch two more components that 
we used for our entity - <code>UiTransform</code> and <code>UiText</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, World, Read, ReadStorage, WriteStorage};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ui::{UiTransform, UiText, UiEvent};
</span><span class="boring">pub struct SimpleButtonSystem {
</span><span class="boring">   reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
</span>type SystemData = Read&lt;'s, EventChannel&lt;UiEvent&gt;&gt;;
<span class="boring">
</span><span class="boring">fn run(&amp;mut self, events: Self::SystemData) {
</span><span class="boring">    for event in events.read(&amp;mut self.reader_id) {
</span><span class="boring">        println!(&quot;{:?}&quot;, event);	
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre>
<p>Usage of <code>WriteStorage&lt;'s, UiText&gt;</code> is needed since we will be changing 
the color that is the property of the <code>UiText</code> component.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, World, Read, ReadStorage, WriteStorage};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::shrev::{EventChannel, ReaderId};
</span><span class="boring">use amethyst::ui::{UiTransform, UiText, UiEvent, UiEventType};
</span><span class="boring">pub struct SimpleButtonSystem {
</span><span class="boring">   reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for SimpleButtonSystem {
</span><span class="boring">type SystemData = (
</span><span class="boring">    Read&lt;'s, EventChannel&lt;UiEvent&gt;&gt;,
</span><span class="boring">    ReadStorage&lt;'s, UiTransform&gt;,
</span><span class="boring">    WriteStorage&lt;'s, UiText&gt;,
</span><span class="boring">);
</span><span class="boring">
</span>fn run(&amp;mut self, (events, transforms, mut texts): Self::SystemData) {
    for event in events.read(&amp;mut self.reader_id) {
        let button_text = texts.get_mut(event.target).unwrap();

        match event.event_type {
            UiEventType::HoverStart =&gt; { 
                button_text.color = [1.0, 1.0, 1.0, 1.0]; 
            },
            UiEventType::HoverStop  =&gt; { 
                button_text.color = [1.0, 1.0, 1.0, 0.5]; 
            },
            _ =&gt; {},
        }   
    }
}
<span class="boring">}
</span></code></pre>
<p>The <code>HoverStart</code> and <code>HoverStop</code> are emitted once, upon the cursor 
entering the transform area and exiting respectively. </p>
<p>This will brighten the button when hovering over it, and dim it otherwise.</p>
<p><strong>Please note</strong> that you would likely have some kind of checks in order to know 
for which button the event is generated. 
We haven't performed any here since we only have one button, so all generated 
events are tied to that button.</p>
<p>Basically you want all the magic happening in the systems, like fading
effects, scaling effect and such. </p>
<p>In theory you could set up a connection between the system and the state
like a resource, which will determine the change of the state.
Eventhough possible, it is not recommended. That's why now 
we will go through managing input through the state.</p>
<h2><a class="header" href="#state-interaction" id="state-interaction">State Interaction</a></h2>
<p>Let's declare our state, and call it <code>MenuState</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::Entity;
</span><span class="boring">
</span>#[derive(Default)]
pub struct MenuState {
    button: Option&lt;Entity&gt;,
}
</code></pre>
<p>We give it a field named <code>button</code> which will hold an entity wrapped in
an <code>Option&lt;T&gt;</code>. This simplifies things since we can now derive <code>Default</code>
trait on it and we can make it as our initial state that the application
will start off as.</p>
<p>It will also serve to hold our ui entity.</p>
<p>In our <code>on_start</code> method of this state we can create the button as shown in
previous chapters, but here we will save the entity in our struct:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring"> assets::{AssetStorage, Loader},
</span><span class="boring">	ecs::{Entity, World, WorldExt},
</span><span class="boring">	ui::{Anchor, FontHandle, Interactable, LineMode, TtfFormat, UiText, UiTransform},
</span><span class="boring">	prelude::{Builder, GameData, SimpleState, StateData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MenuState {
</span><span class="boring">  button: Option&lt;Entity&gt;,
</span><span class="boring">}
</span>impl SimpleState for MenuState {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = data.world;

<span class="boring">
</span>        /* Create the transform */
        let ui_transform = UiTransform::new(
        // ...
<span class="boring">	    String::from(&quot;simple_button&quot;), // id
</span><span class="boring">      Anchor::Middle,                // anchor
</span><span class="boring">      Anchor::Middle,                // pivot
</span><span class="boring">      0f32,                          // x
</span><span class="boring">      0f32,                          // y
</span><span class="boring">      0f32,                          // z
</span><span class="boring">      100f32,                        // width
</span><span class="boring">      30f32,                         // height
</span>        );

        /* Create the text */
<span class="boring">      let font_handle = world.read_resource::&lt;Loader&gt;().load(
</span><span class="boring">      &quot;font/square.ttf&quot;,
</span><span class="boring">      TtfFormat,
</span><span class="boring">      (),
</span><span class="boring">      &amp;world.read_resource(),
</span><span class="boring">      );
</span><span class="boring">
</span>        let ui_text = UiText::new(
        // ...
<span class="boring">      font_handle,                      // font
</span><span class="boring">      String::from(&quot;Simple Button&quot;),    // text
</span><span class="boring">      [1.0f32, 1.0f32, 1.0f32, 0.5f32], // color
</span><span class="boring">      25f32,                            // font_size
</span><span class="boring">      LineMode::Single,                 // line_mode
</span><span class="boring">      Anchor::Middle,                   // align
</span>        );

        /* Building the entity */
        let btn = world.create_entity()
            .with(ui_transform)
            .with(ui_text)
            .with(Interactable)   
            .build();

        /* Saving the button in our state struct */
        self.button = Some(btn);
    }
}
</code></pre>
<p>All the input received will be handled in the <a href="https://docs.amethyst.rs/master/amethyst/trait.State.html#method.handle_event">handle_event</a>
method of our state:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">  assets::{AssetStorage, Loader},
</span><span class="boring">  ecs::{Entity, World, WorldExt},
</span><span class="boring">  ui::{Anchor, FontHandle, Interactable, LineMode, TtfFormat, UiEventType, UiText, UiTransform},
</span><span class="boring">  prelude::{Builder, GameData, SimpleState, StateData, SimpleTrans},
</span><span class="boring">  StateEvent,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MenuState {
</span><span class="boring">  button: Option&lt;Entity&gt;,
</span><span class="boring">}
</span>impl SimpleState for MenuState {
<span class="boring">  fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
</span>    // ...
<span class="boring">      let world = data.world;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">      /* Create the transform */
</span><span class="boring">      let ui_transform = UiTransform::new(
</span><span class="boring">          String::from(&quot;simple_button&quot;), // id
</span><span class="boring">          Anchor::Middle,                // anchor
</span><span class="boring">          Anchor::Middle,                // pivot
</span><span class="boring">          0f32,                          // x
</span><span class="boring">          0f32,                          // y
</span><span class="boring">          0f32,                          // z
</span><span class="boring">          100f32,                        // width
</span><span class="boring">          30f32,                         // height
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      /* Create the text */
</span><span class="boring">      let font_handle = world.read_resource::&lt;Loader&gt;().load(
</span><span class="boring">         &quot;font/square.ttf&quot;,
</span><span class="boring">         TtfFormat,
</span><span class="boring">         (),
</span><span class="boring">         &amp;world.read_resource(),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      let ui_text = UiText::new(
</span><span class="boring">          font_handle,                      // font
</span><span class="boring">          String::from(&quot;Simple Button&quot;),    // text
</span><span class="boring">          [1.0f32, 1.0f32, 1.0f32, 0.5f32], // color
</span><span class="boring">          25f32,                            // font_size
</span><span class="boring">          LineMode::Single,                 // line_mode
</span><span class="boring">          Anchor::Middle,                   // align
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      /* Building the entity */
</span><span class="boring">      let btn = world.create_entity()
</span><span class="boring">          .with(ui_transform)
</span><span class="boring">          .with(ui_text)
</span><span class="boring">          .with(Interactable)   
</span><span class="boring">          .build();
</span><span class="boring">
</span><span class="boring">      /* Saving the button in our state struct */
</span><span class="boring">      self.button = Some(btn);
</span><span class="boring">  }
</span>
    fn handle_event(
        &amp;mut self,
    	_data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;,
    	event: StateEvent) -&gt; SimpleTrans {
    	if let StateEvent::Ui(ui_event) = event {
    		let is_target = ui_event.target == self.button.unwrap();

    		match ui_event.event_type {
    			UiEventType::Click if is_target =&gt; {
    				/* . . . */
    			},
    			_ =&gt; {
    				return SimpleTrans::None;
    			},  
    		};
    	}

    	SimpleTrans::None
    }
}
</code></pre>
<p>We only care about the <code>UiEvent</code>s here, that's why we can use the <code>if-let</code> pattern.
Then we check if the ui target is the same as our saved entity, in this case it
surely is since we've only built one entity. After there's a check for click
event and an additional if statement for our button entity. If it goes well it will
enter that branch.</p>
<p>In this branch you can do whatever you like, either quit if you have a <code>QUIT</code> button
and the user clicks on it, in that case we would return a <code>Trans::Quit</code>, otherwise
probably something else.</p>
<p>Let's assume something was pushed on top our <code>MenuState</code> we would need these two methods:</p>
<ul>
<li>
<p><a href="https://docs.amethyst.rs/master/amethyst/trait.State.html#method.on_pause">on_pause</a></p>
</li>
<li>
<p><a href="https://docs.amethyst.rs/master/amethyst/trait.State.html#method.on_resume">on_resume</a></p>
</li>
</ul>
<p>Upon pushing another state the <code>on_pause</code> method will run - here we can hide our button.
The way we do that is by adding a <a href="https://docs.amethyst.rs/master/amethyst_core/struct.Hidden.html">Hidden</a>
component to our button:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">  assets::{AssetStorage, Loader},
</span><span class="boring">  core::Hidden,
</span><span class="boring">  ecs::{Entity, World, WorldExt},
</span><span class="boring">  ui::{Anchor, FontHandle, Interactable, LineMode, TtfFormat, UiEventType, UiText, UiTransform},
</span><span class="boring">  prelude::{Builder, GameData, SimpleState, StateData, SimpleTrans},
</span><span class="boring">  StateEvent
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MenuState {
</span><span class="boring">   button: Option&lt;Entity&gt;,
</span><span class="boring">}
</span>impl SimpleState for MenuState {
    // ...
<span class="boring">  fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
</span><span class="boring">      let world = data.world;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">      /* Create the transform */
</span><span class="boring">      let ui_transform = UiTransform::new(
</span><span class="boring">          String::from(&quot;simple_button&quot;), // id
</span><span class="boring">          Anchor::Middle,                // anchor
</span><span class="boring">          Anchor::Middle,                // pivot
</span><span class="boring">          0f32,                          // x
</span><span class="boring">          0f32,                          // y
</span><span class="boring">          0f32,                          // z
</span><span class="boring">          100f32,                        // width
</span><span class="boring">          30f32,                         // height
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      /* Create the text */
</span><span class="boring">      let font_handle = world.read_resource::&lt;Loader&gt;().load(
</span><span class="boring">          &quot;font/square.ttf&quot;,
</span><span class="boring">          TtfFormat,
</span><span class="boring">          (),
</span><span class="boring">          &amp;world.read_resource(),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      let ui_text = UiText::new(
</span><span class="boring">          font_handle,                      // font
</span><span class="boring">          String::from(&quot;Simple Button&quot;),    // text
</span><span class="boring">          [1.0f32, 1.0f32, 1.0f32, 0.5f32], // color
</span><span class="boring">          25f32,                            // font_size
</span><span class="boring">          LineMode::Single,                 // line_mode
</span><span class="boring">          Anchor::Middle,                   // align
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      /* Building the entity */
</span><span class="boring">      let btn = world.create_entity()
</span><span class="boring">          .with(ui_transform)
</span><span class="boring">          .with(ui_text)
</span><span class="boring">          .with(Interactable)   
</span><span class="boring">          .build();
</span><span class="boring">
</span><span class="boring">      /* Saving the button in our state struct */
</span><span class="boring">      self.button = Some(btn);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn handle_event(
</span><span class="boring">      &amp;mut self,
</span><span class="boring">      _data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;,
</span><span class="boring">      event: StateEvent) -&gt; SimpleTrans {
</span><span class="boring">      if let StateEvent::Ui(ui_event) = event {
</span><span class="boring">          let is_target = ui_event.target == self.button.unwrap();
</span><span class="boring">
</span><span class="boring">           match ui_event.event_type {
</span><span class="boring">              UiEventType::Click if is_target =&gt; {
</span><span class="boring">              /* . . . */
</span><span class="boring">              },
</span><span class="boring">              _ =&gt; {
</span><span class="boring">                  return SimpleTrans::None;
</span><span class="boring">              },  
</span><span class="boring">          };
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      SimpleTrans::None
</span><span class="boring">  }
</span>
    fn on_pause(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = data.world;
        let mut hiddens = world.write_storage::&lt;Hidden&gt;();

        if let Some(btn) = self.button {
            let _ = hiddens.insert(btn, Hidden);
        }
    }
}
</code></pre>
<p>The same goes for <code>on_resume</code> if we actually want to redisplay the button:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">  assets::{AssetStorage, Loader},
</span><span class="boring">  core::Hidden,
</span><span class="boring">  ecs::{Entity, World, WorldExt},
</span><span class="boring">  ui::{Anchor, FontHandle, Interactable, LineMode, TtfFormat, UiEventType, UiText, UiTransform},
</span><span class="boring">  prelude::{Builder, GameData, SimpleState, StateData, SimpleTrans},
</span><span class="boring">  StateEvent
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct MenuState {
</span><span class="boring">  button: Option&lt;Entity&gt;,
</span><span class="boring">}
</span>impl SimpleState for MenuState {
    // ...
<span class="boring">  fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
</span><span class="boring">      let world = data.world;
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">      /* Create the transform */
</span><span class="boring">      let ui_transform = UiTransform::new(
</span><span class="boring">          String::from(&quot;simple_button&quot;), // id
</span><span class="boring">          Anchor::Middle,                // anchor
</span><span class="boring">          Anchor::Middle,                // pivot
</span><span class="boring">          0f32,                          // x
</span><span class="boring">          0f32,                          // y
</span><span class="boring">          0f32,                          // z
</span><span class="boring">          100f32,                        // width
</span><span class="boring">          30f32,                         // height
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      /* Create the text */
</span><span class="boring">      let font_handle = world.read_resource::&lt;Loader&gt;().load(
</span><span class="boring">          &quot;font/square.ttf&quot;,
</span><span class="boring">          TtfFormat,
</span><span class="boring">          (),
</span><span class="boring">          &amp;world.read_resource(),
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      let ui_text = UiText::new(
</span><span class="boring">          font_handle,                      // font
</span><span class="boring">          String::from(&quot;Simple Button&quot;),    // text
</span><span class="boring">          [1.0f32, 1.0f32, 1.0f32, 0.5f32], // color
</span><span class="boring">          25f32,                            // font_size
</span><span class="boring">          LineMode::Single,                 // line_mode
</span><span class="boring">          Anchor::Middle,                   // align
</span><span class="boring">      );
</span><span class="boring">
</span><span class="boring">      /* Building the entity */
</span><span class="boring">      let btn = world.create_entity()
</span><span class="boring">          .with(ui_transform)
</span><span class="boring">          .with(ui_text)
</span><span class="boring">          .with(Interactable)   
</span><span class="boring">          .build();
</span><span class="boring">
</span><span class="boring">      /* Saving the button in our state struct */
</span><span class="boring">          self.button = Some(btn);
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn handle_event(
</span><span class="boring">  &amp;mut self,
</span><span class="boring">  _data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;,
</span><span class="boring">  event: StateEvent) -&gt; SimpleTrans {
</span><span class="boring">      if let StateEvent::Ui(ui_event) = event {
</span><span class="boring">          let is_target = ui_event.target == self.button.unwrap();
</span><span class="boring">
</span><span class="boring">          match ui_event.event_type {
</span><span class="boring">              UiEventType::Click if is_target =&gt; {
</span><span class="boring">                  /* . . . */
</span><span class="boring">              },
</span><span class="boring">              _ =&gt; {
</span><span class="boring">                  return SimpleTrans::None;
</span><span class="boring">              },  
</span><span class="boring">          };
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      SimpleTrans::None
</span><span class="boring">  }
</span><span class="boring">
</span><span class="boring">  fn on_pause(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
</span><span class="boring">  let world = data.world;
</span><span class="boring">  let mut hiddens = world.write_storage::&lt;Hidden&gt;();
</span><span class="boring">
</span><span class="boring">  if let Some(btn) = self.button {
</span><span class="boring">     let _ = hiddens.insert(btn, Hidden);
</span><span class="boring">  }
</span><span class="boring">}
</span>
    fn on_resume(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = data.world; 	
        let mut hiddens = world.write_storage::&lt;Hidden&gt;();

        if let Some(btn) = self.button {
            let _ = hiddens.remove(btn);
        }
    }
}
</code></pre>
<p>This should provide you with the basic knowledge on building the UI.</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>Without a doubt, Amethyst contains many concepts for you to understand and remember. During development, normally each concept's types are written in its own module.</p>
<p>To test that these types work properly often requires them to be run in an Amethyst application. By now you <em>know</em> that there is much boilerplate required to setting up an application simply to test a single system.</p>
<p>The <code>amethyst_test</code> crate provides support to write tests ergonomically and expressively.</p>
<p>The following shows a simple example of testing a <code>State</code>. More examples are in following pages.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate amethyst_test;
</span><span class="boring">
</span><span class="boring">use std::marker::PhantomData;
</span><span class="boring">
</span><span class="boring">use amethyst_test::prelude::*;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct LoadResource;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct LoadingState;
</span><span class="boring">
</span><span class="boring">impl LoadingState {
</span><span class="boring">    fn new() -&gt; Self {
</span><span class="boring">        LoadingState
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, 'b, E&gt; State&lt;GameData&lt;'a, 'b&gt;, E&gt; for LoadingState
</span><span class="boring">where
</span><span class="boring">    E: Send + Sync + 'static,
</span><span class="boring">{
</span><span class="boring">    fn update(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; Trans&lt;GameData&lt;'a, 'b&gt;, E&gt; {
</span><span class="boring">        data.data.update(&amp;data.world);
</span><span class="boring">
</span><span class="boring">        data.world.insert(LoadResource);
</span><span class="boring">
</span><span class="boring">        Trans::Pop
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn loading_state_adds_load_resource() -&gt; Result&lt;(), Error&gt; {
    AmethystApplication::blank()
        .with_state(|| LoadingState::new())
        .with_assertion(|world| {
            world.read_resource::&lt;LoadResource&gt;();
        })
        .run()
}
</code></pre>
<h2><a class="header" href="#anatomy-of-an-amethyst-test-function" id="anatomy-of-an-amethyst-test-function">Anatomy of an Amethyst Test Function</a></h2>
<p>The Amethyst application is initialized with one of the following functions, each providing a different set of bundles:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate amethyst_test;
</span><span class="boring">
</span>use amethyst_test::prelude::*;

#[test]
fn test_name() {
    // Start with no bundles
    AmethystApplication::blank();

    // Start with the following bundles:
    //
    // * `TransformBundle`
    // * `InputBundle`
    // * `UiBundle`
    //
    // The type parameters here are the Axis and Action types for the
    // `InputBundle` and `UiBundle`.
    use amethyst::input::StringBindings;
    AmethystApplication::ui_base::&lt;StringBindings&gt;();

    // If you need types from the rendering bundle, make sure you have
    // the `&quot;test-support&quot;` feature enabled:
    //
    // ```toml
    // # Cargo.toml
    // amethyst = { version = &quot;..&quot;, features = [&quot;test-support&quot;] }
    // ```
    //
    // Then you can include the `RenderEmptyBundle`:
    use amethyst::renderer::{types::DefaultBackend, RenderEmptyBundle};
    AmethystApplication::blank()
        .with_bundle(RenderEmptyBundle::&lt;DefaultBackend&gt;::new());
}
</code></pre>
<p>Next, attach the logic for your test using the various <code>.with_*(..)</code> methods:</p>
<pre><code class="language-rust ignore">#[test]
fn test_name() {
    let visibility = false; // Whether the window should be shown
    AmethystApplication::render_base::&lt;String, String, _&gt;(&quot;test_name&quot;, visibility)
        .with_bundle(MyBundle::new())                // Registers a bundle.
        .with_bundle_fn(|| MyNonSendBundle::new())   // Registers a `!Send` bundle.
        .with_resource(MyResource::new())            // Adds a resource to the world.
        .with_system(|_| MySystem::new(), &quot;my_sys&quot;, &amp;[]) // Registers a system
                                                     // with the main dispatcher

        // These are run in the order they are invoked.
        // You may invoke them multiple times.
        .with_setup(|world| { /* do something */ })
        .with_state(|| MyState::new())
        .with_effect(|world| { /* do something */ })
        .with_assertion(|world| { /* do something */ })
         // ...
}
</code></pre>
<p>Finally, call <code>.run()</code> to run the application. This returns <code>amethyst::Result&lt;()&gt;</code>, so we return that as part of the function:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate amethyst_test;
</span><span class="boring">
</span><span class="boring">use amethyst::Error;
</span><span class="boring">use amethyst_test::prelude::*;
</span><span class="boring">
</span>#[test]
fn test_name() -&gt; Result&lt;(), Error&gt; {
    let visibility = false; // Whether the window should be shown
    AmethystApplication::render_base(&quot;test_name&quot;, visibility)
        // ...
        .run()
}
</code></pre>
<h1><a class="header" href="#test-examples" id="test-examples">Test Examples</a></h1>
<h2><a class="header" href="#testing-a-bundle" id="testing-a-bundle">Testing a <code>Bundle</code></a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate amethyst_test;
</span><span class="boring">
</span><span class="boring">use amethyst_test::prelude::*;
</span><span class="boring">use amethyst::{
</span><span class="boring">    core::bundle::SystemBundle,
</span><span class="boring">    core::SystemDesc,
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct ApplicationResource;
</span><span class="boring">
</span><span class="boring">#[derive(Debug, SystemDesc)]
</span><span class="boring">#[system_desc(insert(ApplicationResource))]
</span><span class="boring">struct MySystem;
</span><span class="boring">
</span><span class="boring">impl&lt;'s&gt; System&lt;'s&gt; for MySystem {
</span><span class="boring">    type SystemData = ReadExpect&lt;'s, ApplicationResource&gt;;
</span><span class="boring">
</span><span class="boring">    fn run(&amp;mut self, _: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Debug)]
struct MyBundle;

impl&lt;'a, 'b&gt; SystemBundle&lt;'a, 'b&gt; for MyBundle {
    fn build(self, world: &amp;mut World, builder: &amp;mut DispatcherBuilder&lt;'a, 'b&gt;) -&gt; Result&lt;(), Error&gt; {
        // System that adds `ApplicationResource` to the `World`
        builder.add(MySystem.build(world), &quot;my_system&quot;, &amp;[]);
        Ok(())
    }
}

// #[test]
fn bundle_registers_system_with_resource() -&gt; Result&lt;(), Error&gt; {
    AmethystApplication::blank()
        .with_bundle(MyBundle)
        .with_assertion(|world| {
            // The next line would panic if the resource wasn't added.
            world.read_resource::&lt;ApplicationResource&gt;();
        })
        .run()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    bundle_registers_system_with_resource();
</span><span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#testing-a-system" id="testing-a-system">Testing a <code>System</code></a></h2>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate amethyst_test;
</span><span class="boring">
</span><span class="boring">use amethyst_test::prelude::*;
</span><span class="boring">use amethyst::{
</span><span class="boring">    core::SystemDesc,
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">
</span>struct MyComponent(pub i32);

impl Component for MyComponent {
    type Storage = DenseVecStorage&lt;Self&gt;;
}

#[derive(Debug, SystemDesc)]
struct MySystem;
impl&lt;'s&gt; System&lt;'s&gt; for MySystem {
    type SystemData = WriteStorage&lt;'s, MyComponent&gt;;
    fn run(&amp;mut self, mut my_component_storage: Self::SystemData) {
        for mut my_component in (&amp;mut my_component_storage).join() {
            my_component.0 += 1
        }
    }
}

// #[test]
fn system_increases_component_value_by_one() -&gt; Result&lt;(), Error&gt; {
    AmethystApplication::blank()
        .with_system(MySystem, &quot;my_system&quot;, &amp;[])
        .with_effect(|world| {
            let entity = world.create_entity().with(MyComponent(0)).build();
            world.insert(EffectReturn(entity));
        })
        .with_assertion(|world| {
            let entity = world.read_resource::&lt;EffectReturn&lt;Entity&gt;&gt;().0.clone();

            let my_component_storage = world.read_storage::&lt;MyComponent&gt;();
            let my_component = my_component_storage
                .get(entity)
                .expect(&quot;Entity should have a `MyComponent` component.&quot;);

            // If the system ran, the value in the `MyComponent` should be 1.
            assert_eq!(1, my_component.0);
        })
        .run()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    system_increases_component_value_by_one();
</span><span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#testing-a-system-in-a-custom-dispatcher" id="testing-a-system-in-a-custom-dispatcher">Testing a <code>System</code> in a Custom Dispatcher</a></h3>
<p>This is useful when your system must run <em>after</em> some setup has been done, for example adding a resource:</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate amethyst_test;
</span><span class="boring">
</span><span class="boring">use amethyst_test::prelude::*;
</span><span class="boring">use amethyst::{
</span><span class="boring">    core::SystemDesc,
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::prelude::*,
</span><span class="boring">    prelude::*,
</span><span class="boring">    Error,
</span><span class="boring">};
</span><span class="boring">
</span>// !Default
struct MyResource(pub i32);

#[derive(Debug, SystemDesc)]
struct MySystem;

impl&lt;'s&gt; System&lt;'s&gt; for MySystem {
    type SystemData = WriteExpect&lt;'s, MyResource&gt;;

    fn run(&amp;mut self, mut my_resource: Self::SystemData) {
        my_resource.0 += 1
    }
}

// #[test]
fn system_increases_resource_value_by_one() -&gt; Result&lt;(), Error&gt; {
    AmethystApplication::blank()
        .with_setup(|world| {
            world.insert(MyResource(0));
        })
        .with_system_single(MySystem, &quot;my_system&quot;, &amp;[])
        .with_assertion(|world| {
            let my_resource = world.read_resource::&lt;MyResource&gt;();

            // If the system ran, the value in the `MyResource` should be 1.
            assert_eq!(1, my_resource.0);
        })
        .run()
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    system_increases_resource_value_by_one();
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#glossary" id="glossary">Glossary</a></h1>
<h2><a class="header" href="#data-driven-design" id="data-driven-design">Data-driven design</a></h2>
<p>Describes a program that has its logic defined largely in data rather than in
compiled code. Ideally, this would permit the user to edit their code and
resources using offline tools and have the program hot-reload the changes at
run-time for instant feedback without the need for recompilation. The bare
minimum qualification for a data-driven program is the ability to read external
content (text files, scripts, byte streams) and mutate its behavior accordingly.</p>
<h2><a class="header" href="#data-oriented-programming" id="data-oriented-programming">Data-oriented programming</a></h2>
<p>Not to be confused with data-driven design, data-oriented programming is a
programming paradigm, like object-oriented programming (OOP) or procedural
programming. Where OOP focuses on modeling a problem in terms of interacting
objects, and procedural programming tries to model a problem in terms of
sequential or recursive steps or procedures, data-oriented programming shifts
the focus towards the data being operated on: the data type, its memory layout,
how it will be processed. Software written in a data-oriented manner tends
toward high-throughput pipelining, modularity, separation of concerns, and
massive parallelism. If architected correctly, data-oriented software can be
very cache-friendly and easy to scale on systems with multiple cores.</p>
<blockquote>
<p>Note: Data-oriented programming does not necessarily imply that a program is
data-driven. Data-driven behavior can be implemented with any programming
approach you like.</p>
</blockquote>
<h2><a class="header" href="#entity-component-system-ecs-model" id="entity-component-system-ecs-model">Entity-component-system (ECS) model</a></h2>
<p>Describes a game programming design pattern invented as a reaction to the
deep-rooted problems with using <em>inheritance</em> (is-a relationship) to represent
game objects, including the <a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">deadly diamond of death</a> and <a href="https://en.wikipedia.org/wiki/God_object">god objects</a>.
The inheritance-based approach was especially common in the game industry during
the 1990's and early 2000's.</p>
<p>This alternative model makes use of <em>composition</em> (has-a relationship) instead
of inheritance to represent objects in the game world, flattening the hierarchy
and eliminating the problems above, while increasing flexibility. The holistic
ECS approach is broken into three key pieces:</p>
<ol>
<li><em>Entity</em>: Represents a single object in the game world. Has no functionality
on its own. The world owns a collection of entities (either in a flat list or
a hierarchy). Each entity has a unique identifier or name, for the sake of
ease of use.</li>
<li><em>Component</em>: A plain-old-data structure that describes a certain trait an
entity can have. Can be &quot;attached&quot; to entities to grant them certain
abilities, e.g. a <code>Light</code> component contains parameters to make an entity
glow, or a <code>Collidable</code> component can grant an entity collision detection
properties. These components <em>do not</em> have any logic. They contain only data.</li>
<li><em>System</em>: This is where the magic happens! Systems are centralized game engine
subsystems that perform a specific function, such as rendering, physics, audio,
etc. Every frame, they process each entity in the game world looking for
components that are relevant to them, reading their contents, and performing
actions. For example, a <code>Rendering</code> system could search for all entities that have
<code>Light</code>, <code>Mesh</code>, or <code>Emitter</code> components and draw them to the screen.</li>
</ol>
<p>This approach could potentially be stretched to fit the model-view-controller
(MVC) paradigm popular in GUI and Web development circles: entities and
components together represent the model, and systems represent either views
(<code>Rendering</code>, <code>Audio</code>) or controllers (<code>Input</code>, <code>AI</code>, <code>Physics</code>), depending on
their purpose.</p>
<p>Another great advantage of the ECS model is the ability to rapidly prototype
a game simply by describing objects' characteristics in terms of creating
entities and attaching components to them, with very little game code involved.
And all of this data can be easily serialized or de-serialized into a
human-friendly plain text format like <a href="https://github.com/ron-rs/ron">RON</a> (Json derivative).</p>
<p>For more detailed explanations of entity-component-system designs, please
<a href="https://www.reddit.com/r/rust/comments/43p2fq/this_week_in_amethyst_3/czkc4hj">see this great post on Reddit</a> and <a href="http://gamedev.stackexchange.com/questions/31473/what-is-the-role-of-systems-in-a-component-based-entity-architecture/31491#31491">this Stack Overflow answer</a>.</p>
<h1><a class="header" href="#appendix-a-config-files" id="appendix-a-config-files">Appendix A: Config Files</a></h1>
<p>In the <a href="https://github.com/amethyst/amethyst/tree/master/examples/pong">full Pong example</a>, the paddle sizes, ball sizes, colors, and arena size are all hard-coded 
into the implementation. This means that if you want to change any of these, you need to recompile the 
project. Wouldn't it be nice to not have to recompile the project each time you wanted to change one or all 
of these things?</p>
<p>Luckily, Amethyst uses <a href="https://docs.rs/ron/0.3.0/ron/">RON</a> configuration files and has infrastructure in the form of the 
<a href="https://docs.rs/amethyst_config/0.6.0/amethyst_config/trait.Config.html">Config</a> trait to help us implement our own config files.</p>
<h2><a class="header" href="#structure-of-the-config-file" id="structure-of-the-config-file">Structure of the Config File</a></h2>
<p>The existing example uses the following constants:</p>
<pre><code class="language-rust ignore">const ARENA_HEIGHT: f32 = 100.0;
const ARENA_WIDTH: f32 = 100.0;
const PADDLE_HEIGHT: f32 = 15.0;
const PADDLE_WIDTH: f32 = 2.5;
const PADDLE_VELOCITY: f32 = 75.0;
const PADDLE_COLOR: [f32; 4] = [0.0, 0.0, 1.0, 1.0];

const BALL_VELOCITY_X: f32 = 75.0;
const BALL_VELOCITY_Y: f32 = 50.0;
const BALL_RADIUS: f32 = 2.5;
const BALL_COLOR: [f32; 4] = [1.0, 0.0, 0.0, 1.0];
</code></pre>
<p>to specify the look of the game. We want to replace this with something more flexible in the form of a config 
file. To start, let's create a new file, <code>config.rs</code>, to hold our configuration structures. Add the following 
<code>use</code> statements to the top of this file:</p>
<pre><code class="language-rust ignore">use std::path::Path;

use amethyst::config::Config;
</code></pre>
<p>For this project, we'll be placing a <code>config.ron</code> file in the same location as the <code>display.ron</code> and 
<code>input.ron</code> files (likely the <code>config/</code> folder).</p>
<h2><a class="header" href="#chapters-1" id="chapters-1">Chapters</a></h2>
<ul>
<li><a href="appendices/./a_config_files/arena_config.html">Adding an ArenaConfig</a></li>
<li><a href="appendices/./a_config_files/ball_config.html">Adding a Ball Config</a></li>
<li><a href="appendices/./a_config_files/paddle_configs.html">Adding Paddle Configs</a></li>
</ul>
<h1><a class="header" href="#adding-an-arena-config" id="adding-an-arena-config">Adding an Arena Config</a></h1>
<p>To begin with, let's make the <code>Arena</code> dimensions configurable. Add this structure to a new file <code>config.rs</code>.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Deserialize, Serialize)]
struct ArenaConfig {
    pub height: f32,
    pub width: f32,
}

impl Default for ArenaConfig {
    fn default() -&gt; Self {
        ArenaConfig {
            height: 100.0,
            width: 100.0,
        }
    }
}
</code></pre>
<p>The default values match the values used in the full example, so if we don't use a config file things will
look just like the Pong example. Another option would be to use <a href="https://serde.rs/attr-default.html"><code>[#serde(default)]</code></a>, which allows
you to set the default value of a field if that field is not present in the config file. This is different
than the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait in that you can set default values for some fields while requiring others
be present. For now though, let's just use the <code>Default</code> trait.</p>
<h2><a class="header" href="#adding-the-config-to-the-world" id="adding-the-config-to-the-world">Adding the Config to the World</a></h2>
<p>Now, in <code>main.rs</code>, add the following lines:</p>
<pre><code class="language-rust ignore">use crate::config::ArenaConfig;
</code></pre>
<p>We'll need to load the config at startup, so let's add this to the <code>run</code> function in <code>main.rs</code></p>
<pre><code class="language-rust ignore">let arena_config = ArenaConfig::load(&amp;config)?;
</code></pre>
<p>Now that we have loaded our config, we want to add it to the world so other modules can access
it. We do this by adding the config as a resource during <code>Application</code> creation:</p>
<pre><code class="language-rust ignore">    .with_resource(arena_config)
    .with_bundle(PongBundle::default())?
</code></pre>
<p>Now for the difficult part: replacing every use of <code>ARENA_WIDTH</code> and <code>ARENA_HEIGHT</code> with our config object.
First, let's change our initialisation steps in <code>pong.rs</code>.</p>
<p>Add the following line to the top of <code>pong.rs</code>:</p>
<pre><code class="language-rust ignore">use crate::config::ArenaConfig;
</code></pre>
<p>Now, in the <code>initialise_paddles()</code> function, add the following lines after the initialisation of the
<code>left_transform</code> and <code>right_transform</code>.</p>
<pre><code class="language-rust ignore">let (arena_height, arena_width) = {
    let config = &amp;world.read_resource::&lt;ArenaConfig&gt;();
    (config.height, config.width)
};
</code></pre>
<p>Now replace all references to <code>ARENA_HEIGHT</code> with <code>arena_height</code> and all references to <code>ARENA_WIDTH</code> with
<code>arena_width</code>. Do this for each initialisation function in <code>pong.rs</code>.</p>
<h2><a class="header" href="#accessing-config-files-from-systems" id="accessing-config-files-from-systems">Accessing Config Files from Systems</a></h2>
<p>It is actually simpler to access a Config file from a system than via the <code>World</code> directly. To access
it in the <code>System</code>'s <code>run()</code> function, add it to the <code>SystemData</code> type. This is what the <code>BounceSystem</code> looks
like when it wants to access the <code>ArenaConfig</code>.</p>
<pre><code class="language-rust ignore">use crate::config::ArenaConfig;
...
type SystemData = (
    WriteStorage&lt;'s, Ball&gt;,
    ReadStorage&lt;'s, Paddle&gt;,
    ReadStorage&lt;'s, Transform&gt;,
    Read&lt;'s, AssetStorage&lt;Source&gt;&gt;,
    ReadExpect&lt;'s, Sounds&gt;,
    Read&lt;'s, Option&lt;Output&gt;&gt;,
    Read&lt;'s, ArenaConfig&gt;,
);
...
fn run(&amp;mut self,
       (mut balls, paddles, transforms, storage, sounds, audio_output, arena_config): SystemData) {
</code></pre>
<p>Now, in the <code>run()</code> function, replace the reference to <code>ARENA_HEIGHT</code> with <code>arena_config.height</code>.</p>
<p>Add <code>Read&lt;'s, ArenaConfig&gt;</code> to the <code>WinnerSystem</code> and <code>PaddleSystem</code> as well, replacing the reference to
<code>ARENA_WIDTH</code> with <code>arena_config.width</code>.</p>
<h2><a class="header" href="#making-configron" id="making-configron">Making <code>config.ron</code></a></h2>
<p>Now for the final part: actually creating our <code>config.ron</code> file. This will be very simple right now, and
expand as we add more configurable items. For now, just copy and paste the following into a new file. Feel
free to modify the height and width if you want.</p>
<pre><code class="language-ignore">arena: (
    height: 100.0,
    width: 100.0,
)
</code></pre>
<h1><a class="header" href="#adding-a-ball-config" id="adding-a-ball-config">Adding a Ball Config</a></h1>
<p>For simplicity, we will wrap all of our Config objects into a single <code>PongConfig</code> object backed by a single
<code>config.ron</code> file, but know that you can just as easily keep them in separate files and read from each file
separately.</p>
<p>To prepare for our <code>BallConfig</code>, add the following line to the top of <code>config.rs</code>:</p>
<pre><code class="language-rust ignore">use amethyst::core::math::Vector2;
</code></pre>
<p>The <code>BallConfig</code> will replace the <code>BALL_VELOCITY_X</code>, <code>BALL_VELOCITY_Y</code>, <code>BALL_RADIUS</code>, and <code>BALL_COLOR</code>
variables. We'll use a <a href="https://nalgebra.org/rustdoc/nalgebra/base/type.Vector2.html"><code>Vector2</code></a> to store the velocity for simplicity and to demonstrate how to add
a non-trivial data type to a RON file. The <code>BALL_COLOR</code> was originally an array, but [Serde][serde] and RON
handle arrays as tuples, so it will read in a tuple and convert the color values to an array if needed by a
particular function (e.g., in <code>pong.rs</code>).</p>
<pre><code class="language-rust ignore">#[derive(Debug, Deserialize, Serialize)]
pub struct BallConfig {
    pub velocity: Vector2&lt;f32&gt;,
    pub radius: f32,
    pub color: (f32, f32, f32, f32),
}
</code></pre>
<p>We'll also add the <code>Default</code> trait to this config that will match what the full example uses.</p>
<pre><code class="language-rust ignore">impl Default for BallConfig {
    fn default() -&gt; Self {
        BallConfig {
            velocity: Vector2::new(75.0, 50.0),
            radius: 2.5,
            color: (1.0, 0.0, 0.0, 1.0),
        }
    }
}
</code></pre>
<p>Still in <code>config.rs</code>, add the following structure definition at the very bottom. This structure will be
backed by the whole <code>config.ron</code> file.</p>
<pre><code class="language-rust ignore">#[derive(Debug, Default, Deserialize, Serialize)]
pub struct PongConfig {
    pub arena: ArenaConfig,
    pub ball: BallConfig,
}
</code></pre>
<h2><a class="header" href="#replacing-ball-constants" id="replacing-ball-constants">Replacing Ball Constants</a></h2>
<p>Now we need to replace our usage of the <code>BALL_*</code> constants with our new <code>BallConfig</code>.</p>
<p>We use these values in <code>pong.rs</code> in the <code>initialise_ball()</code> function, so the substitution is even simpler than
the <code>ArenaConfig</code>.</p>
<p>In <code>pong.rs</code>, underneath our loading of the <code>ArenaConfig</code>, add the following lines</p>
<pre><code class="language-rust ignore">let (velocity_x, velocity_y, radius, color) = {
    let config = world.read_resource::&lt;BallConfig&gt;();
    let c: [f32; 4] = [
        config.color.0,
        config.color.1,
        config.color.2,
        config.color.3,
    ];
    (config.velocity.x, config.velocity.y, config.radius, c)
};
</code></pre>
<p>Our functions expect a <code>[f32; 4]</code> array, so we had to convert the tuple to an array. This is relatively
simple to do, but for more complex arrays it might be worth it to add a function to the <code>impl BallConfig</code> to
avoid duplicating this effort.</p>
<p>Now, within the <code>initialise_ball</code> function, replace <code>BALL_VELOCITY_X</code> with <code>velocity_x</code>, <code>BALL_VELOCITY_Y</code>
with <code>velocity_y</code>, <code>BALL_RADIUS</code> with <code>radius</code>, and <code>BALL_COLOR</code> with <code>color</code>.</p>
<h2><a class="header" href="#modifying-the-initialisation" id="modifying-the-initialisation">Modifying the initialisation</a></h2>
<p>Now we will modify our application initialisation. We don't want everyone to always access all the config files, so we need to
add each resource separately so systems can use only what they want.</p>
<p>First, we need to change what <code>main.rs</code> is using. Change</p>
<pre><code class="language-rust ignore">use crate::config::ArenaConfig;
</code></pre>
<p>to</p>
<pre><code class="language-rust ignore">use crate::config::PongConfig;
</code></pre>
<p>Now, modify the <code>run()</code> function, from</p>
<pre><code class="language-rust ignore">let arena_config = ArenaConfig::load(&amp;config)?;
[..]
    .with_bundle(PongBundle::default())?
[..]
    .with_resource(arena_config)
</code></pre>
<p>to</p>
<pre><code class="language-rust ignore">let pong_config = PongConfig::load(&amp;config)?;
[..]
    .with_bundle(PongBundle::default())?
[..]
    .with_resource(pong_config.arena)
    .with_resource(pong_config.ball)
</code></pre>
<h2><a class="header" href="#adding-the-ballconfig-to-configron" id="adding-the-ballconfig-to-configron">Adding the BallConfig to <code>config.ron</code></a></h2>
<p>Now we need to modify our configuration file to allow multiple structures to be included. This is actually
very easy with RON; we just add an additional level of nesting.</p>
<pre><code class="language-ignore">(
    arena: (
        height: 100.0,
        width: 100.0,
    ),
    ball: (
        velocity: Vector2(
            x: 75.0,
            y: 50.0,
        ),
        radius: 2.5,
        color: (1.0, 0.647, 0.0, 1.0),
    ),
)
</code></pre>
<p>This configuration sets the ball to be orange, while retaining the same size and velocity as the original
example.</p>
<h1><a class="header" href="#adding-paddle-configs" id="adding-paddle-configs">Adding Paddle Configs</a></h1>
<p>We're finally going to add a configuration struct for our Paddles. Because our Pong clone supports two 
players, we should let them configure each separately. Add the following to the <code>config.rs</code> file:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Deserialize, Serialize)]
pub struct PaddleConfig {
    pub height: f32,
    pub width: f32,
    pub velocity: f32,
    pub color: (f32, f32, f32, f32),
}

impl Default for PaddleConfig {
    fn default() -&gt; Self {
        PaddleConfig {
            height: 15.0,
            width: 2.5,
            velocity: 75.0,
            color: (0.0, 0.0, 1.0, 1.0),
        }
    }
}
</code></pre>
<p>Just like the <code>BallConfig</code>, we need to read in the color as a tuple instead of an array.</p>
<p>Now, to allow us to have two separate <code>PaddleConfig</code>s, we will wrap them in a bigger structure as follows:</p>
<pre><code class="language-rust ignore">#[derive(Debug, Default, Deserialize, Serialize)]
pub struct PaddlesConfig {
    pub left: PaddleConfig,
    pub right: PaddleConfig,
}
</code></pre>
<p>Now we need to add the <code>PaddlesConfig</code> to our <code>PongConfig</code> as shown below</p>
<pre><code class="language-rust ignore">pub struct PongConfig {
    pub arena: ArenaConfig,
    pub ball: BallConfig,
    pub paddles: PaddlesConfig,
}
</code></pre>
<p>and modify the <code>main.rs</code>'s <code>run()</code> function to add our <code>PaddleConfig</code>s. </p>
<pre><code class="language-rust ignore">    .with_resource(pong_config.arena)
    .with_resource(pong_config.ball)
    .with_resource(pong_config.paddles)
    .with_bundle(PongBundle::default())?
</code></pre>
<p>We add the <code>PaddlesConfig</code> to the <code>World</code>, rather than as separate <code>left</code> and <code>right</code> configurations because
<code>System</code>s can only access resources with ID 0. Any resource added using <a href="https://docs.rs/specs/0.12.0/specs/struct.World.html#method.insert"><code>World::add_resource</code></a>
is added using a default ID of 0. You must use <a href="https://docs.rs/specs/0.12.0/specs/struct.World.html#method.insert_with_id"><code>World::add_resource_with_id</code></a> to add multiple
resources of the same type, but then the <code>System</code>s cannot properly differentiate between them.</p>
<h2><a class="header" href="#replacing-constants-with-configs" id="replacing-constants-with-configs">Replacing Constants with Configs</a></h2>
<p>Replacing all instances of <code>PADDLE_*</code> will be similar to the <code>BallConfig</code>, as we only use those values for 
creating the paddle entities. However, we will need to separate the <code>PaddlesConfig</code> into <code>left</code> and <code>right</code>.
To avoid issues with the borrow checker, we read the <code>PaddlesConfig</code> once and copy all of the values, 
unwrapping them in one big assignment statement.
In <code>initialise_paddles()</code> in <code>pong.rs</code>, add this code below reading the <code>ArenaConfig</code>.</p>
<pre><code class="language-rust ignore">let (
    left_height,
    left_width,
    left_velocity,
    left_color,
    right_height,
    right_width,
    right_velocity,
    right_color,
) = {
    let config = &amp;world.read_resource::&lt;PaddlesConfig&gt;();
    let cl: [f32; 4] = [
        config.left.color.0,
        config.left.color.1,
        config.left.color.2,
        config.left.color.3,
    ];
    let cr: [f32; 4] = [
        config.right.color.0,
        config.right.color.1,
        config.right.color.2,
        config.right.color.3,
    ];
    (
        config.left.height,
        config.left.width,
        config.left.velocity,
        cl,
        config.right.height,
        config.right.width,
        config.right.velocity,
        cr,
    )
};
</code></pre>
<p>Now, within this function, replace</p>
<pre><code class="language-rust ignore">let y = (arena_height - PADDLE_HEIGHT) / 2.0;
</code></pre>
<p>with </p>
<pre><code class="language-rust ignore">let left_y = (arena_height - left_height) / 2.0;
let right_y = (arena_height - right_height) / 2.0;
</code></pre>
<p>You will also need to repeat the calls to <code>create_mesh</code> and 
<code>create_color_material()</code> so that you have a left and right mesh and left
and right color.</p>
<p>Now, use the left- and right-specific values in  the <code>world.create_entity()</code> 
calls.</p>
<h2><a class="header" href="#modifying-configron" id="modifying-configron">Modifying <code>config.ron</code></a></h2>
<p>Now for the final modification of our <code>config.ron</code> file. For fun, let's make the right paddle yellow and
keep the left paddle blue so the final <code>config.ron</code> file will be as follows:</p>
<pre><code class="language-ignore">(
    arena: (
        height: 100.0,
        width: 100.0,
    ),
    ball: (
        velocity: Vector2(
            x: 75.0,
            y: 50.0,
        ),
        radius: 2.5,
        color: (1.0, 0.647, 0.0, 1.0),
    ),
    paddles: (
        left: (
            height: 15.0,
            width: 2.5,
            velocity: 75.0,
            color: (0.0, 0.0, 1.0, 1.0),
        ),
        right: (
            height: 15.0,
            width: 2.5,
            velocity: 75.0,
            color: (0.0, 1.0, 1.0, 1.0),
        ),
    )
)
</code></pre>
<h1><a class="header" href="#appendix-b-migration-notes" id="appendix-b-migration-notes">Appendix B: Migration Notes</a></h1>
<p>At times Amethyst goes through non-trivial changes which may impose additional effort to upgrade. This section contains migration notes to reduce this effort.</p>
<ul>
<li><a href="appendices/b_migration_notes/cgmath_to_nalgebra.html">0.9 to 0.10</a>: <code>cgmath</code> to <code>nalgebra</code> migration</li>
<li><a href="appendices/b_migration_notes/rendy_migration.html">0.10 to 0.12</a>: Rendy migration guide</li>
<li><a href="appendices/b_migration_notes/transform_api_changes.html">0.10 to 0.11</a>: Transform API Changes</li>
<li>[0.11 to 0.12] Float type removed. Search and replace with 'f32'</li>
<li><a href="appendices/b_migration_notes/specs_migration.html">0.12 to 0.13</a>: <code>specs</code> upgraded to <code>0.15</code>.</li>
</ul>
<h1><a class="header" href="#cgmath-to-nalgebra" id="cgmath-to-nalgebra"><code>cgmath</code> to <code>nalgebra</code></a></h1>
<h2><a class="header" href="#how-to-use" id="how-to-use">How To Use</a></h2>
<p>This cheat sheet is split up into the following sections:</p>
<ul>
<li><strong>Type Changes:</strong> Previously you used <code>this::Type</code>, now you use <code>another::Thing</code></li>
<li><strong>Logic Changes:</strong> Previously you had <code>object.method(args)</code>, now you use <code>object.other(stuff)</code></li>
</ul>
<p>Most changes will have accompanying explanations and code examples on how to switch.</p>
<p>This document is by no means exhaustive, so if there is something missing, or if you can clarify any changes, please correct this!</p>
<p>The text is designed to be searchable, so if you are looking for a specific type or method, please use Ctrl + F: <code>TypeName</code>. If you cannot find it in the document, likely we missed it during writing. Please send us a pull request!</p>
<h2><a class="header" href="#type-changes" id="type-changes">Type Changes</a></h2>
<p>Many types retain the same type name, just under the <code>nalgebra</code> namespace:</p>
<pre><code class="language-patch">-use amethyst::core::cgmath::{Vector2, Vector3, Matrix4};
+use amethyst::core::math::{Vector2, Vector3, Matrix4};
</code></pre>
<p>We will not list the names of every type with the same simple name, but will try to list the changes for types whose simple names are different:</p>
<pre><code class="language-patch">-cgmath::Ortho
+math::Orthographic3

-cgmath::PerspectiveFov
+math::Perspective3
</code></pre>
<h2><a class="header" href="#logic-changes" id="logic-changes">Logic Changes</a></h2>
<ul>
<li>
<p><code>cgmath</code> to <code>nalgebra</code> functions:</p>
<pre><code class="language-patch">-Vector3::unit_z()
+Vector3::z()

-matrix4.z.truncate()
+matrix4.column(2).xyz().into()

-matrix4.transform_point(origin)
+matrix4.transform_point(&amp;origin)
</code></pre>
</li>
<li>
<p><code>amethyst::core::transform::Transform</code></p>
<ul>
<li>
<p>Transformation values are accessed / mutated through accessor methods.</p>
<pre><code class="language-patch">-transform.translation = Vector3::new(5.0, 2.0, -0.5);
-transform.scale = Vector3::new(2.0, 2.0, 2.0);
-transform.rotation = Quaternion::new(1.0, 0.0, 0.0, 0.0);
+transform.set_translation_xyz(5.0, 2.0, -0.5);
+transform.set_scale(2.0, 2.0, 2.0);
+transform.set_rotation(Unit::new_normalize(Quaternion::new(1.0, 0.0, 0.0, 0.0)));

// Translations
-transform.translation = Vector3::new(0.0, 0.0, 0.0);
+*transform.translation_mut() = Vector3::new(0.0, 0.0, 0.0);

-transform_0.translation - transform_1.translation
+transform_0.translation() - transform_1.translation()

-transform.translation[0] = x;
+transform.set_translation_x(position.x);

-translation.x += 0.1;
-translation.y -= 0.1;
+transform.prepend_translation_x(0.1);
+transform.prepend_translation_y(-0.1);
// or
+transform.translation_mut().x += 0.1;
+transform.translation_mut().y -= 0.1;

-let ball_x = transform.translation[0];
+let ball_x = transform.translation().x;

-transform.set_position(Vector3::new(6.0, 6.0, -6.0));
+transform.set_translation_xyz(6.0, 6.0, -6.0);
// or
*transform.translation_mut() = Vector3::new(6.0, 6.0, -6.0);

// Rotations
-transform.rotation = [1.0, 0.0, 0.0, 0.0].into();
+use amethyst::core::math::{Quaternion, Unit};
+
+*transform.rotation_mut() = Unit::new_normalize(Quaternion::new(
+    1.0, // w
+    0.0, // x
+    0.0, // y
+    0.0, // z
+));

-use amethyst::core::cgmath::Deg;
-
-transform.set_rotation(Deg(75.96), Deg(0.0), Deg(0.0));
+transform.set_rotation_x_axis(1.3257521);
// or
+transform.set_rotation_euler(1.3257521, 0.0, 0.0);

// Scaling
-transform.scale = Vector3::new(1.0, 1.0, 1.0);
+*transform.scale_mut() = Vector3::new(1.0, 1.0, 1.0);
</code></pre>
</li>
<li>
<p><code>amethyst::core::transform::Transform</code> prefabs no longer use labels</p>
<pre><code class="language-patch"> // scene.ron
 data: (
     transform: (
-        translation: (x: 0.0, y: 0.0, z: -4.0),
-        rotation: (s: 0.0, v: (x: 0.0, y: 1.0, z: 0.0),),
-        scale: (x: 4.0, y: 2.0, z: 1.0),
+        translation: (0.0, 0.0, -4.0),
+        rotation: (0.0, 0.0, 1.0, 0.0),
+        scale: (4.0, 2.0, 1.0),
     ),
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>amethyst::renderer::GlobalTransform</code> inverse.</p>
<pre><code class="language-patch">-global.0.invert()
+global.0.try_inverse()
</code></pre>
</li>
<li>
<p><code>amethyst::renderer::Pos*</code> fields use <code>nalgebra</code> types instead of arrays.</p>
<p>Type change:</p>
<pre><code class="language-patch"> pub struct PosTex {
-    pub position: [f32; 3],
-    pub tex_coord: [f32; 2],
+    pub position: Vector3&lt;f32&gt;,
+    pub tex_coord: Vector2&lt;f32&gt;,
 }
</code></pre>
<p>Usage changes:</p>
<pre><code class="language-patch"> PosTex {
-    position: [0.0, 0.0, 0.0],
-    tex_coord: [0.0, 0.0],
+    position: Vector3::new(0.0, 0.0, 0.0),
+    tex_coord: Vector2::new(0.0, 0.0),
 }
</code></pre>
</li>
<li>
<p><code>amethyst::core::math::Matrix4</code> construction.</p>
<pre><code class="language-patch">-Matrix4::from_translation(Vector3::new(x, y, z))
+Matrix4::new_translation(&amp;Vector3::new(x, y, z))

// OR

+use amethyst::core::math::Translation3;
+
+Translation3::new(x, y, z).to_homogeneous()
</code></pre>
</li>
<li>
<p><code>UnitQuarternion::rotation_between</code> is right handed, previously they were left handed.</p>
</li>
<li>
<p>Orthographic projection has changed from <code>(left, right, top, bottom)</code> to <code>(left, right, bottom, top)</code>.</p>
<pre><code class="language-patch"> Projection::orthographic(
     0.0,           // left
     ARENA_WIDTH,   // right
-    ARENA_HEIGHT,  // top
     0.0,           // bottom
+    ARENA_HEIGHT,  // top
 )

-use amethyst::core::cgmath::Ortho;
-
-Ortho { left, right, top, bottom, near, far }
+use amethyst::core::math::Orthographic3;
+
+Orthographic3::new(left, right, bottom, top, near, far)
</code></pre>
</li>
<li>
<p>Perspective projection</p>
<ul>
<li>
<p>Angles are specified in radians:</p>
<pre><code class="language-patch">use amethyst::renderer::Projection;
-amethyst::core::cgmath::Deg;

 Projection::perspective(
     1.33333,
-    Deg(90.0)
+    std::f32::consts::FRAC_PI_2,
 )
</code></pre>
<pre><code class="language-patch">// scene.ron
 data: (
     camera: Perspective((
         aspect: 1.3,
-        fovy: Rad (1.0471975512),
+        fovy: 1.0471975512,
         // ...
     )),
 )
</code></pre>
</li>
<li>
<p>Prefab fields have been renamed:</p>
<pre><code class="language-patch">// scene.ron
 data: (
     camera: Perspective((
         aspect: 1.3,
-        fovy: Rad (1.0471975512),
+        fovy: 1.0471975512,
-        near: 0.1,
-        far: 2000.0,
+        znear: 0.1,
+        zfar: 2000.0,
     )),
 )
</code></pre>
</li>
</ul>
</li>
<li>
<p><code>amethyst::renderer::SpotLight</code> angle has changed from degrees to radians.</p>
<pre><code class="language-patch"> SpotLight {
-    angle: 60.0,
+    angle: std::f32::consts::FRAC_PI_3,
     ..
 }
</code></pre>
</li>
<li>
<p><code>amethyst::renderer::SunLight</code> angle has changed from degrees to radians.</p>
<pre><code class="language-patch"> SunLight {
-    ang_rad: 0.0093,
+    ang_rad: 0.0093_f32.to_radians(),
     ..
 }
</code></pre>
</li>
</ul>
<h1><a class="header" href="#rendy-migration-guide" id="rendy-migration-guide">Rendy: Migration Guide</a></h1>
<h2><a class="header" href="#audio" id="audio">Audio</a></h2>
<ul>
<li><code>AudioFormat</code> no longer exists, you have to use the lower level types -- <code>Mp3Format</code>, <code>WavFormat</code>, <code>OggFormat</code>, <code>FlacFormat</code>.</li>
</ul>
<h2><a class="header" href="#assets-1" id="assets-1">Assets</a></h2>
<ul>
<li><code>SimpleFormat</code> trait has merged into <code>Format</code>.</li>
<li><code>Format::Options</code> associated type has been removed; options are now stored in the format instance.</li>
<li><code>NAME</code> associated constant is now a method call.</li>
<li><code>Format&lt;A&gt;</code> type parameter now takes in <code>Format&lt;D&gt;</code>, where <code>D</code> is <code>A::Data</code>.</li>
<li>Implement <code>import_simple</code> instead of <code>import</code>.</li>
<li><code>Loader::load</code> no longer takes in the <code>Options</code> parameter.</li>
</ul>
<h2><a class="header" href="#input-1" id="input-1">Input</a></h2>
<ul>
<li>
<p><code>Bindings&lt;String, String&gt;</code> is now <code>Bindings&lt;StringBindings&gt;</code>.</p>
</li>
<li>
<p><code>Bindings&lt;AX, AC&gt;</code> is now <code>Bindings&lt;T&gt;</code>, where <code>T</code> is a new type you must implement:</p>
<pre><code class="language-rust ignore">pub struct ControlBindings;

impl BindingTypes for ControlBindings {
    type Axis = PlayerAxisControl;
    type Action = PlayerActionControl;
}
</code></pre>
<p>Diff:</p>
<pre><code class="language-patch">-Bindings&lt;PlayerAxisControl, PlayerActionControl&gt;
+Bindings&lt;ControlBindings&gt;
</code></pre>
</li>
<li>
<p><code>InputBundle</code> type parameters:</p>
<pre><code class="language-patch">-InputBundle::&lt;String, String&gt;::new()
+InputBundle::&lt;StringBindings&gt;::new()
</code></pre>
</li>
<li>
<p><code>UiBundle</code> type parameters:</p>
<pre><code class="language-patch">+use amethyst::renderer::types::DefaultBackend;

-UiBundle::&lt;String, String&gt;::new()
+UiBundle::&lt;DefaultBackend, StringBindings&gt;::new()
</code></pre>
</li>
</ul>
<h2><a class="header" href="#window" id="window">Window</a></h2>
<ul>
<li>
<p><code>DisplayConfig</code>'s <code>fullscreen</code> field is now an <code>Option&lt;MonitorIdent&gt;</code>. <code>MonitorIdent</code> is <code>MonitorIdent(u16, String)</code>, indicating the native monitor display ID, and its <a href="https://docs.rs/winit/0.19.1/winit/struct.MonitorId.html#method.get_name">name</a>.</p>
</li>
<li>
<p><code>WindowBundle</code> is now separate from <code>amethyst_renderer</code>.</p>
<pre><code class="language-rust ignore">use amethyst::window::WindowBundle;

game_data.with_bundle(WindowBundle::from_config_file(display_config_path))?;
</code></pre>
<p>This system is loaded automatically by the <code>RenderToWindow</code> render plugin.</p>
</li>
</ul>
<h2><a class="header" href="#renderer" id="renderer">Renderer</a></h2>
<ul>
<li>
<p><code>amethyst::renderer::VirtualKeyCode</code> is now <code>amethyst::input::VirtualKeyCode</code></p>
</li>
<li>
<p><code>amethyst::renderer::DisplayConfig</code> is now <code>amethyst::window::DisplayConfig</code></p>
</li>
<li>
<p><code>amethyst::renderer::WindowEvent</code> is now <code>amethyst::winit::WindowEvent</code></p>
</li>
<li>
<p><code>amethyst::renderer::Event</code> is no longer re-exported. Use <code>amethyst::winit::Event</code></p>
</li>
<li>
<p><code>amethyst::renderer::Transparent</code> is now under <code>amethyst::renderer::transparent::Transparent</code>.</p>
</li>
<li>
<p><code>amethyst::renderer::Visibility</code> is now under <code>amethyst::renderer::visibility::Visibility</code>.</p>
</li>
<li>
<p><code>TextureHandle</code> type alias no longer exists, use <code>Handle&lt;Texture&gt;</code>.</p>
</li>
<li>
<p><code>Flipped</code> component is removed. You can specify <code>flipped</code> during sprite loading, or mutating <code>Transform</code> at run time.</p>
</li>
<li>
<p>To load a texture in memory, you can't use <code>[0.; 4].into()</code> as the <code>TextureData</code> anymore. Use:</p>
<pre><code class="language-rust ignore">use amethyst::{
    assets::{AssetStorage, Handle, Loader, Prefab, PrefabLoader},
    ecs::World,
    renderer::{
        loaders::load_from_srgba,
        palette::Srgba,
        types::TextureData,
        Texture,
    },
};

let loader = world.read_resource::&lt;Loader&gt;();
let texture_assets = world.read_resource::&lt;AssetStorage&lt;Texture&gt;&gt;();
let texture_builder = load_from_srgba(Srgba::new(0., 0., 0., 0.));
let texture_handle: Handle&lt;Texture&gt; =
    loader.load_from_data(TextureData::from(texture_builder), (), &amp;texture_assets);
</code></pre>
</li>
<li>
<p><code>RenderBundle</code> and <code>Pipeline</code> are gone, now you need to use the <code>RenderingBundle</code>, for example:</p>
<p>In <code>main.rs</code>:</p>
<pre><code class="language-rust ignore">use amethyst::renderer::{types::DefaultBackend, RenderingSystem};

let game_data = GameDataBuilder::default()
    .with_bundle(
        RenderingBundle::&lt;DefaultBackend&gt;::new()
            .with_plugin(
                RenderToWindow::from_config_path(display_config)
                    .with_clear([0.34, 0.36, 0.52, 1.0]),
            )
            .with_plugin(RenderShaded3D::default())
            .with_plugin(RenderDebugLines::default())
            .with_plugin(RenderSkybox::with_colors(
                Srgb::new(0.82, 0.51, 0.50),
                Srgb::new(0.18, 0.11, 0.85),
            )),
    )?;
</code></pre>
</li>
<li>
<p>Render passes can be integrated into amethyst by using the newly introduced <code>RenderPlugin</code> trait, for example:</p>
<pre><code class="language-rust ignore">pub struct RenderCustom {
    target: Target,
}

impl RenderTerrain {
    /// Set target to which 2d sprites will be rendered.
    pub fn with_target(mut self, target: Target) -&gt; Self {
        self.target = target;
        self
    }
}


impl&lt;B: Backend&gt; RenderPlugin&lt;B&gt; for RenderCustom {
    fn on_build&lt;'a, 'b&gt;(
        &amp;mut self,
        builder: &amp;mut DispatcherBuilder&lt;'a, 'b&gt;,
    ) -&gt; Result&lt;(), Error&gt; {
        // You can add systems that are needed by your renderpass here
        Ok(())
    }

    fn on_plan(
        &amp;mut self,
        plan: &amp;mut RenderPlan&lt;B&gt;,
        _factory: &amp;mut Factory&lt;B&gt;,
        _res: &amp;Resources,
    ) -&gt; Result&lt;(), Error&gt; {
        plan.extend_target(self.target, |ctx| {
            ctx.add(RenderOrder::Opaque, DrawCustomDesc::new().builder())?;
            Ok(())
        });
        Ok(())
    }
}
</code></pre>
</li>
<li>
<p><code>RenderBundle::with_sprite_sheet_processor()</code> is replaced by:</p>
<pre><code class="language-rust ignore">game_data.with(
    Processor::&lt;SpriteSheet&gt;::new(),
    &quot;sprite_sheet_processor&quot;,
    &amp;[],
);
</code></pre>
<p>This system is added automatically by each of the 3D render plugins (<code>RenderPbr3D</code>, <code>RenderShaded3D</code>, <code>RenderFlat3D</code>).</p>
</li>
<li>
<p><code>RenderBundle::with_sprite_visibility_sorting()</code> is replaced by:</p>
<pre><code class="language-rust ignore">use amethyst::rendy::sprite_visibility::SpriteVisibilitySortingSystem;

game_data.with(
    SpriteVisibilitySortingSystem::new(),
    &quot;sprite_visibility_system&quot;,
    &amp;[&quot;transform_system&quot;],
);
</code></pre>
<p>This system is added automatically by the <code>RenderFlat2D</code> render plugin.</p>
</li>
<li>
<p>Sprite transparency is no longer a separate flag. Instead of <code>with_transparency</code>, you add a second render pass using <code>DrawFlat2DTransparent</code>. See the <a href="https://github.com/amethyst/amethyst/blob/7ed8432d8eef2b2727d0c4188b91e5823ae03548/examples/sprites_ordered/main.rs#L463-L482"><code>sprites_ordered</code> example</a>.</p>
</li>
</ul>
<p>Camera changes:</p>
<ul>
<li>
<p><code>CameraPrefab</code> is no longer nested:</p>
<pre><code class="language-patch">-camera: Perspective((aspect: 1.3, fovy: 1.0471975512, znear: 0.1, zfar: 2000.0))
+camera: Perspective(aspect: 1.3, fovy: 1.0471975512, znear: 0.1, zfar: 2000.0)
</code></pre>
</li>
<li>
<p><code>nalgebra</code>'s <code>Perspective3</code>/<code>Orthographic3</code> are <em>no longer compatible</em>, as they use OpenGL coordinates instead of Vulkan.</p>
<p>Amethyst now has amethyst::rendy::camera::Orthographic and Perspective, respectively. These types are mostly feature-parity with nalgebra, but correct for vulkan. You can use as_matrix to get the inner Matrix4 value.</p>
</li>
<li>
<p>Camera now stores <code>Projection</code>, which means it is type-safe.</p>
</li>
<li>
<p>You can no longer serialize raw camera matrices, only camera parameter types.</p>
</li>
</ul>
<p>Z-axis direction clarifications:</p>
<ul>
<li>In Vulkan, <code>Z+</code> is away.</li>
<li>in OpenGL, <code>Z-</code> is away.</li>
<li>In amethyst_renderer, <code>Z-</code> is away (world coordinates).</li>
<li>In amethyst_rendy, <code>Z-</code> is away (world coordinates).</li>
</ul>
<h2><a class="header" href="#amethyst-test" id="amethyst-test">Amethyst Test</a></h2>
<ul>
<li>
<p>The <code>render_base</code> function has been changed:</p>
<pre><code class="language-patch">-let visibility = false;
-AmethystApplication::render_base(&quot;test_name&quot;, visibility);
+use amethyst::renderer::{types::DefaultBackend, RenderEmptyBundle};
+AmethystApplication::blank()
+    .with_bundle(RenderEmptyBundle::&lt;DefaultBackend&gt;::new());
</code></pre>
</li>
<li>
<p>The <code>mark_render()</code> and <code>.run()</code> chained call is replaced by a single <code>run_isolated()</code> call.</p>
</li>
</ul>
<h1><a class="header" href="#specs-migration" id="specs-migration">Specs Migration</a></h1>
<ul>
<li>
<p>Specs migration</p>
<p>Quick fix:</p>
<ul>
<li>Add <code>use amethyst::ecs::WorldExt</code> to imports.</li>
<li>Replace <code>world.add_resource</code> with <code>world.insert</code>.</li>
<li><code>use amethyst::ecs::WorldExt;</code> for <code>world.read_resource</code>.</li>
<li>Regex replace <code>\bResources\b</code> with <code>World</code>. Check for false replacements.</li>
<li>Replace <code>world.res</code> with <code>world</code>.</li>
<li>Regex replace <code>\bres\b</code> with <code>world</code>.</li>
</ul>
<p><code>shred-derive</code> is re-exported by <code>amethyst</code>. Migration steps:</p>
<ul>
<li>Remove <code>shred-derive</code> from <code>Cargo.toml</code>.</li>
<li>Remove <code>use amethyst::ecs::SystemData</code> from imports (if present).</li>
<li>Add <code>use amethyst::shred::{ResourceId, SystemData}</code> to imports.</li>
</ul>
</li>
<li>
<p><code>PrefabLoaderSystem</code> is initialized by <code>PrefabLoaderSystemDesc</code>.</p>
<p><strong>Quick fix:</strong></p>
<ul>
<li>Find: <code>PrefabLoaderSystem::&lt;([A-Za-z]+)&gt;::default\(\)</code>,</li>
<li>Replace: <code>PrefabLoaderSystemDesc::&lt;\1&gt;::default()</code></li>
<li>Don't forget to replace <code>with</code> with <code>with_system_desc</code> when adding to GameData.</li>
</ul>
</li>
<li>
<p><code>GltfSceneLoaderSystem</code> is initialized by <code>GltfSceneLoaderSystemDesc</code>.</p>
<p><strong>Quick fix:</strong></p>
<ul>
<li>Find: <code>GltfSceneLoaderSystem::&lt;([A-Za-z]+)&gt;::default\(\)</code>,</li>
<li>Replace: <code>GltfSceneLoaderSystemDesc::&lt;\1&gt;::default()</code></li>
<li>Don't forget to replace <code>with</code> with <code>with_system_desc</code> when adding to GameData.</li>
</ul>
</li>
<li>
<p><code>AmethystApplication::with_setup</code> runs the function before the dispatcher.</p>
<p><strong>Quick fix:</strong></p>
<ul>
<li>Find: <code>with_setup</code>,</li>
<li>Replace: <code>with_effect</code></li>
</ul>
</li>
<li>
<p>Renamed <code>UiTransformBuilder</code> to <code>UiTransformData</code>.</p>
</li>
<li>
<p>Renamed <code>UiTextBuilder</code> to <code>UiTextData</code>.</p>
</li>
<li>
<p>Renamed <code>UiButtonBuilder</code> to <code>UiButtonData</code>.</p>
</li>
</ul>
<h1><a class="header" href="#appendix-c-feature-gates" id="appendix-c-feature-gates">Appendix C: Feature Gates</a></h1>
<p>Various feature gate exist in Amethyst, with different purposes.
In this chapter, we will go through each of the feature gate types.</p>
<h2><a class="header" href="#crate-enabling-feature-gates" id="crate-enabling-feature-gates">Crate Enabling Feature Gates</a></h2>
<p>To reduce compilation times, you can disable features that are not needed for your project.</p>
<p>When compiling, you can use the following Cargo parameters:</p>
<pre><code class="language-ignore">cargo (build/test/run) --no-default-features --features feature1,feature2,feature3
</code></pre>
<p>At the time of writing, the list of features of this type is the following:</p>
<ul>
<li><code>animation</code></li>
<li><code>audio</code></li>
<li><code>gltf</code></li>
<li><code>locale</code></li>
<li><code>network</code></li>
<li><code>renderer</code></li>
<li><code>saveload</code></li>
<li><code>sdl_controller</code></li>
</ul>
<p>The full list of available features is available in the <a href="https://github.com/amethyst/amethyst/blob/master/Cargo.toml">Cargo.toml</a> file.
The available features might change from time to time.</p>
<h2><a class="header" href="#graphics-features" id="graphics-features">Graphics features</a></h2>
<p>Whenever you run your game, you'll need to enable one graphics backend. The following features are
available for the backend:</p>
<ul>
<li><code>empty</code></li>
<li><code>metal</code></li>
<li><code>vulkan</code></li>
</ul>
<p>Rendy has multiple safety checks built-in to detect bugs in the data it gets submitted. However,
those checks can become too costly for a smooth experience with larger games; you can disable
them using the <code>no-slow-safety-checks</code> feature.</p>
<p>Additionally, there's a <code>shader-compiler</code> feature which allows compiling GLSL / HLSL to SPIR-V
shaders. This is only needed if you're planning to compile shaders at runtime. Amethyst's 
built-in shaders come pre-compiled, and you can also precompile your own using <code>glslc</code> (provided 
by <a href="https://github.com/google/shaderc">shaderc</a>). Please note, that on Windows this feature requires <a href="https://ninja-build.org/">Ninja</a> to be installed.</p>
<h2><a class="header" href="#using-amethyst-testing-utility" id="using-amethyst-testing-utility">Using Amethyst testing utility</a></h2>
<p>As described in the <a href="appendices/../testing.html">Testing chapter</a>, Amethyst has several utilities to help you
test an application written using Amethyst. For some cases (especially when rendering components 
are involved in the test), you need to enable the <code>test-support</code> feature.</p>
<h2><a class="header" href="#profiling" id="profiling">Profiling</a></h2>
<p>To enable the profiler, you can use the following feature:</p>
<pre><code class="language-ignore">cargo (build/test/run) --features profiler
</code></pre>
<p>The next time you will run a project, upon closing it, a file will be created at the root of the project called <code>thread_profile.json</code>.
You can open this file using the chromium browser (or google chrome) and navigating to <a href="chrome://tracing">chrome://tracing</a></p>
<h2><a class="header" href="#nightly" id="nightly">Nightly</a></h2>
<blockquote>
<p><strong>Note:</strong> Only applicable to Amethyst 0.14 and earlier.</p>
<p>Version after 0.14 no longer have the <code>&quot;nightly&quot;</code> feature, as the type names are available on stable Rust.</p>
</blockquote>
<p>Enabling the <code>nightly</code> feature adds a bit of debug information when running into runtime issues. To
use it, you need to use the nightly rust compiler toolchain.</p>
<p>Here is how to enable it:</p>
<pre><code class="language-ignore">cargo (build/test/run) --features nightly
</code></pre>
<p>The most common use of this feature is to find out the type name of the resource that is missing, such as when a <code>Resources::fetch()</code> or <code>World::read_resource()</code> invocation fails.</p>
<h2><a class="header" href="#amethyst-as-a-dependency" id="amethyst-as-a-dependency">Amethyst as a dependency</a></h2>
<p>When using Amethyst as a dependency of your project, you can use the following to disable default features and enable other ones.</p>
<pre><code class="language-ignore">[dependencies.amethyst]
version = &quot;*&quot;
default-features = false
features = [&quot;audio&quot;, &quot;animation&quot;] # you can add more or replace those
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="style/book.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
