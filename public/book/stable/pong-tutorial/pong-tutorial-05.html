<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Winning Rounds and Keeping Score - Amethyst Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../style/book.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../concepts/intro.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/state.html"><strong aria-hidden="true">3.1.</strong> State</a></li><li class="chapter-item expanded "><a href="../concepts/entity_and_component.html"><strong aria-hidden="true">3.2.</strong> Entity and Component</a></li><li class="chapter-item expanded "><a href="../concepts/resource.html"><strong aria-hidden="true">3.3.</strong> Resource</a></li><li class="chapter-item expanded "><a href="../concepts/world.html"><strong aria-hidden="true">3.4.</strong> World</a></li><li class="chapter-item expanded "><a href="../concepts/system.html"><strong aria-hidden="true">3.5.</strong> System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/system/system_initialization.html"><strong aria-hidden="true">3.5.1.</strong> System Initialization</a></li><li class="chapter-item expanded "><a href="../concepts/system/system_desc_derive.html"><strong aria-hidden="true">3.5.2.</strong> SystemDesc Derive</a></li><li class="chapter-item expanded "><a href="../concepts/system/implementing_the_system_desc_trait.html"><strong aria-hidden="true">3.5.3.</strong> Implementing the SystemDesc Trait</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/dispatcher.html"><strong aria-hidden="true">3.6.</strong> Dispatcher</a></li><li class="chapter-item expanded "><a href="../concepts/event-channel.html"><strong aria-hidden="true">3.7.</strong> Event Channel</a></li></ol></li><li class="chapter-item expanded "><a href="../pong-tutorial.html"><strong aria-hidden="true">4.</strong> Pong Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-01.html"><strong aria-hidden="true">4.1.</strong> Setting up the project</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-02.html"><strong aria-hidden="true">4.2.</strong> Drawing the Paddles</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-03.html"><strong aria-hidden="true">4.3.</strong> Moving the Paddles</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-04.html"><strong aria-hidden="true">4.4.</strong> Making a Ball Move and Bounce</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-05.html" class="active"><strong aria-hidden="true">4.5.</strong> Winning Rounds and Keeping Score</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-06.html"><strong aria-hidden="true">4.6.</strong> Adding audio</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/contribution.html"><strong aria-hidden="true">4.7.</strong> Call for Contribution</a></li></ol></li><li class="chapter-item expanded "><a href="../math.html"><strong aria-hidden="true">5.</strong> Math</a></li><li class="chapter-item expanded "><a href="../input.html"><strong aria-hidden="true">6.</strong> Input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../input/handling_input.html"><strong aria-hidden="true">6.1.</strong> Handling Input</a></li><li class="chapter-item expanded "><a href="../input/how_to_define_custom_control_bindings.html"><strong aria-hidden="true">6.2.</strong> How to Define Custom Control Bindings</a></li></ol></li><li class="chapter-item expanded "><a href="../assets.html"><strong aria-hidden="true">7.</strong> Assets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../assets/formats.html"><strong aria-hidden="true">7.1.</strong> Formats</a></li><li class="chapter-item expanded "><a href="../assets/how_to_use_assets.html"><strong aria-hidden="true">7.2.</strong> How to Use Assets</a></li><li class="chapter-item expanded "><a href="../assets/how_to_define_custom_assets.html"><strong aria-hidden="true">7.3.</strong> How to Define Custom Assets</a></li><li class="chapter-item expanded "><a href="../assets/how_to_define_custom_formats.html"><strong aria-hidden="true">7.4.</strong> How to Define Custom Formats</a></li></ol></li><li class="chapter-item expanded "><a href="../prefabs.html"><strong aria-hidden="true">8.</strong> Prefabs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../prefabs/prefabs_in_amethyst.html"><strong aria-hidden="true">8.1.</strong> Prefabs in Amethyst</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_prelude.html"><strong aria-hidden="true">8.2.</strong> How to Define Prefabs: Prelude</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_simple.html"><strong aria-hidden="true">8.3.</strong> How to Define Prefabs: Simple</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_aggregate.html"><strong aria-hidden="true">8.4.</strong> How to Define Prefabs: Aggregate</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_adapter.html"><strong aria-hidden="true">8.5.</strong> How to Define Prefabs: Adapter</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_asset.html"><strong aria-hidden="true">8.6.</strong> How to Define Prefabs: Asset</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_multi_handle.html"><strong aria-hidden="true">8.7.</strong> How to Define Prefabs: Multi-Handle</a></li><li class="chapter-item expanded "><a href="../prefabs/prefabs_technical_explanation.html"><strong aria-hidden="true">8.8.</strong> Prefabs Technical Explanation</a></li></ol></li><li class="chapter-item expanded "><a href="../animation.html"><strong aria-hidden="true">9.</strong> Animation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../animation/interpolation.html"><strong aria-hidden="true">9.1.</strong> Interpolation</a></li><li class="chapter-item expanded "><a href="../animation/channel.html"><strong aria-hidden="true">9.2.</strong> Channel</a></li><li class="chapter-item expanded "><a href="../animation/sampler.html"><strong aria-hidden="true">9.3.</strong> Sampler</a></li><li class="chapter-item expanded "><a href="../animation/definition.html"><strong aria-hidden="true">9.4.</strong> Definition</a></li></ol></li><li class="chapter-item expanded "><a href="../controlling_system_execution.html"><strong aria-hidden="true">10.</strong> Controlling System Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../controlling_system_execution/custom_game_data.html"><strong aria-hidden="true">10.1.</strong> Custom GameData</a></li><li class="chapter-item expanded "><a href="../controlling_system_execution/state-specific_dispatcher.html"><strong aria-hidden="true">10.2.</strong> State-specific Dispatcher</a></li><li class="chapter-item expanded "><a href="../controlling_system_execution/pausable_systems.html"><strong aria-hidden="true">10.3.</strong> Pausable Systems</a></li></ol></li><li class="chapter-item expanded "><a href="../sprites.html"><strong aria-hidden="true">11.</strong> Sprites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sprites/set_up_the_render_pass.html"><strong aria-hidden="true">11.1.</strong> Set Up The Render Pass</a></li><li class="chapter-item expanded "><a href="../sprites/load_the_texture.html"><strong aria-hidden="true">11.2.</strong> Load The Texture</a></li><li class="chapter-item expanded "><a href="../sprites/define_the_sprite_sheet.html"><strong aria-hidden="true">11.3.</strong> Define The SpriteSheet</a></li><li class="chapter-item expanded "><a href="../sprites/sprite_render_component.html"><strong aria-hidden="true">11.4.</strong> SpriteRender Component</a></li><li class="chapter-item expanded "><a href="../sprites/modify_the_texture.html"><strong aria-hidden="true">11.5.</strong> Modify The Texture</a></li><li class="chapter-item expanded "><a href="../sprites/orthographic_camera.html"><strong aria-hidden="true">11.6.</strong> Orthographic Camera</a></li></ol></li><li class="chapter-item expanded "><a href="../tiles.html"><strong aria-hidden="true">12.</strong> Tiles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tiles/setup.html"><strong aria-hidden="true">12.1.</strong> Setup Features and Render Pass</a></li><li class="chapter-item expanded "><a href="../tiles/create_a_tile_map.html"><strong aria-hidden="true">12.2.</strong> Create a Tile Map</a></li></ol></li><li class="chapter-item expanded "><a href="../ui/introduction.html"><strong aria-hidden="true">13.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ui/simple_button.html"><strong aria-hidden="true">13.1.</strong> Creating a simple button</a></li><li class="chapter-item expanded "><a href="../ui/interacting.html"><strong aria-hidden="true">13.2.</strong> Interacting with the UI</a></li><li class="chapter-item expanded "><a href="../ui/state_interaction.html"><strong aria-hidden="true">13.3.</strong> Interacting through a state</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">14.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/test_examples.html"><strong aria-hidden="true">14.1.</strong> Test Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../glossary.html"><strong aria-hidden="true">15.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/a_config_files.html"><strong aria-hidden="true">16.</strong> Appendix A: Config Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendices/a_config_files/arena_config.html"><strong aria-hidden="true">16.1.</strong> Adding an Arena Config</a></li><li class="chapter-item expanded "><a href="../appendices/a_config_files/ball_config.html"><strong aria-hidden="true">16.2.</strong> Adding a Ball Config</a></li><li class="chapter-item expanded "><a href="../appendices/a_config_files/paddle_configs.html"><strong aria-hidden="true">16.3.</strong> Adding Paddle Configs</a></li></ol></li><li class="chapter-item expanded "><a href="../appendices/b_migration_notes.html"><strong aria-hidden="true">17.</strong> Appendix B: Migration Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendices/b_migration_notes/cgmath_to_nalgebra.html"><strong aria-hidden="true">17.1.</strong> cgmath to nalgebra</a></li><li class="chapter-item expanded "><a href="../appendices/b_migration_notes/rendy_migration.html"><strong aria-hidden="true">17.2.</strong> Rendy Migration</a></li><li class="chapter-item expanded "><a href="../appendices/b_migration_notes/specs_migration.html"><strong aria-hidden="true">17.3.</strong> Specs Migration</a></li></ol></li><li class="chapter-item expanded "><a href="../appendices/c_feature_gates.html"><strong aria-hidden="true">18.</strong> Appendix C: Feature Gates</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Amethyst Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#winning-rounds-and-keeping-score" id="winning-rounds-and-keeping-score">Winning Rounds and Keeping Score</a></h1>
<p>Our last chapter ended on a bit of a cliffhanger. What happens when our ball
reaches the left or right edge of the screen? It just keeps going! ðŸ˜¦</p>
<p>In this chapter, we'll fix that by putting the ball back into play after it
leaves either side of the arena. We'll also add a scoreboard and keep track of
who's winning and losing.</p>
<h2><a class="header" href="#winning-and-losing-rounds" id="winning-and-losing-rounds">Winning and Losing Rounds</a></h2>
<p>So let's fix the big current issue; having a game that only works for one
round isn't very fun. We'll add a new system that will check if the ball has
reached either edge of the arena and reset its position and velocity. We'll also
make a note of who got the point for the round.</p>
<p>First, we'll add a new module to <code>systems/mod.rs</code></p>
<pre><code class="language-rust ignore">pub use self::winner::WinnerSystem;

mod winner;
</code></pre>
<p>Then, we'll create <code>systems/winner.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">        pub radius: f32,
</span><span class="boring">        pub velocity: [f32; 2],
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">        type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_WIDTH: f32 = 100.0;
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::transform::Transform,
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{Join, System, SystemData, World, WriteStorage},
};

use crate::pong::{Ball, ARENA_WIDTH, ARENA_HEIGHT};

#[derive(SystemDesc)]
pub struct WinnerSystem;

impl&lt;'s&gt; System&lt;'s&gt; for WinnerSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
    );

    fn run(&amp;mut self, (mut balls, mut locals): Self::SystemData) {
        for (ball, transform) in (&amp;mut balls, &amp;mut locals).join() {
            let ball_x = transform.translation().x;

            let did_hit = if ball_x &lt;= ball.radius {
                // Right player scored on the left side.
                println!(&quot;Player 2 Scores!&quot;);
                true
            } else if ball_x &gt;= ARENA_WIDTH - ball.radius {
                // Left player scored on the right side.
                println!(&quot;Player 1 Scores!&quot;);
                true
            } else {
                false
            };

            if did_hit {
                ball.velocity[0] = -ball.velocity[0]; // Reverse Direction
                transform.set_translation_x(ARENA_WIDTH / 2.0); // Reset Position
                transform.set_translation_y(ARENA_HEIGHT / 2.0); // Reset Position
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Here, we're creating a new system, joining on all <code>Entities</code> that have a <code>Ball</code>
and a <code>Transform</code> component, and then checking each ball to see if it has
reached either the left or right boundary of the arena. If so, we reverse
its direction and put it back in the middle of the screen.</p>
<p>Now, we just need to add our new system to <code>main.rs</code>, and we should be able to
keep playing after someone scores and log who got the point.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">   core::transform::TransformBundle,
</span><span class="boring">   ecs::{World, WorldExt},
</span><span class="boring">   prelude::*,
</span><span class="boring">   input::StringBindings,
</span><span class="boring">   window::DisplayConfig,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">mod systems {
</span><span class="boring">    use amethyst;
</span><span class="boring">    use amethyst::core::SystemDesc;
</span><span class="boring">    use amethyst::core::ecs::{System, SystemData, World};
</span><span class="boring">    use amethyst::derive::SystemDesc;
</span><span class="boring">
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct PaddleSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct MoveBallsSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MoveBallsSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct BounceSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for BounceSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">    #[derive(SystemDesc)]
</span><span class="boring">    pub struct WinnerSystem;
</span><span class="boring">    impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for WinnerSystem {
</span><span class="boring">        type SystemData = ();
</span><span class="boring">        fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">
</span><span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">let input_bundle = amethyst::input::InputBundle::&lt;StringBindings&gt;::new();
</span><span class="boring">
</span>let game_data = GameDataBuilder::default()
<span class="boring">   .with_bundle(TransformBundle::new())?
</span><span class="boring">   .with_bundle(input_bundle)?
</span><span class="boring">   .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;])
</span><span class="boring">   .with(systems::MoveBallsSystem, &quot;ball_system&quot;, &amp;[])
</span><span class="boring">   .with(
</span><span class="boring">       systems::BounceSystem,
</span><span class="boring">       &quot;collision_system&quot;,
</span><span class="boring">       &amp;[&quot;paddle_system&quot;, &quot;ball_system&quot;],
</span><span class="boring">   )
</span>    .with(systems::WinnerSystem, &quot;winner_system&quot;, &amp;[&quot;ball_system&quot;]);
<span class="boring">
</span><span class="boring">let assets_dir = &quot;/&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<h2><a class="header" href="#adding-a-scoreboard" id="adding-a-scoreboard">Adding a Scoreboard</a></h2>
<p>We have a pretty functional Pong game now! At this point, the least fun thing
about the game is just that players have to keep track of the score themselves.
Our game should be able to do that for us.</p>
<p>In this section, we'll set up UI rendering for our game and create a scoreboard
to display our players' scores.</p>
<p>First, let's add the UI rendering in <code>main.rs</code>. Add the following imports:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::ui::{RenderUi, UiBundle};
</code></pre>
<p>Then, add a <code>RenderUi</code> plugin to your <code>RenderBundle</code> like so:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">    renderer::{
</span><span class="boring">        types::DefaultBackend,
</span><span class="boring">        RenderingBundle,
</span><span class="boring">    },
</span><span class="boring">    ui::RenderUi,
</span><span class="boring">};
</span><span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt;{
</span><span class="boring">let game_data = GameDataBuilder::default()
</span>    .with_bundle(RenderingBundle::&lt;DefaultBackend&gt;::new()
        // ...
            .with_plugin(RenderUi::default()),
    )?;
<span class="boring">Ok(()) }
</span></code></pre>
<p>Finally, add the <code>UiBundle</code> after the <code>InputBundle</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    input::StringBindings,
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">use amethyst::ui::UiBundle;
</span><span class="boring">fn main() -&gt; Result&lt;(), amethyst::Error&gt;{
</span><span class="boring">let display_config_path = &quot;&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">let game_data = GameDataBuilder::default()
</span>.with_bundle(UiBundle::&lt;StringBindings&gt;::new())?
<span class="boring">;
</span><span class="boring">
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>We're adding a <code>RenderUi</code> to our <code>RenderBundle</code>, and we're also adding the
<code>UiBundle</code> to our game data. This allows us to start
rendering UI visuals to our game in addition to the existing background and
sprites.</p>
<blockquote>
<p><strong>Note:</strong> We're using a <code>UiBundle</code> with type <code>StringBindings</code> here because the
<code>UiBundle</code> needs to know what types our <code>InputHandler</code> is using to map <code>actions</code>
and <code>axes</code>. So just know that your <code>UiBundle</code> type should match your
<code>InputHandler</code> type. You can read more about those here: <a href="https://docs.amethyst.rs/stable/amethyst_ui/struct.UiBundle.html">UiBundle</a>,
<a href="https://docs.amethyst.rs/stable/amethyst_input/struct.InputHandler.html">InputHandler</a>.</p>
</blockquote>
<p>Now we have everything set up so we can start rendering a scoreboard in our
game. We'll start by creating some structures in <code>pong.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    // --snip--
    ecs::{Component, DenseVecStorage, Entity},
};

/// ScoreBoard contains the actual score data
#[derive(Default)]
pub struct ScoreBoard {
    pub score_left: i32,
    pub score_right: i32,
}

/// ScoreText contains the ui text components that display the score
pub struct ScoreText {
    pub p1_score: Entity,
    pub p2_score: Entity,
}
</code></pre>
<blockquote>
<p>Don't glimpse over the <code>#[derive(Default)]</code> annotation for the <code>ScoreBoard</code> struct!</p>
</blockquote>
<p><code>ScoreBoard</code> is just a container that will allow us to keep track of each
player's score. We'll use this in another module later in this chapter, so we've
gone ahead and marked it as public (same with <code>ScoreText</code>). <code>ScoreText</code> is also
a container, but this one holds handles to the UI <code>Entity</code>s that will be
rendered to the screen. We'll create those next:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
<span class="boring">    assets::{AssetStorage, Loader},
</span><span class="boring">    ecs::Entity,
</span><span class="boring">    prelude::*,
</span>    // ...
    ui::{Anchor, LineMode, TtfFormat, UiText, UiTransform},
};

<span class="boring">pub struct Pong;
</span><span class="boring">
</span>impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
<span class="boring">      let world = data.world;
</span>        // --snip--

        initialise_scoreboard(world);
    }
}
// ...

/// Initialises a ui scoreboard
fn initialise_scoreboard(world: &amp;mut World) {
    let font = world.read_resource::&lt;Loader&gt;().load(
        &quot;font/square.ttf&quot;,
        TtfFormat,
        (),
        &amp;world.read_resource(),
    );
    let p1_transform = UiTransform::new(
        &quot;P1&quot;.to_string(), Anchor::TopMiddle, Anchor::TopMiddle,
        -50., -50., 1., 200., 50.,
    );
    let p2_transform = UiTransform::new(
        &quot;P2&quot;.to_string(), Anchor::TopMiddle, Anchor::TopMiddle,
        50., -50., 1., 200., 50.,
    );

    let p1_score = world
        .create_entity()
        .with(p1_transform)
        .with(UiText::new(
            font.clone(),
            &quot;0&quot;.to_string(),
            [1., 1., 1., 1.],
            50.,
            LineMode::Single,
            Anchor::Middle,
        ))
        .build();

    let p2_score = world
        .create_entity()
        .with(p2_transform)
        .with(UiText::new(
            font,
            &quot;0&quot;.to_string(),
            [1., 1., 1., 1.],
            50.,
            LineMode::Single,
            Anchor::Middle,
        ))
        .build();

<span class="boring">pub struct ScoreText {pub p1_score: Entity,pub p2_score: Entity,}
</span>    world.insert(ScoreText { p1_score, p2_score });
}
</code></pre>
<p>Here, we add some UI imports and create a new <code>initialise_scoreboard</code> function,
which we'll call in the <code>on_start</code> method of the <code>Pong</code> game state.</p>
<p>Inside <code>initialise_scoreboard</code>, we're first going to load up a font which we've
saved to <code>assets/font/square.ttf</code> (<a href="https://github.com/amethyst/amethyst/raw/master/examples/pong_tutorial_05/assets/font/square.ttf">download</a>). We pull
in the <code>TtfFormat</code> to match this font type, load the font as a resource in the
world, and then save the handle to a <code>font</code> variable (which we'll use to create
our <code>UiText</code> components).</p>
<p>Next, we create a transform for each of our two scores by giving them a unique
id (<code>P1</code> and <code>P2</code>), a UI <code>Anchor</code> at the top middle of our window, and then
adjust their global <code>x</code>, <code>y</code>, and <code>z</code> coordinates, <code>width</code>, <code>height</code>, and
<code>tab-order</code>.</p>
<p>After creating the <code>font</code> and <code>transform</code>s, we'll create an <code>Entity</code> in the
world for each of our players' scores, with their <code>transform</code> and a <code>UiText</code>
component (with a <code>font</code> handle, initial <code>text</code>, <code>color</code>, and <code>font_size</code>).</p>
<p>Finally, we initialize a <code>ScoreText</code> structure containing each of our UI
<code>Entity</code>s and add it as a resource to the world so we can access it from our
<code>System</code>s later.</p>
<p>If we've done everything right so far, we should see <code>0</code> <code>0</code> at the top of our
game window. You'll notice that the scores don't update yet when the ball makes
it to either side, so we'll add that next!</p>
<h2><a class="header" href="#updating-the-scoreboard" id="updating-the-scoreboard">Updating the Scoreboard</a></h2>
<p>All that's left for us to do now is update the UI whenever a player scores a
point. You'll see just how easy this is with our <code>ECS</code> design. All we have to do
is modify our <code>WinnerSystem</code> to access the players' scores and update them
accordingly:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">        pub radius: f32,
</span><span class="boring">        pub velocity: [f32; 2],
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">        type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(Default)]
</span><span class="boring">    pub struct ScoreBoard {
</span><span class="boring">        pub score_left: i32,
</span><span class="boring">        pub score_right: i32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct ScoreText {
</span><span class="boring">        pub p1_score: Entity,
</span><span class="boring">        pub p2_score: Entity,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_WIDTH: f32 = 100.0;
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
<span class="boring">    core::transform::Transform,
</span><span class="boring">    core::SystemDesc,
</span><span class="boring">    derive::SystemDesc,
</span>    // --snip--
    ecs::{Join, ReadExpect, System, SystemData, World, Write, WriteStorage},
    ui::UiText,
};

use crate::pong::{Ball, ScoreBoard, ScoreText, ARENA_WIDTH, ARENA_HEIGHT};

#[derive(SystemDesc)]
pub struct WinnerSystem;

impl&lt;'s&gt; System&lt;'s&gt; for WinnerSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
        WriteStorage&lt;'s, UiText&gt;,
        Write&lt;'s, ScoreBoard&gt;,
        ReadExpect&lt;'s, ScoreText&gt;,
    );

    fn run(&amp;mut self, (
        mut balls,
        mut locals,
        mut ui_text,
        mut scores,
        score_text
    ): Self::SystemData) {
        for (ball, transform) in (&amp;mut balls, &amp;mut locals).join() {
<span class="boring">            let ball_x = transform.translation().x;
</span>            // --snip--

            let did_hit = if ball_x &lt;= ball.radius {
                // Right player scored on the left side.
                // We top the score at 999 to avoid text overlap.
                scores.score_right = (scores.score_right + 1)
                    .min(999);

                if let Some(text) = ui_text.get_mut(score_text.p2_score) {
                    text.text = scores.score_right.to_string();
                }
                true
            } else if ball_x &gt;= ARENA_WIDTH - ball.radius {
                // Left player scored on the right side.
                // We top the score at 999 to avoid text overlap.
                scores.score_left = (scores.score_left + 1)
                    .min(999);
                if let Some(text) = ui_text.get_mut(score_text.p1_score) {
                    text.text = scores.score_left.to_string();
                }
                true
            } else {
                false
            };

            if did_hit {
<span class="boring">                ball.velocity[0] = -ball.velocity[0]; // Reverse Direction
</span><span class="boring">                transform.set_translation_x(ARENA_WIDTH / 2.0); // Reset Position
</span><span class="boring">                transform.set_translation_y(ARENA_HEIGHT / 2.0); // Reset Position
</span>
                // --snip--

                // Print the scoreboard.
                println!(
                    &quot;Score: | {:^3} | {:^3} |&quot;,
                    scores.score_left, scores.score_right
                );
            }
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>We've added a fair few changes here, so let's go through them. First, we want to
be able to read and write our scores, so we add the <code>UiText</code> storage, which
holds all <code>UiText</code> components, to our <code>SystemData</code>. We'll want to select our
players' scores from that, so we also add the <code>ScoreText</code> structure which holds
handles to the <code>UiText</code> components that we want. Finally, we add the
<code>ScoreBoard</code> resource so we can keep track of the actual score data.</p>
<p>We're using <code>Write</code> here to pull in the <code>ScoreBoard</code> instead of with
<code>WriteStorage</code> because we want mutable access to <code>ScoreBoard</code>, which is not a
collection of components but rather a single resource item. This item is
strictly required in all cases, but if we wanted it to be optional we could
use <code>Option&lt;Write&lt;'s, ScoreBoard&gt;&gt;</code> instead.</p>
<p>We also use <code>ReadExpect</code> to access the <code>ScoreText</code> resource immutably. Again,
<code>ScoreText</code> is a single resource item rather than a collection of components.
With <code>ReadExpect</code>, we are asserting that <code>ScoreText</code> must already exist and will
panic if it does not. We do this instead of just using <code>Read</code> because we are
manually adding the <code>ScoreText</code> resource to the game in
<code>pong.rs &gt; initialise_scoreboard</code> instead of having the system create this
resource for us automatically.</p>
<p>Inside our <code>run</code> method (after updating the signature to match our <code>SystemData</code>
changes), we replace the <code>println!</code> statements with code that will update our
<code>UiText</code> components. We first update the score stored in <code>score_board</code> by
adding 1 to it and clamping it to not exceed <code>999</code> (mostly because we don't want
our scores to overlap each other in the window). Then, we use the <code>UiText</code>
<code>Entity</code> handle that we stored in our <code>ScoreText</code> resource to get a mutable
reference to our <code>UiText</code> component. Lastly, we set the text of the <code>UiText</code>
component to the player's score, after converting it to a string.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>And that's it! Our game now keeps track of the score for us and displays it at
the top of our window.</p>
<p><img src="../images/pong_tutorial/pong_05.png" alt="Pong Game with Scores" /></p>
<p>Now don't go just yet, because, in the next chapter, we'll make our Pong game
even better by adding sound effects and even some music!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../pong-tutorial/pong-tutorial-04.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../pong-tutorial/pong-tutorial-06.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../pong-tutorial/pong-tutorial-04.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../pong-tutorial/pong-tutorial-06.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../style/book.js"></script>
        

        

    </body>
</html>
