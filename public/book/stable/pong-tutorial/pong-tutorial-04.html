<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Making a Ball Move and Bounce - Amethyst Documentation</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../style/book.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../concepts/intro.html"><strong aria-hidden="true">3.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/state.html"><strong aria-hidden="true">3.1.</strong> State</a></li><li class="chapter-item expanded "><a href="../concepts/entity_and_component.html"><strong aria-hidden="true">3.2.</strong> Entity and Component</a></li><li class="chapter-item expanded "><a href="../concepts/resource.html"><strong aria-hidden="true">3.3.</strong> Resource</a></li><li class="chapter-item expanded "><a href="../concepts/world.html"><strong aria-hidden="true">3.4.</strong> World</a></li><li class="chapter-item expanded "><a href="../concepts/system.html"><strong aria-hidden="true">3.5.</strong> System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concepts/system/system_initialization.html"><strong aria-hidden="true">3.5.1.</strong> System Initialization</a></li><li class="chapter-item expanded "><a href="../concepts/system/system_desc_derive.html"><strong aria-hidden="true">3.5.2.</strong> SystemDesc Derive</a></li><li class="chapter-item expanded "><a href="../concepts/system/implementing_the_system_desc_trait.html"><strong aria-hidden="true">3.5.3.</strong> Implementing the SystemDesc Trait</a></li></ol></li><li class="chapter-item expanded "><a href="../concepts/dispatcher.html"><strong aria-hidden="true">3.6.</strong> Dispatcher</a></li><li class="chapter-item expanded "><a href="../concepts/event-channel.html"><strong aria-hidden="true">3.7.</strong> Event Channel</a></li></ol></li><li class="chapter-item expanded "><a href="../pong-tutorial.html"><strong aria-hidden="true">4.</strong> Pong Tutorial</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-01.html"><strong aria-hidden="true">4.1.</strong> Setting up the project</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-02.html"><strong aria-hidden="true">4.2.</strong> Drawing the Paddles</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-03.html"><strong aria-hidden="true">4.3.</strong> Moving the Paddles</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-04.html" class="active"><strong aria-hidden="true">4.4.</strong> Making a Ball Move and Bounce</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-05.html"><strong aria-hidden="true">4.5.</strong> Winning Rounds and Keeping Score</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/pong-tutorial-06.html"><strong aria-hidden="true">4.6.</strong> Adding audio</a></li><li class="chapter-item expanded "><a href="../pong-tutorial/contribution.html"><strong aria-hidden="true">4.7.</strong> Call for Contribution</a></li></ol></li><li class="chapter-item expanded "><a href="../math.html"><strong aria-hidden="true">5.</strong> Math</a></li><li class="chapter-item expanded "><a href="../input.html"><strong aria-hidden="true">6.</strong> Input</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../input/handling_input.html"><strong aria-hidden="true">6.1.</strong> Handling Input</a></li><li class="chapter-item expanded "><a href="../input/how_to_define_custom_control_bindings.html"><strong aria-hidden="true">6.2.</strong> How to Define Custom Control Bindings</a></li></ol></li><li class="chapter-item expanded "><a href="../assets.html"><strong aria-hidden="true">7.</strong> Assets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../assets/formats.html"><strong aria-hidden="true">7.1.</strong> Formats</a></li><li class="chapter-item expanded "><a href="../assets/how_to_use_assets.html"><strong aria-hidden="true">7.2.</strong> How to Use Assets</a></li><li class="chapter-item expanded "><a href="../assets/how_to_define_custom_assets.html"><strong aria-hidden="true">7.3.</strong> How to Define Custom Assets</a></li><li class="chapter-item expanded "><a href="../assets/how_to_define_custom_formats.html"><strong aria-hidden="true">7.4.</strong> How to Define Custom Formats</a></li></ol></li><li class="chapter-item expanded "><a href="../prefabs.html"><strong aria-hidden="true">8.</strong> Prefabs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../prefabs/prefabs_in_amethyst.html"><strong aria-hidden="true">8.1.</strong> Prefabs in Amethyst</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_prelude.html"><strong aria-hidden="true">8.2.</strong> How to Define Prefabs: Prelude</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_simple.html"><strong aria-hidden="true">8.3.</strong> How to Define Prefabs: Simple</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_aggregate.html"><strong aria-hidden="true">8.4.</strong> How to Define Prefabs: Aggregate</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_adapter.html"><strong aria-hidden="true">8.5.</strong> How to Define Prefabs: Adapter</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_asset.html"><strong aria-hidden="true">8.6.</strong> How to Define Prefabs: Asset</a></li><li class="chapter-item expanded "><a href="../prefabs/how_to_define_prefabs_multi_handle.html"><strong aria-hidden="true">8.7.</strong> How to Define Prefabs: Multi-Handle</a></li><li class="chapter-item expanded "><a href="../prefabs/prefabs_technical_explanation.html"><strong aria-hidden="true">8.8.</strong> Prefabs Technical Explanation</a></li></ol></li><li class="chapter-item expanded "><a href="../animation.html"><strong aria-hidden="true">9.</strong> Animation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../animation/interpolation.html"><strong aria-hidden="true">9.1.</strong> Interpolation</a></li><li class="chapter-item expanded "><a href="../animation/channel.html"><strong aria-hidden="true">9.2.</strong> Channel</a></li><li class="chapter-item expanded "><a href="../animation/sampler.html"><strong aria-hidden="true">9.3.</strong> Sampler</a></li><li class="chapter-item expanded "><a href="../animation/definition.html"><strong aria-hidden="true">9.4.</strong> Definition</a></li></ol></li><li class="chapter-item expanded "><a href="../controlling_system_execution.html"><strong aria-hidden="true">10.</strong> Controlling System Execution</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../controlling_system_execution/custom_game_data.html"><strong aria-hidden="true">10.1.</strong> Custom GameData</a></li><li class="chapter-item expanded "><a href="../controlling_system_execution/state-specific_dispatcher.html"><strong aria-hidden="true">10.2.</strong> State-specific Dispatcher</a></li><li class="chapter-item expanded "><a href="../controlling_system_execution/pausable_systems.html"><strong aria-hidden="true">10.3.</strong> Pausable Systems</a></li></ol></li><li class="chapter-item expanded "><a href="../sprites.html"><strong aria-hidden="true">11.</strong> Sprites</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../sprites/set_up_the_render_pass.html"><strong aria-hidden="true">11.1.</strong> Set Up The Render Pass</a></li><li class="chapter-item expanded "><a href="../sprites/load_the_texture.html"><strong aria-hidden="true">11.2.</strong> Load The Texture</a></li><li class="chapter-item expanded "><a href="../sprites/define_the_sprite_sheet.html"><strong aria-hidden="true">11.3.</strong> Define The SpriteSheet</a></li><li class="chapter-item expanded "><a href="../sprites/sprite_render_component.html"><strong aria-hidden="true">11.4.</strong> SpriteRender Component</a></li><li class="chapter-item expanded "><a href="../sprites/modify_the_texture.html"><strong aria-hidden="true">11.5.</strong> Modify The Texture</a></li><li class="chapter-item expanded "><a href="../sprites/orthographic_camera.html"><strong aria-hidden="true">11.6.</strong> Orthographic Camera</a></li></ol></li><li class="chapter-item expanded "><a href="../tiles.html"><strong aria-hidden="true">12.</strong> Tiles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tiles/setup.html"><strong aria-hidden="true">12.1.</strong> Setup Features and Render Pass</a></li><li class="chapter-item expanded "><a href="../tiles/create_a_tile_map.html"><strong aria-hidden="true">12.2.</strong> Create a Tile Map</a></li></ol></li><li class="chapter-item expanded "><a href="../ui/introduction.html"><strong aria-hidden="true">13.</strong> User Interface</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ui/simple_button.html"><strong aria-hidden="true">13.1.</strong> Creating a simple button</a></li><li class="chapter-item expanded "><a href="../ui/interacting.html"><strong aria-hidden="true">13.2.</strong> Interacting with the UI</a></li><li class="chapter-item expanded "><a href="../ui/state_interaction.html"><strong aria-hidden="true">13.3.</strong> Interacting through a state</a></li></ol></li><li class="chapter-item expanded "><a href="../testing.html"><strong aria-hidden="true">14.</strong> Testing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../testing/test_examples.html"><strong aria-hidden="true">14.1.</strong> Test Examples</a></li></ol></li><li class="chapter-item expanded "><a href="../glossary.html"><strong aria-hidden="true">15.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="../appendices/a_config_files.html"><strong aria-hidden="true">16.</strong> Appendix A: Config Files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendices/a_config_files/arena_config.html"><strong aria-hidden="true">16.1.</strong> Adding an Arena Config</a></li><li class="chapter-item expanded "><a href="../appendices/a_config_files/ball_config.html"><strong aria-hidden="true">16.2.</strong> Adding a Ball Config</a></li><li class="chapter-item expanded "><a href="../appendices/a_config_files/paddle_configs.html"><strong aria-hidden="true">16.3.</strong> Adding Paddle Configs</a></li></ol></li><li class="chapter-item expanded "><a href="../appendices/b_migration_notes.html"><strong aria-hidden="true">17.</strong> Appendix B: Migration Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../appendices/b_migration_notes/cgmath_to_nalgebra.html"><strong aria-hidden="true">17.1.</strong> cgmath to nalgebra</a></li><li class="chapter-item expanded "><a href="../appendices/b_migration_notes/rendy_migration.html"><strong aria-hidden="true">17.2.</strong> Rendy Migration</a></li><li class="chapter-item expanded "><a href="../appendices/b_migration_notes/specs_migration.html"><strong aria-hidden="true">17.3.</strong> Specs Migration</a></li></ol></li><li class="chapter-item expanded "><a href="../appendices/c_feature_gates.html"><strong aria-hidden="true">18.</strong> Appendix C: Feature Gates</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Amethyst Documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#making-a-ball-move-and-bounce" id="making-a-ball-move-and-bounce">Making a ball move and bounce</a></h1>
<p>In the previous chapter, we learned how to capture user input
to make things move on the screen by creating a <code>System</code> ourselves.
This chapter will reuse all the knowledge we acquired through the
previous chapters to add a new object to our game: a ball that moves
and bounces around!</p>
<p>First, let's define some other useful constants for this chapter in <code>pong.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub const BALL_VELOCITY_X: f32 = 75.0;
pub const BALL_VELOCITY_Y: f32 = 50.0;
pub const BALL_RADIUS: f32 = 2.0;
</code></pre>
<p>This could also be done by using an external config file. This is
especially useful when you want to edit values a lot. Here, we're
keeping it simple.</p>
<h2><a class="header" href="#create-our-next-component-the-ball-component" id="create-our-next-component-the-ball-component">Create our next Component: The ball Component!</a></h2>
<p>In <code>pong.rs</code>, let's create the <code>Ball</code> Component.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span>pub struct Ball {
    pub velocity: [f32; 2],
    pub radius: f32,
}

impl Component for Ball {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>A ball has a velocity and a radius, so we store that information in the component.</p>
<p>Then let's add an <code>initialise_ball</code> function the same way we wrote the
<code>initialise_paddles</code> function.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::assets::{Loader, AssetStorage, Handle};
</span><span class="boring">use amethyst::renderer::{Texture, SpriteRender, Sprite, SpriteSheet};
</span><span class="boring">use amethyst::core::transform::Transform;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage, World};
</span><span class="boring">pub struct Ball {
</span><span class="boring">   pub velocity: [f32; 2],
</span><span class="boring">   pub radius: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for Ball {
</span><span class="boring">   type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">const PADDLE_WIDTH: f32 = 4.0;
</span><span class="boring">const SPRITESHEET_SIZE: (f32, f32) = (8.0, 16.0);
</span><span class="boring">const BALL_RADIUS: f32 = 2.0;
</span><span class="boring">const BALL_VELOCITY_X: f32 = 75.0;
</span><span class="boring">const BALL_VELOCITY_Y: f32 = 50.0;
</span><span class="boring">const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">const ARENA_WIDTH: f32 = 100.0;
</span>/// Initialises one ball in the middle-ish of the arena.
fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) {
    // Create the translation.
    let mut local_transform = Transform::default();
    local_transform.set_translation_xyz(ARENA_WIDTH / 2.0, ARENA_HEIGHT / 2.0, 0.0);

    // Assign the sprite for the ball. The ball is the second sprite in the sheet.
    let sprite_render = SpriteRender::new(sprite_sheet_handle, 1);

    world
        .create_entity()
        .with(sprite_render)
        .with(Ball {
            radius: BALL_RADIUS,
            velocity: [BALL_VELOCITY_X, BALL_VELOCITY_Y],
        })
        .with(local_transform)
        .build();
}
</code></pre>
<p>In <a href="pong-tutorial-02.html#drawing">a previous chapter</a> we saw how to load a sprite sheet
and get things drawn on the screen. Remember sprite sheet information
is stored in <code>pong_spritesheet.ron</code>, and the ball sprite was the
second one, whose index is <code>1</code>.</p>
<p>Finally, let's make sure the code is working as intended by updating the <code>on_start</code> method:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::assets::Handle;
</span><span class="boring">use amethyst::renderer::{Texture, SpriteSheet};
</span><span class="boring">use amethyst::ecs::{Component, World, VecStorage};
</span><span class="boring">struct Paddle;
</span><span class="boring">impl Component for Paddle {
</span><span class="boring">  type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">struct Ball;
</span><span class="boring">impl Component for Ball {
</span><span class="boring">  type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    // Load the spritesheet necessary to render the graphics.
    let sprite_sheet_handle = load_sprite_sheet(world);

    world.register::&lt;Ball&gt;(); // &lt;- add this line temporarily

    initialise_ball(world, sprite_sheet_handle.clone()); // &lt;- add this line
    initialise_paddles(world, sprite_sheet_handle);
    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
<p>Don't forget to call <code>clone</code> on <code>sprite_sheet_handle</code> because <code>initialise_paddles</code> and
<code>initialise_ball</code> <em>consume</em> the handle.</p>
<p>By running the game now, you should be able to see the two paddles and the ball
in the center. In the next section, we're going to make this ball actually move!</p>
<h2><a class="header" href="#create-systems-to-make-the-ball-move" id="create-systems-to-make-the-ball-move">Create systems to make the ball move</a></h2>
<p>We're now ready to implement the <code>MoveBallsSystem</code> in <code>systems/move_balls.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">       pub velocity: [f32; 2],
</span><span class="boring">       pub radius: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">       type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::timing::Time,
    core::transform::Transform,
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{Join, Read, ReadStorage, System, SystemData, World, WriteStorage},
};

use crate::pong::Ball;

#[derive(SystemDesc)]
pub struct MoveBallsSystem;

impl&lt;'s&gt; System&lt;'s&gt; for MoveBallsSystem {
    type SystemData = (
        ReadStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
        Read&lt;'s, Time&gt;,
    );

    fn run(&amp;mut self, (balls, mut locals, time): Self::SystemData) {
        // Move every ball according to its speed, and the time passed.
        for (ball, local) in (&amp;balls, &amp;mut locals).join() {
            local.prepend_translation_x(ball.velocity[0] * time.delta_seconds());
            local.prepend_translation_y(ball.velocity[1] * time.delta_seconds());
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>This system is responsible for moving all balls according to their speed and
the elapsed time. Notice how the <code>join()</code> method is used to iterate over all
ball entities. Here we only have one ball, but if we ever need multiple, the
system will handle them out of the box.
In this system, we also want <em>framerate independence</em>.
That is, no matter the framerate, all objects move with the same speed.
To achieve that, a <strong>delta time</strong>, which is the duration since the last frame, is used.
This is commonly known as <a href="https://en.wikipedia.org/wiki/Delta_timing">&quot;delta timing&quot;</a>.
As you can see in the snippet, to gain access to time passed since the last frame,
you need to use <a href="https://docs.amethyst.rs/stable/amethyst_core/timing/struct.Time.html"><code>amethyst::core::timing::Time</code></a>, a commonly used
resource. It has a method called <code>delta_seconds</code> that does exactly what we want.</p>
<p>Now that our ball can move, let's implement a new System:
<code>BounceSystem</code> in <code>systems/bounce.rs</code>.
It will be responsible for detecting collisions between balls and
paddles, as well as balls and the top and bottom edges of the arena.
If a collision is detected, the ball bounces off. This is done
by negating the velocity of the <code>Ball</code> component on the <code>x</code> or <code>y</code> axis.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">       pub velocity: [f32; 2],
</span><span class="boring">       pub radius: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">       type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(PartialEq, Eq)]
</span><span class="boring">    pub enum Side {
</span><span class="boring">      Left,
</span><span class="boring">      Right,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct Paddle {
</span><span class="boring">      pub side: Side,
</span><span class="boring">      pub width: f32,
</span><span class="boring">      pub height: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Paddle {
</span><span class="boring">      type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::{Transform, SystemDesc},
    derive::SystemDesc,
    ecs::{Join, ReadStorage, System, SystemData, World, WriteStorage},
};

use crate::pong::{Ball, Side, Paddle, ARENA_HEIGHT};

<span class="boring">#[derive(SystemDesc)]
</span>pub struct BounceSystem;

impl&lt;'s&gt; System&lt;'s&gt; for BounceSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        ReadStorage&lt;'s, Paddle&gt;,
        ReadStorage&lt;'s, Transform&gt;,
    );

    fn run(&amp;mut self, (mut balls, paddles, transforms): Self::SystemData) {
        // Check whether a ball collided, and bounce off accordingly.
        //
        // We also check for the velocity of the ball every time, to prevent multiple collisions
        // from occurring.
        for (ball, transform) in (&amp;mut balls, &amp;transforms).join() {
            let ball_x = transform.translation().x;
            let ball_y = transform.translation().y;

            // Bounce at the top or the bottom of the arena.
            if (ball_y &lt;= ball.radius &amp;&amp; ball.velocity[1] &lt; 0.0)
                || (ball_y &gt;= ARENA_HEIGHT - ball.radius &amp;&amp; ball.velocity[1] &gt; 0.0)
            {
                ball.velocity[1] = -ball.velocity[1];
            }

            // Bounce at the paddles.
            for (paddle, paddle_transform) in (&amp;paddles, &amp;transforms).join() {
                let paddle_x = paddle_transform.translation().x - (paddle.width * 0.5);
                let paddle_y = paddle_transform.translation().y - (paddle.height * 0.5);

                // To determine whether the ball has collided with a paddle, we create a larger
                // rectangle around the current one, by subtracting the ball radius from the
                // lowest coordinates, and adding the ball radius to the highest ones. The ball
                // is then within the paddle if its center is within the larger wrapper
                // rectangle.
                if point_in_rect(
                    ball_x,
                    ball_y,
                    paddle_x - ball.radius,
                    paddle_y - ball.radius,
                    paddle_x + paddle.width + ball.radius,
                    paddle_y + paddle.height + ball.radius,
                ) {
                    if (paddle.side == Side::Left &amp;&amp; ball.velocity[0] &lt; 0.0)
                        || (paddle.side == Side::Right &amp;&amp; ball.velocity[0] &gt; 0.0)
                    {
                        ball.velocity[0] = -ball.velocity[0];
                    }
                }
            }
        }
    }
}

// A point is in a box when its coordinates are smaller or equal than the top
// right and larger or equal than the bottom left.
fn point_in_rect(x: f32, y: f32, left: f32, bottom: f32, right: f32, top: f32) -&gt; bool {
    x &gt;= left &amp;&amp; x &lt;= right &amp;&amp; y &gt;= bottom &amp;&amp; y &lt;= top
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>The following image illustrates how collisions with paddles are checked.</p>
<p><img src="../images/pong_tutorial/pong_paddle_collision.png" alt="Collision explanotary drawing" /></p>
<p>Also, don't forget to add <code>mod move_balls</code> and <code>mod bounce</code> in <code>systems/mod.rs</code>
as well as adding our new systems to the game data:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::core::transform::TransformBundle;
</span><span class="boring">use amethyst::window::DisplayConfig;
</span><span class="boring">use amethyst::input::StringBindings;
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">mod systems {
</span><span class="boring">use amethyst;
</span><span class="boring">use amethyst::core::ecs::{System, SystemData, World};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct PaddleSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct MoveBallsSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MoveBallsSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct BounceSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for BounceSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">}
</span><span class="boring">let input_bundle = amethyst::input::InputBundle::&lt;StringBindings&gt;::new();
</span>let game_data = GameDataBuilder::default()
<span class="boring">   .with_bundle(TransformBundle::new())?
</span><span class="boring">   .with_bundle(input_bundle)?
</span><span class="boring">   .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;])
</span>    // ...other systems...
    .with(systems::MoveBallsSystem, &quot;ball_system&quot;, &amp;[])
    .with(
        systems::BounceSystem,
        &quot;collision_system&quot;,
        &amp;[&quot;paddle_system&quot;, &quot;ball_system&quot;],
    );
<span class="boring">let assets_dir = &quot;/&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>You should now have a ball moving and bouncing off paddles and off the top
and bottom of the screen. However, you will quickly notice that if the ball
goes out of the screen on the right or the left, it never comes back
and the game is over. You might not even see that at all, as the ball might be already
outside of the screen when the window comes up. You might have to dramatically reduce
<code>BALL_VELOCITY_X</code> in order to see that in action. This obviously isn't a good solution for an actual game.
To fix that problem and better see what's happening we have to spawn the ball with a slight delay.</p>
<h2><a class="header" href="#spawning-ball-with-a-delay" id="spawning-ball-with-a-delay">Spawning ball with a delay</a></h2>
<p>The ball now spawns and moves off screen instantly when the game starts. This might be disorienting,
as you might be thrown into the game and lose your first point before you had the time to notice.
We also have to give some time for the operating system and the renderer to initialize the window
before the game starts. Usually, you would have a separate state with a game menu, so this isn't an issue.
Our pong game throws you right into the action, so we have to fix that problem.</p>
<p>Let's delay the first time the ball spawns. This is also a good opportunity to use our game state
struct to actually hold some data.</p>
<p>First, let's add a new method to our state: <code>update</code>.
Let's add that <code>update</code> method just below <code>on_start</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
    Trans::None
}
<span class="boring">}
</span></code></pre>
<p>That method allows you to transition out of state using its return value.
Here, we do not want to change any state, so we return <code>Trans::None</code>.</p>
<p>Now we have to move paddle creation to that method and add some delay to it. Our <code>update</code> runs every frame,
so in order to do something only once after a given time, we have to use our local state.
Additionally, notice that <code>initialise_paddles</code> requires us to provide the <code>sprite_sheet_handle</code>, but it was created
as a local variable inside <code>on_start</code>. For that reason, we have to make it a part of the state too.</p>
<p>Let's add some fields to our <code>Pong</code> struct:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst; use amethyst::renderer::SpriteSheet;
</span><span class="boring">use amethyst::assets::Handle;
</span>#[derive(Default)]
pub struct Pong {
    ball_spawn_timer: Option&lt;f32&gt;,
    sprite_sheet_handle: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
}
</code></pre>
<p>Our timer is represented by <code>Option&lt;f32&gt;</code>, which will count down to zero when available, and be replaced with <code>None</code> after
the time has passed. Our sprite sheet handle is also inside <code>Option</code> because we can't create it inside <code>Pong</code> constructor.
It will be created inside the <code>on_start</code> method instead.</p>
<p>We've also added <code>#[derive(Default)]</code>, which will automatically implement <code>Default</code> trait for us, which allows to create
default empty state. Now let's use that inside our <code>Application</code> creation code in <code>main.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)] struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">  let game_data = GameDataBuilder::default();
</span><span class="boring">  let assets_dir = &quot;/&quot;;
</span><span class="boring">  let world = World::new();
</span>let mut game = Application::new(assets_dir, Pong::default(), game_data)?;
<span class="boring">  Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Now let's finish our timer and ball spawning code. We have to do two things:</p>
<ul>
<li>First, we have to initialize our state and remove <code>initialise_ball</code> from <code>on_start</code>,</li>
<li>then we have to <code>initialise_ball</code> once after the time has passed inside <code>update</code>:</li>
</ul>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{assets::Handle, renderer::SpriteSheet};
</span><span class="boring">use amethyst::prelude::*;
</span>use amethyst::core::timing::Time;

<span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">struct Ball;
</span><span class="boring">impl amethyst::ecs::Component for Ball {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">#[derive(Default)] pub struct Pong {
</span><span class="boring">    ball_spawn_timer: Option&lt;f32&gt;,
</span><span class="boring">    sprite_sheet_handle: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = data.world;

        // Wait one second before spawning the ball.
        self.ball_spawn_timer.replace(1.0);

        // Load the spritesheet necessary to render the graphics.
        // `spritesheet` is the layout of the sprites on the image;
        // `texture` is the pixel data.
        self.sprite_sheet_handle.replace(load_sprite_sheet(world));
        initialise_paddles(world, self.sprite_sheet_handle.clone().unwrap());
        initialise_camera(world);
    }

    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        if let Some(mut timer) = self.ball_spawn_timer.take() {
            // If the timer isn't expired yet, subtract the time that passed since the last update.
            {
                let time = data.world.fetch::&lt;Time&gt;();
                timer -= time.delta_seconds();
            }
            if timer &lt;= 0.0 {
                // When timer expire, spawn the ball
                initialise_ball(data.world, self.sprite_sheet_handle.clone().unwrap());
            } else {
                // If timer is not expired yet, put it back onto the state.
                self.ball_spawn_timer.replace(timer);
            }
        }
        Trans::None
    }
}
</code></pre>
<p>Now our ball will only show up after a set delay, giving us some breathing room after startup.
This will give us a better opportunity to see what happens to the ball immediately when it spawns.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>In this chapter, we finally added a ball to our game. As always, the full code
is available under the <code>pong_tutorial_04</code> example in the Amethyst repository.
In the next chapter, we'll add a system checking when a player loses the game,
and add a scoring system!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../pong-tutorial/pong-tutorial-03.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../pong-tutorial/pong-tutorial-05.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../pong-tutorial/pong-tutorial-03.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../pong-tutorial/pong-tutorial-05.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../style/book.js"></script>
        

        

    </body>
</html>
